Only in binutils-2.35/gas: ChangeLog.orig
Only in binutils-2.35/gas: ChangeLog.rej
Only in binutils-2.35/gas: NEWS.orig
Only in binutils-2.35/gas: NEWS.rej
diff -rup binutils.orig/gas/as.c binutils-2.35/gas/as.c
--- binutils.orig/gas/as.c	2021-08-11 17:33:12.486488583 +0100
+++ binutils-2.35/gas/as.c	2021-08-11 17:41:32.630279947 +0100
@@ -345,10 +345,6 @@ Options:\n\
   fprintf (stream, _("\
   --gdwarf-sections       generate per-function section names for DWARF line information\n"));
   fprintf (stream, _("\
-  --hash-size=<value>     set the hash table size close to <value>\n"));
-  fprintf (stream, _("\
-  --help                  show this message and exit\n"));
-  fprintf (stream, _("\
   --target-help           show target specific options\n"));
   fprintf (stream, _("\
   -I DIR                  add DIR to search list for .include directives\n"));
@@ -371,10 +367,6 @@ Options:\n\
   fprintf (stream, _("\
   -R                      fold data section into text section\n"));
   fprintf (stream, _("\
-  --reduce-memory-overheads \n\
-                          prefer smaller memory use at the cost of longer\n\
-                          assembly times\n"));
-  fprintf (stream, _("\
   --statistics            print various measured statistics from execution\n"));
   fprintf (stream, _("\
   --strip-local-absolute  strip local absolute symbols\n"));
@@ -1099,22 +1091,10 @@ This program has absolutely no warranty.
 	  break;
 
 	case OPTION_REDUCE_MEMORY_OVERHEADS:
-	  /* The only change we make at the moment is to reduce
-	     the size of the hash tables that we use.  */
-	  set_gas_hash_table_size (4051);
 	  break;
 
 	case OPTION_HASH_TABLE_SIZE:
-	  {
-	    unsigned long new_size;
-
-            new_size = strtoul (optarg, NULL, 0);
-            if (new_size)
-              set_gas_hash_table_size (new_size);
-            else
-              as_fatal (_("--hash-size needs a numeric argument"));
-	    break;
-	  }
+	  break;
 	}
     }
 
Only in binutils-2.35/gas: as.c.orig
diff -rup binutils.orig/gas/as.h binutils-2.35/gas/as.h
--- binutils.orig/gas/as.h	2021-08-11 17:33:12.203490408 +0100
+++ binutils-2.35/gas/as.h	2021-08-11 17:45:01.315941347 +0100
@@ -565,6 +565,7 @@ int generic_force_reloc (struct fix *);
 
 #include "write.h"
 #include "frags.h"
+#include "hashtab.h"
 #include "hash.h"
 #include "read.h"
 #include "symbols.h"
diff -rup binutils.orig/gas/config/obj-coff-seh.c binutils-2.35/gas/config/obj-coff-seh.c
--- binutils.orig/gas/config/obj-coff-seh.c	2021-08-11 17:33:12.208490376 +0100
+++ binutils-2.35/gas/config/obj-coff-seh.c	2021-08-11 17:39:31.399057590 +0100
@@ -31,7 +31,7 @@ struct seh_seg_list {
 /* Local data.  */
 static seh_context *seh_ctx_cur = NULL;
 
-static struct hash_control *seh_hash;
+static htab_t seh_hash;
 
 static struct seh_seg_list *x_segcur = NULL;
 static struct seh_seg_list *p_segcur = NULL;
@@ -116,17 +116,13 @@ make_pxdata_seg (segT cseg, char *name)
 static void
 seh_hash_insert (const char *name, struct seh_seg_list *item)
 {
-  const char *error_string;
-
-  if ((error_string = hash_jam (seh_hash, name, (char *) item)))
-    as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
-	      name, error_string);
+  str_hash_insert (seh_hash, name, (char *) item);
 }
 
 static struct seh_seg_list *
 seh_hash_find (char *name)
 {
-  return (struct seh_seg_list *) hash_find (seh_hash, name);
+  return (struct seh_seg_list *) str_hash_find (seh_hash, name);
 }
 
 static struct seh_seg_list *
@@ -137,7 +133,7 @@ seh_hash_find_or_make (segT cseg, const
 
   /* Initialize seh_hash once.  */
   if (!seh_hash)
-    seh_hash = hash_new ();
+    seh_hash = str_htab_create ();
 
   name = get_pxdata_name (cseg, base_name);
 
diff -rup binutils.orig/gas/config/obj-coff.c binutils-2.35/gas/config/obj-coff.c
--- binutils.orig/gas/config/obj-coff.c	2021-08-11 17:33:12.214490337 +0100
+++ binutils-2.35/gas/config/obj-coff.c	2021-08-11 17:39:31.399057590 +0100
@@ -117,28 +117,24 @@ stack_pop (stack *st)
 
 /* Maintain a list of the tagnames of the structures.  */
 
-static struct hash_control *tag_hash;
+static htab_t tag_hash;
 
 static void
 tag_init (void)
 {
-  tag_hash = hash_new ();
+  tag_hash = str_htab_create ();
 }
 
 static void
 tag_insert (const char *name, symbolS *symbolP)
 {
-  const char *error_string;
-
-  if ((error_string = hash_jam (tag_hash, name, (char *) symbolP)))
-    as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
-	      name, error_string);
+  str_hash_insert (tag_hash, name, (char *) symbolP);
 }
 
 static symbolS *
 tag_find (char *name)
 {
-  return (symbolS *) hash_find (tag_hash, name);
+  return (symbolS *) str_hash_find (tag_hash, name);
 }
 
 static symbolS *
diff -rup binutils.orig/gas/config/obj-elf.c binutils-2.35/gas/config/obj-elf.c
--- binutils.orig/gas/config/obj-elf.c	2021-08-11 17:33:12.215490331 +0100
+++ binutils-2.35/gas/config/obj-elf.c	2021-08-11 17:39:31.399057590 +0100
@@ -2610,7 +2610,7 @@ struct group_list
 {
   asection **head;		/* Section lists.  */
   unsigned int num_group;	/* Number of lists.  */
-  struct hash_control *indexes; /* Maps group name to index in head array.  */
+  htab_t indexes; /* Maps group name to index in head array.  */
 };
 
 static struct group_list groups;
@@ -2648,7 +2648,7 @@ build_additional_section_info (bfd *abfd
 
   /* If this group already has a list, add the section to the head of
      the list.  */
-  elem_idx = (unsigned int *) hash_find (list->indexes, group_name);
+  elem_idx = (unsigned int *) str_hash_find (list->indexes, group_name);
   if (elem_idx != NULL)
     {
       elf_next_in_group (sec) = list->head[*elem_idx];
@@ -2670,12 +2670,15 @@ build_additional_section_info (bfd *abfd
   /* Add index to hash.  */
   idx_ptr = XNEW (unsigned int);
   *idx_ptr = i;
-  hash_insert (list->indexes, group_name, idx_ptr);
+  str_hash_insert (list->indexes, group_name, (char *)idx_ptr);
 }
 
-static void free_section_idx (const char *key ATTRIBUTE_UNUSED, void *val)
+static int
+free_section_idx (void **slot, void *arg ATTRIBUTE_UNUSED)
 {
-  free ((unsigned int *) val);
+  string_tuple_t *tuple = *((string_tuple_t **) slot);
+  free ((char *)tuple->value);
+  return 1;
 }
 
 /* Create symbols for group signature.  */
@@ -2688,7 +2691,7 @@ elf_adjust_symtab (void)
   /* Go find section groups.  */
   groups.num_group = 0;
   groups.head = NULL;
-  groups.indexes = hash_new ();
+  groups.indexes = str_htab_create ();
   bfd_map_over_sections (stdoutput, build_additional_section_info,
 			 &groups);
 
@@ -2860,8 +2863,8 @@ elf_frob_file_after_relocs (void)
     }
 
   /* Cleanup hash.  */
-  hash_traverse (groups.indexes, free_section_idx);
-  hash_die (groups.indexes);
+  htab_traverse (groups.indexes, free_section_idx, NULL);
+  htab_delete (groups.indexes);
 
 #ifdef NEED_ECOFF_DEBUG
   if (ECOFF_DEBUGGING)
Only in binutils-2.35/gas/config: obj-elf.c.orig
diff -rup binutils.orig/gas/config/tc-aarch64.c binutils-2.35/gas/config/tc-aarch64.c
--- binutils.orig/gas/config/tc-aarch64.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-aarch64.c	2021-08-11 17:40:58.180500928 +0100
@@ -451,21 +451,21 @@ get_reg_expected_msg (aarch64_reg_type r
 /* Instructions take 4 bytes in the object file.  */
 #define INSN_SIZE	4
 
-static struct hash_control *aarch64_ops_hsh;
-static struct hash_control *aarch64_cond_hsh;
-static struct hash_control *aarch64_shift_hsh;
-static struct hash_control *aarch64_sys_regs_hsh;
-static struct hash_control *aarch64_pstatefield_hsh;
-static struct hash_control *aarch64_sys_regs_ic_hsh;
-static struct hash_control *aarch64_sys_regs_dc_hsh;
-static struct hash_control *aarch64_sys_regs_at_hsh;
-static struct hash_control *aarch64_sys_regs_tlbi_hsh;
-static struct hash_control *aarch64_sys_regs_sr_hsh;
-static struct hash_control *aarch64_reg_hsh;
-static struct hash_control *aarch64_barrier_opt_hsh;
-static struct hash_control *aarch64_nzcv_hsh;
-static struct hash_control *aarch64_pldop_hsh;
-static struct hash_control *aarch64_hint_opt_hsh;
+static htab_t aarch64_ops_hsh;
+static htab_t aarch64_cond_hsh;
+static htab_t aarch64_shift_hsh;
+static htab_t aarch64_sys_regs_hsh;
+static htab_t aarch64_pstatefield_hsh;
+static htab_t aarch64_sys_regs_ic_hsh;
+static htab_t aarch64_sys_regs_dc_hsh;
+static htab_t aarch64_sys_regs_at_hsh;
+static htab_t aarch64_sys_regs_tlbi_hsh;
+static htab_t aarch64_sys_regs_sr_hsh;
+static htab_t aarch64_reg_hsh;
+static htab_t aarch64_barrier_opt_hsh;
+static htab_t aarch64_nzcv_hsh;
+static htab_t aarch64_pldop_hsh;
+static htab_t aarch64_hint_opt_hsh;
 
 /* Stuff needed to resolve the label ambiguity
    As:
@@ -764,7 +764,7 @@ parse_reg (char **ccp)
     p++;
   while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');
 
-  reg = (reg_entry *) hash_find_n (aarch64_reg_hsh, start, p - start);
+  reg = (reg_entry *) str_hash_find_n (aarch64_reg_hsh, start, p - start);
 
   if (!reg)
     return NULL;
@@ -1315,7 +1315,7 @@ insert_reg_alias (char *str, int number,
   reg_entry *new;
   const char *name;
 
-  if ((new = hash_find (aarch64_reg_hsh, str)) != 0)
+  if ((new = str_hash_find (aarch64_reg_hsh, str)) != 0)
     {
       if (new->builtin)
 	as_warn (_("ignoring attempt to redefine built-in register '%s'"),
@@ -1337,8 +1337,7 @@ insert_reg_alias (char *str, int number,
   new->type = type;
   new->builtin = FALSE;
 
-  if (hash_insert (aarch64_reg_hsh, name, (void *) new))
-    abort ();
+  str_hash_insert (aarch64_reg_hsh, name, (void *) new);
 
   return new;
 }
@@ -1367,7 +1366,7 @@ create_register_alias (char *newname, ch
   if (*oldname == '\0')
     return FALSE;
 
-  old = hash_find (aarch64_reg_hsh, oldname);
+  old = str_hash_find (aarch64_reg_hsh, oldname);
   if (!old)
     {
       as_warn (_("unknown register '%s' -- .req ignored"), oldname);
@@ -1456,7 +1455,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)
     as_bad (_("invalid syntax for .unreq directive"));
   else
     {
-      reg_entry *reg = hash_find (aarch64_reg_hsh, name);
+      reg_entry *reg = str_hash_find (aarch64_reg_hsh, name);
 
       if (!reg)
 	as_bad (_("unknown register alias '%s'"), name);
@@ -1468,7 +1467,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)
 	  char *p;
 	  char *nbuf;
 
-	  hash_delete (aarch64_reg_hsh, name, FALSE);
+	  str_hash_delete (aarch64_reg_hsh, name);
 	  free ((char *) reg->name);
 	  free (reg);
 
@@ -1479,20 +1478,20 @@ s_unreq (int a ATTRIBUTE_UNUSED)
 	  nbuf = strdup (name);
 	  for (p = nbuf; *p; p++)
 	    *p = TOUPPER (*p);
-	  reg = hash_find (aarch64_reg_hsh, nbuf);
+	  reg = str_hash_find (aarch64_reg_hsh, nbuf);
 	  if (reg)
 	    {
-	      hash_delete (aarch64_reg_hsh, nbuf, FALSE);
+	      str_hash_delete (aarch64_reg_hsh, nbuf);
 	      free ((char *) reg->name);
 	      free (reg);
 	    }
 
 	  for (p = nbuf; *p; p++)
 	    *p = TOLOWER (*p);
-	  reg = hash_find (aarch64_reg_hsh, nbuf);
+	  reg = str_hash_find (aarch64_reg_hsh, nbuf);
 	  if (reg)
 	    {
-	      hash_delete (aarch64_reg_hsh, nbuf, FALSE);
+	      str_hash_delete (aarch64_reg_hsh, nbuf);
 	      free ((char *) reg->name);
 	      free (reg);
 	    }
@@ -3122,7 +3121,7 @@ parse_shift (char **str, aarch64_opnd_in
       return FALSE;
     }
 
-  shift_op = hash_find_n (aarch64_shift_hsh, *str, p - *str);
+  shift_op = str_hash_find_n (aarch64_shift_hsh, *str, p - *str);
 
   if (shift_op == NULL)
     {
@@ -3979,7 +3978,7 @@ parse_pldop (char **str)
   while (ISALNUM (*q))
     q++;
 
-  o = hash_find_n (aarch64_pldop_hsh, p, q - p);
+  o = str_hash_find_n (aarch64_pldop_hsh, p, q - p);
   if (!o)
     return PARSE_FAIL;
 
@@ -4000,7 +3999,7 @@ parse_barrier (char **str)
   while (ISALPHA (*q))
     q++;
 
-  o = hash_find_n (aarch64_barrier_opt_hsh, p, q - p);
+  o = str_hash_find_n (aarch64_barrier_opt_hsh, p, q - p);
   if (!o)
     return PARSE_FAIL;
 
@@ -4022,7 +4021,7 @@ parse_barrier_psb (char **str,
   while (ISALPHA (*q))
     q++;
 
-  o = hash_find_n (aarch64_hint_opt_hsh, p, q - p);
+  o = str_hash_find_n (aarch64_hint_opt_hsh, p, q - p);
   if (!o)
     {
       set_fatal_syntax_error
@@ -4057,7 +4056,7 @@ parse_bti_operand (char **str,
   while (ISALPHA (*q))
     q++;
 
-  o = hash_find_n (aarch64_hint_opt_hsh, p, q - p);
+  o = str_hash_find_n (aarch64_hint_opt_hsh, p, q - p);
   if (!o)
     {
       set_fatal_syntax_error
@@ -4095,7 +4094,7 @@ parse_bti_operand (char **str,
 */
 
 static int
-parse_sys_reg (char **str, struct hash_control *sys_regs,
+parse_sys_reg (char **str, htab_t sys_regs,
 	       int imple_defined_p, int pstatefield_p,
 	       uint32_t* flags)
 {
@@ -4112,7 +4111,7 @@ parse_sys_reg (char **str, struct hash_c
   /* Assert that BUF be large enough.  */
   gas_assert (p - buf == q - *str);
 
-  o = hash_find (sys_regs, buf);
+  o = str_hash_find (sys_regs, buf);
   if (!o)
     {
       if (!imple_defined_p)
@@ -4156,7 +4155,7 @@ parse_sys_reg (char **str, struct hash_c
    for the option, or NULL.  */
 
 static const aarch64_sys_ins_reg *
-parse_sys_ins_reg (char **str, struct hash_control *sys_ins_regs)
+parse_sys_ins_reg (char **str, htab_t sys_ins_regs)
 {
   char *p, *q;
   char buf[32];
@@ -4168,7 +4167,7 @@ parse_sys_ins_reg (char **str, struct ha
       *p++ = TOLOWER (*q);
   *p = '\0';
 
-  o = hash_find (sys_ins_regs, buf);
+  o = str_hash_find (sys_ins_regs, buf);
   if (!o)
     return NULL;
 
@@ -5078,7 +5077,7 @@ lookup_mnemonic (const char *start, int
 {
   templates *templ = NULL;
 
-  templ = hash_find_n (aarch64_ops_hsh, start, len);
+  templ = str_hash_find_n (aarch64_ops_hsh, start, len);
   return templ;
 }
 
@@ -5109,7 +5108,7 @@ opcode_lookup (char **str)
   /* Handle a possible condition.  */
   if (dot)
     {
-      cond = hash_find_n (aarch64_cond_hsh, dot + 1, end - dot - 1);
+      cond = str_hash_find_n (aarch64_cond_hsh, dot + 1, end - dot - 1);
       if (cond)
 	{
 	  inst.cond = cond->value;
@@ -6160,7 +6159,7 @@ parse_operands (char *str, const aarch64
 
 	case AARCH64_OPND_NZCV:
 	  {
-	    const asm_nzcv *nzcv = hash_find_n (aarch64_nzcv_hsh, str, 4);
+	    const asm_nzcv *nzcv = str_hash_find_n (aarch64_nzcv_hsh, str, 4);
 	    if (nzcv != NULL)
 	      {
 		str += 4;
@@ -6179,7 +6178,7 @@ parse_operands (char *str, const aarch64
 	    do
 	      str++;
 	    while (ISALPHA (*str));
-	    info->cond = hash_find_n (aarch64_cond_hsh, start, str - start);
+	    info->cond = str_hash_find_n (aarch64_cond_hsh, start, str - start);
 	    if (info->cond == NULL)
 	      {
 		set_syntax_error (_("invalid condition"));
@@ -8603,13 +8602,9 @@ aarch64_adjust_symtab (void)
 }
 
 static void
-checked_hash_insert (struct hash_control *table, const char *key, void *value)
+checked_hash_insert (htab_t table, const char *key, void *value)
 {
-  const char *hash_err;
-
-  hash_err = hash_insert (table, key, value);
-  if (hash_err)
-    printf ("Internal Error:  Can't hash %s\n", key);
+  str_hash_insert (table, key, value);
 }
 
 static void
@@ -8620,7 +8615,7 @@ fill_instruction_hash_table (void)
   while (opcode->name != NULL)
     {
       templates *templ, *new_templ;
-      templ = hash_find (aarch64_ops_hsh, opcode->name);
+      templ = str_hash_find (aarch64_ops_hsh, opcode->name);
 
       new_templ = XNEW (templates);
       new_templ->opcode = opcode;
@@ -8666,21 +8661,21 @@ md_begin (void)
   unsigned mach;
   unsigned int i;
 
-  if ((aarch64_ops_hsh = hash_new ()) == NULL
-      || (aarch64_cond_hsh = hash_new ()) == NULL
-      || (aarch64_shift_hsh = hash_new ()) == NULL
-      || (aarch64_sys_regs_hsh = hash_new ()) == NULL
-      || (aarch64_pstatefield_hsh = hash_new ()) == NULL
-      || (aarch64_sys_regs_ic_hsh = hash_new ()) == NULL
-      || (aarch64_sys_regs_dc_hsh = hash_new ()) == NULL
-      || (aarch64_sys_regs_at_hsh = hash_new ()) == NULL
-      || (aarch64_sys_regs_tlbi_hsh = hash_new ()) == NULL
-      || (aarch64_sys_regs_sr_hsh = hash_new ()) == NULL
-      || (aarch64_reg_hsh = hash_new ()) == NULL
-      || (aarch64_barrier_opt_hsh = hash_new ()) == NULL
-      || (aarch64_nzcv_hsh = hash_new ()) == NULL
-      || (aarch64_pldop_hsh = hash_new ()) == NULL
-      || (aarch64_hint_opt_hsh = hash_new ()) == NULL)
+  if ((aarch64_ops_hsh = str_htab_create ()) == NULL
+      || (aarch64_cond_hsh = str_htab_create ()) == NULL
+      || (aarch64_shift_hsh = str_htab_create ()) == NULL
+      || (aarch64_sys_regs_hsh = str_htab_create ()) == NULL
+      || (aarch64_pstatefield_hsh = str_htab_create ()) == NULL
+      || (aarch64_sys_regs_ic_hsh = str_htab_create ()) == NULL
+      || (aarch64_sys_regs_dc_hsh = str_htab_create ()) == NULL
+      || (aarch64_sys_regs_at_hsh = str_htab_create ()) == NULL
+      || (aarch64_sys_regs_tlbi_hsh = str_htab_create ()) == NULL
+      || (aarch64_sys_regs_sr_hsh = str_htab_create ()) == NULL
+      || (aarch64_reg_hsh = str_htab_create ()) == NULL
+      || (aarch64_barrier_opt_hsh = str_htab_create ()) == NULL
+      || (aarch64_nzcv_hsh = str_htab_create ()) == NULL
+      || (aarch64_pldop_hsh = str_htab_create ()) == NULL
+      || (aarch64_hint_opt_hsh = str_htab_create ()) == NULL)
     as_fatal (_("virtual memory exhausted"));
 
   fill_instruction_hash_table ();
Only in binutils-2.35/gas/config: tc-aarch64.c.orig
Only in binutils-2.35/gas/config: tc-aarch64.c.rej
diff -rup binutils.orig/gas/config/tc-alpha.c binutils-2.35/gas/config/tc-alpha.c
--- binutils.orig/gas/config/tc-alpha.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-alpha.c	2021-08-11 17:39:31.401057577 +0100
@@ -297,10 +297,10 @@ static unsigned alpha_target = AXP_OPCOD
 static const char *alpha_target_name = "<all>";
 
 /* The hash table of instruction opcodes.  */
-static struct hash_control *alpha_opcode_hash;
+static htab_t alpha_opcode_hash;
 
 /* The hash table of macro opcodes.  */
-static struct hash_control *alpha_macro_hash;
+static htab_t alpha_macro_hash;
 
 #ifdef OBJ_ECOFF
 /* The $gp relocation symbol.  */
@@ -514,7 +514,7 @@ struct alpha_reloc_tag
 };
 
 /* Hash table to link up literals with the appropriate lituse.  */
-static struct hash_control *alpha_literal_hash;
+static htab_t alpha_literal_hash;
 
 /* Sequence numbers for internal use by macros.  */
 static long next_sequence_num = -1;
@@ -589,11 +589,10 @@ get_alpha_reloc_tag (long sequence)
 
   sprintf (buffer, "!%ld", sequence);
 
-  info = (struct alpha_reloc_tag *) hash_find (alpha_literal_hash, buffer);
+  info = (struct alpha_reloc_tag *) str_hash_find (alpha_literal_hash, buffer);
   if (! info)
     {
       size_t len = strlen (buffer);
-      const char *errmsg;
 
       info = (struct alpha_reloc_tag *)
           xcalloc (sizeof (struct alpha_reloc_tag) + len, 1);
@@ -601,9 +600,7 @@ get_alpha_reloc_tag (long sequence)
       info->segment = now_seg;
       info->sequence = sequence;
       strcpy (info->string, buffer);
-      errmsg = hash_insert (alpha_literal_hash, info->string, (void *) info);
-      if (errmsg)
-	as_fatal ("%s", errmsg);
+      str_hash_insert (alpha_literal_hash, info->string, (void *) info);
 #ifdef OBJ_EVAX
       info->sym = 0;
       info->psym = 0;
@@ -1171,7 +1168,7 @@ assemble_tokens_to_insn (const char *opn
   const struct alpha_opcode *opcode;
 
   /* Search opcodes.  */
-  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
+  opcode = (const struct alpha_opcode *) str_hash_find (alpha_opcode_hash, opname);
   if (opcode)
     {
       int cpumatch;
@@ -3319,7 +3316,7 @@ assemble_tokens (const char *opname,
   if (local_macros_on)
     {
       macro = ((const struct alpha_macro *)
-	       hash_find (alpha_macro_hash, opname));
+	       str_hash_find (alpha_macro_hash, opname));
       if (macro)
 	{
 	  found_something = 1;
@@ -3333,7 +3330,7 @@ assemble_tokens (const char *opname,
     }
 
   /* Search opcodes.  */
-  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
+  opcode = (const struct alpha_opcode *) str_hash_find (alpha_opcode_hash, opname);
   if (opcode)
     {
       found_something = 1;
@@ -5419,17 +5416,14 @@ md_begin (void)
   }
 
   /* Create the opcode hash table.  */
-  alpha_opcode_hash = hash_new ();
+  alpha_opcode_hash = str_htab_create ();
 
   for (i = 0; i < alpha_num_opcodes;)
     {
-      const char *name, *retval, *slash;
+      const char *name, *slash;
 
       name = alpha_opcodes[i].name;
-      retval = hash_insert (alpha_opcode_hash, name, (void *) &alpha_opcodes[i]);
-      if (retval)
-	as_fatal (_("internal error: can't hash opcode `%s': %s"),
-		  name, retval);
+      str_hash_insert (alpha_opcode_hash, name, (void *) &alpha_opcodes[i]);
 
       /* Some opcodes include modifiers of various sorts with a "/mod"
 	 syntax, like the architecture manual suggests.  However, for
@@ -5443,7 +5437,7 @@ md_begin (void)
 	  memcpy (p, name, slash - name);
 	  strcpy (p + (slash - name), slash + 1);
 
-	  (void) hash_insert (alpha_opcode_hash, p, (void *) &alpha_opcodes[i]);
+	  (void) str_hash_insert (alpha_opcode_hash, p, (void *) &alpha_opcodes[i]);
 	  /* Ignore failures -- the opcode table does duplicate some
 	     variants in different forms, like "hw_stq" and "hw_st/q".  */
 	}
@@ -5455,17 +5449,14 @@ md_begin (void)
     }
 
   /* Create the macro hash table.  */
-  alpha_macro_hash = hash_new ();
+  alpha_macro_hash = str_htab_create ();
 
   for (i = 0; i < alpha_num_macros;)
     {
-      const char *name, *retval;
+      const char *name;
 
       name = alpha_macros[i].name;
-      retval = hash_insert (alpha_macro_hash, name, (void *) &alpha_macros[i]);
-      if (retval)
-	as_fatal (_("internal error: can't hash macro `%s': %s"),
-		  name, retval);
+      str_hash_insert (alpha_macro_hash, name, (void *) &alpha_macros[i]);
 
       while (++i < alpha_num_macros
 	     && (alpha_macros[i].name == name
@@ -5520,7 +5511,7 @@ md_begin (void)
 #endif
 
   /* Create literal lookup hash table.  */
-  alpha_literal_hash = hash_new ();
+  alpha_literal_hash = str_htab_create ();
 
   subseg_set (text_section, 0);
 }
diff -rup binutils.orig/gas/config/tc-arc.c binutils-2.35/gas/config/tc-arc.c
--- binutils.orig/gas/config/tc-arc.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-arc.c	2021-08-11 17:39:31.401057577 +0100
@@ -428,16 +428,16 @@ enum mach_selection_type
 static enum mach_selection_type mach_selection_mode = MACH_SELECTION_NONE;
 
 /* The hash table of instruction opcodes.  */
-static struct hash_control *arc_opcode_hash;
+static htab_t arc_opcode_hash;
 
 /* The hash table of register symbols.  */
-static struct hash_control *arc_reg_hash;
+static htab_t arc_reg_hash;
 
 /* The hash table of aux register symbols.  */
-static struct hash_control *arc_aux_hash;
+static htab_t arc_aux_hash;
 
 /* The hash table of address types.  */
-static struct hash_control *arc_addrtype_hash;
+static htab_t arc_addrtype_hash;
 
 #define ARC_CPU_TYPE_A6xx(NAME,EXTRA)			\
   { #NAME, ARC_OPCODE_ARC600, bfd_mach_arc_arc600,	\
@@ -704,7 +704,7 @@ arc_find_opcode (const char *name)
 {
   const struct arc_opcode_hash_entry *entry;
 
-  entry = hash_find (arc_opcode_hash, name);
+  entry = str_hash_find (arc_opcode_hash, name);
   return entry;
 }
 
@@ -754,21 +754,18 @@ arc_opcode_hash_entry_iterator_next (con
 static void
 arc_insert_opcode (const struct arc_opcode *opcode)
 {
-  const char *name, *retval;
+  const char *name;
   struct arc_opcode_hash_entry *entry;
   name = opcode->name;
 
-  entry = hash_find (arc_opcode_hash, name);
+  entry = str_hash_find (arc_opcode_hash, name);
   if (entry == NULL)
     {
       entry = XNEW (struct arc_opcode_hash_entry);
       entry->count = 0;
       entry->opcode = NULL;
 
-      retval = hash_insert (arc_opcode_hash, name, (void *) entry);
-      if (retval)
-	as_fatal (_("internal error: can't hash opcode '%s': %s"),
-		  name, retval);
+      str_hash_insert (arc_opcode_hash, name, (void *) entry);
     }
 
   entry->opcode = XRESIZEVEC (const struct arc_opcode *, entry->opcode,
@@ -1920,7 +1917,7 @@ find_opcode_match (const struct arc_opco
 		    tmpp = strdup (p);
 		    for (pp = tmpp; *pp; ++pp) *pp = TOLOWER (*pp);
 
-		    auxr = hash_find (arc_aux_hash, tmpp);
+		    auxr = str_hash_find (arc_aux_hash, tmpp);
 		    if (auxr)
 		      {
 			/* We modify the token array here, safe in the
@@ -2528,14 +2525,10 @@ md_assemble (char *str)
 static void
 declare_register (const char *name, int number)
 {
-  const char *err;
   symbolS *regS = symbol_create (name, reg_section,
 				 number, &zero_address_frag);
 
-  err = hash_insert (arc_reg_hash, S_GET_NAME (regS), (void *) regS);
-  if (err)
-    as_fatal (_("Inserting \"%s\" into register table failed: %s"),
-	      name, err);
+  str_hash_insert (arc_reg_hash, S_GET_NAME (regS), (void *) regS);
 }
 
 /* Construct symbols for each of the general registers.  */
@@ -2563,15 +2556,11 @@ declare_register_set (void)
 static void
 declare_addrtype (const char *name, int number)
 {
-  const char *err;
   symbolS *addrtypeS = symbol_create (name, undefined_section,
                                       number, &zero_address_frag);
 
-  err = hash_insert (arc_addrtype_hash, S_GET_NAME (addrtypeS),
-                     (void *) addrtypeS);
-  if (err)
-    as_fatal (_("Inserting \"%s\" into address type table failed: %s"),
-              name, err);
+  str_hash_insert (arc_addrtype_hash, S_GET_NAME (addrtypeS),
+		   (void *) addrtypeS);
 }
 
 /* Port-specific assembler initialization.  This function is called
@@ -2595,7 +2584,7 @@ md_begin (void)
   bfd_set_private_flags (stdoutput, selected_cpu.eflags);
 
   /* Set up a hash table for the instructions.  */
-  arc_opcode_hash = hash_new ();
+  arc_opcode_hash = str_htab_create ();
   if (arc_opcode_hash == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
@@ -2613,7 +2602,7 @@ md_begin (void)
     }while (opcode->name);
 
   /* Register declaration.  */
-  arc_reg_hash = hash_new ();
+  arc_reg_hash = str_htab_create ();
   if (arc_reg_hash == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
@@ -2666,7 +2655,7 @@ md_begin (void)
   memset (&arc_last_insns[0], 0, sizeof (arc_last_insns));
 
   /* Aux register declaration.  */
-  arc_aux_hash = hash_new ();
+  arc_aux_hash = str_htab_create ();
   if (arc_aux_hash == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
@@ -2674,8 +2663,6 @@ md_begin (void)
   unsigned int i;
   for (i = 0; i < arc_num_aux_regs; i++, auxr++)
     {
-      const char *retval;
-
       if (!(auxr->cpu & selected_cpu.flags))
 	continue;
 
@@ -2683,14 +2670,11 @@ md_begin (void)
 	  && !check_cpu_feature (auxr->subclass))
 	continue;
 
-      retval = hash_insert (arc_aux_hash, auxr->name, (void *) auxr);
-      if (retval)
-	as_fatal (_("internal error: can't hash aux register '%s': %s"),
-		  auxr->name, retval);
+      str_hash_insert (arc_aux_hash, auxr->name, (void *) auxr);
     }
 
   /* Address type declaration.  */
-  arc_addrtype_hash = hash_new ();
+  arc_addrtype_hash = str_htab_create ();
   if (arc_addrtype_hash == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
@@ -3396,7 +3380,7 @@ arc_parse_name (const char *name,
       && e->X_md == O_absent)
     return FALSE;
 
-  sym = hash_find (arc_reg_hash, name);
+  sym = str_hash_find (arc_reg_hash, name);
   if (sym)
     {
       e->X_op = O_register;
@@ -3404,7 +3388,7 @@ arc_parse_name (const char *name,
       return TRUE;
     }
 
-  sym = hash_find (arc_addrtype_hash, name);
+  sym = str_hash_find (arc_addrtype_hash, name);
   if (sym)
     {
       e->X_op = O_addrtype;
@@ -4369,7 +4353,7 @@ tc_arc_regname_to_dw2regnum (char *regna
 {
   struct symbol *sym;
 
-  sym = hash_find (arc_reg_hash, regname);
+  sym = str_hash_find (arc_reg_hash, regname);
   if (sym)
     return S_GET_VALUE (sym);
 
@@ -4859,7 +4843,6 @@ arc_extcorereg (int opertype)
 {
   extRegister_t ereg;
   struct arc_aux_reg *auxr;
-  const char *retval;
   struct arc_flag_operand *ccode;
 
   memset (&ereg, 0, sizeof (ereg));
@@ -4882,10 +4865,7 @@ arc_extcorereg (int opertype)
       auxr->cpu = selected_cpu.flags;
       auxr->subclass = NONE;
       auxr->address = ereg.number;
-      retval = hash_insert (arc_aux_hash, auxr->name, (void *) auxr);
-      if (retval)
-	as_fatal (_("internal error: can't hash aux register '%s': %s"),
-		  auxr->name, retval);
+      str_hash_insert (arc_aux_hash, auxr->name, (void *) auxr);
       break;
     case EXT_COND_CODE:
       /* Condition code.  */
Only in binutils-2.35/gas/config: tc-arc.c.orig
diff -rup binutils.orig/gas/config/tc-arm.c binutils-2.35/gas/config/tc-arm.c
--- binutils.orig/gas/config/tc-arm.c	2021-08-11 17:33:12.215490331 +0100
+++ binutils-2.35/gas/config/tc-arm.c	2021-08-11 17:39:31.403057564 +0100
@@ -945,15 +945,15 @@ struct asm_opcode
 #define BAD_EL_TYPE	_("bad element type for instruction")
 #define MVE_BAD_QREG	_("MVE vector register Q[0..7] expected")
 
-static struct hash_control * arm_ops_hsh;
-static struct hash_control * arm_cond_hsh;
-static struct hash_control * arm_vcond_hsh;
-static struct hash_control * arm_shift_hsh;
-static struct hash_control * arm_psr_hsh;
-static struct hash_control * arm_v7m_psr_hsh;
-static struct hash_control * arm_reg_hsh;
-static struct hash_control * arm_reloc_hsh;
-static struct hash_control * arm_barrier_opt_hsh;
+static htab_t  arm_ops_hsh;
+static htab_t  arm_cond_hsh;
+static htab_t  arm_vcond_hsh;
+static htab_t  arm_shift_hsh;
+static htab_t  arm_psr_hsh;
+static htab_t  arm_v7m_psr_hsh;
+static htab_t  arm_reg_hsh;
+static htab_t  arm_reloc_hsh;
+static htab_t  arm_barrier_opt_hsh;
 
 /* Stuff needed to resolve the label ambiguity
    As:
@@ -1427,7 +1427,7 @@ arm_reg_parse_multi (char **ccp)
     p++;
   while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');
 
-  reg = (struct reg_entry *) hash_find_n (arm_reg_hsh, start, p - start);
+  reg = (struct reg_entry *) str_hash_find_n (arm_reg_hsh, start, p - start);
 
   if (!reg)
     return NULL;
@@ -2546,7 +2546,7 @@ parse_reloc (char **str)
     return -1;
 
   if ((r = (struct reloc_entry *)
-       hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
+       str_hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
     return -1;
 
   *str = q + 1;
@@ -2561,7 +2561,7 @@ insert_reg_alias (char *str, unsigned nu
   struct reg_entry *new_reg;
   const char *name;
 
-  if ((new_reg = (struct reg_entry *) hash_find (arm_reg_hsh, str)) != 0)
+  if ((new_reg = (struct reg_entry *) str_hash_find (arm_reg_hsh, str)) != 0)
     {
       if (new_reg->builtin)
 	as_warn (_("ignoring attempt to redefine built-in register '%s'"), str);
@@ -2583,8 +2583,7 @@ insert_reg_alias (char *str, unsigned nu
   new_reg->builtin = FALSE;
   new_reg->neon = NULL;
 
-  if (hash_insert (arm_reg_hsh, name, (void *) new_reg))
-    abort ();
+  str_hash_insert (arm_reg_hsh, name, new_reg);
 
   return new_reg;
 }
@@ -2632,7 +2631,7 @@ create_register_alias (char * newname, c
   if (*oldname == '\0')
     return FALSE;
 
-  old = (struct reg_entry *) hash_find (arm_reg_hsh, oldname);
+  old = (struct reg_entry *) str_hash_find (arm_reg_hsh, oldname);
   if (!old)
     {
       as_warn (_("unknown register '%s' -- .req ignored"), oldname);
@@ -2884,7 +2883,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)
     as_bad (_("invalid syntax for .unreq directive"));
   else
     {
-      struct reg_entry *reg = (struct reg_entry *) hash_find (arm_reg_hsh,
+      struct reg_entry *reg = (struct reg_entry *) str_hash_find (arm_reg_hsh,
 							      name);
 
       if (!reg)
@@ -2897,7 +2896,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)
 	  char * p;
 	  char * nbuf;
 
-	  hash_delete (arm_reg_hsh, name, FALSE);
+	  str_hash_delete (arm_reg_hsh, name);
 	  free ((char *) reg->name);
 	  free (reg->neon);
 	  free (reg);
@@ -2909,10 +2908,10 @@ s_unreq (int a ATTRIBUTE_UNUSED)
 	  nbuf = strdup (name);
 	  for (p = nbuf; *p; p++)
 	    *p = TOUPPER (*p);
-	  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);
+	  reg = (struct reg_entry *) str_hash_find (arm_reg_hsh, nbuf);
 	  if (reg)
 	    {
-	      hash_delete (arm_reg_hsh, nbuf, FALSE);
+	      str_hash_delete (arm_reg_hsh, nbuf);
 	      free ((char *) reg->name);
 	      free (reg->neon);
 	      free (reg);
@@ -2920,10 +2919,10 @@ s_unreq (int a ATTRIBUTE_UNUSED)
 
 	  for (p = nbuf; *p; p++)
 	    *p = TOLOWER (*p);
-	  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);
+	  reg = (struct reg_entry *) str_hash_find (arm_reg_hsh, nbuf);
 	  if (reg)
 	    {
-	      hash_delete (arm_reg_hsh, nbuf, FALSE);
+	      str_hash_delete (arm_reg_hsh, nbuf);
 	      free ((char *) reg->name);
 	      free (reg->neon);
 	      free (reg);
@@ -5537,7 +5536,7 @@ parse_shift (char **str, int i, enum par
       return FAIL;
     }
 
-  shift_name = (const struct asm_shift_name *) hash_find_n (arm_shift_hsh, *str,
+  shift_name = (const struct asm_shift_name *) str_hash_find_n (arm_shift_hsh, *str,
 							    p - *str);
 
   if (shift_name == NULL)
@@ -6338,7 +6337,7 @@ parse_psr (char **str, bfd_boolean lhs)
 	  || strncasecmp (start, "psr", 3) == 0)
 	p = start + strcspn (start, "rR") + 1;
 
-      psr = (const struct asm_psr *) hash_find_n (arm_v7m_psr_hsh, start,
+      psr = (const struct asm_psr *) str_hash_find_n (arm_v7m_psr_hsh, start,
 						  p - start);
 
       if (!psr)
@@ -6441,7 +6440,7 @@ parse_psr (char **str, bfd_boolean lhs)
 	}
       else
 	{
-	  psr = (const struct asm_psr *) hash_find_n (arm_psr_hsh, start,
+	  psr = (const struct asm_psr *) str_hash_find_n (arm_psr_hsh, start,
 						      p - start);
 	  if (!psr)
 	    goto error;
@@ -6633,7 +6632,7 @@ parse_cond (char **str)
       n++;
     }
 
-  c = (const struct asm_cond *) hash_find_n (arm_cond_hsh, cond, n);
+  c = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, cond, n);
   if (!c)
     {
       inst.error = _("condition required");
@@ -6656,7 +6655,7 @@ parse_barrier (char **str)
   while (ISALPHA (*q))
     q++;
 
-  o = (const struct asm_barrier_opt *) hash_find_n (arm_barrier_opt_hsh, p,
+  o = (const struct asm_barrier_opt *) str_hash_find_n (arm_barrier_opt_hsh, p,
 						    q - p);
   if (!o)
     return FAIL;
@@ -15606,7 +15605,7 @@ do_vfp_nsyn_opcode (const char *opname)
 {
   const struct asm_opcode *opcode;
 
-  opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, opname);
+  opcode = (const struct asm_opcode *) str_hash_find (arm_ops_hsh, opname);
 
   if (!opcode)
     abort ();
@@ -22618,7 +22617,7 @@ opcode_lookup (char **str)
     *str = end;
 
   /* Look for unaffixed or special-case affixed mnemonic.  */
-  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
+  opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,
 						    end - base);
   if (opcode)
     {
@@ -22632,7 +22631,7 @@ opcode_lookup (char **str)
       if (warn_on_deprecated && unified_syntax)
 	as_tsktsk (_("conditional infixes are deprecated in unified syntax"));
       affix = base + (opcode->tag - OT_odd_infix_0);
-      cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
+      cond = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, affix, 2);
       gas_assert (cond);
 
       inst.cond = cond->value;
@@ -22645,8 +22644,8 @@ opcode_lookup (char **str)
     if (end - base < 2)
       return NULL;
      affix = end - 1;
-     cond = (const struct asm_cond *) hash_find_n (arm_vcond_hsh, affix, 1);
-     opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
+     cond = (const struct asm_cond *) str_hash_find_n (arm_vcond_hsh, affix, 1);
+     opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,
 						      affix - base);
      /* If this opcode can not be vector predicated then don't accept it with a
 	vector predication code.  */
@@ -22662,8 +22661,8 @@ opcode_lookup (char **str)
 
       /* Look for suffixed mnemonic.  */
       affix = end - 2;
-      cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
-      opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
+      cond = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, affix, 2);
+      opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,
 							affix - base);
     }
 
@@ -22713,13 +22712,13 @@ opcode_lookup (char **str)
 
   /* Look for infixed mnemonic in the usual position.  */
   affix = base + 3;
-  cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
+  cond = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, affix, 2);
   if (!cond)
     return NULL;
 
   memcpy (save, affix, 2);
   memmove (affix, affix + 2, (end - affix) - 2);
-  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
+  opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,
 						    (end - base) - 2);
   memmove (affix + 2, affix, (end - affix) - 2);
   memcpy (affix, save, 2);
@@ -27987,16 +27986,19 @@ arm_tc_equal_in_insn (int c ATTRIBUTE_UN
 
       for (p = nbuf; *p; p++)
 	*p = TOLOWER (*p);
-      if (hash_find (arm_ops_hsh, nbuf) != NULL)
+      if (str_hash_find (arm_ops_hsh, nbuf) != NULL)
 	{
-	  static struct hash_control * already_warned = NULL;
+	  static htab_t  already_warned = NULL;
 
 	  if (already_warned == NULL)
-	    already_warned = hash_new ();
+	    already_warned = str_htab_create ();
 	  /* Only warn about the symbol once.  To keep the code
-	     simple we let hash_insert do the lookup for us.  */
-	  if (hash_insert (already_warned, nbuf, NULL) == NULL)
-	    as_warn (_("[-mwarn-syms]: Assignment makes a symbol match an ARM instruction: %s"), name);
+	     simple we let str_hash_insert do the lookup for us.  */
+	  if (str_hash_find (already_warned, nbuf) == NULL)
+	    {
+	      as_warn (_("[-mwarn-syms]: Assignment makes a symbol match an ARM instruction: %s"), name);
+	      str_hash_insert (already_warned, nbuf, NULL);
+	    }
 	}
       else
 	free (nbuf);
@@ -30712,36 +30714,37 @@ md_begin (void)
   unsigned mach;
   unsigned int i;
 
-  if (	 (arm_ops_hsh = hash_new ()) == NULL
-      || (arm_cond_hsh = hash_new ()) == NULL
-      || (arm_vcond_hsh = hash_new ()) == NULL
-      || (arm_shift_hsh = hash_new ()) == NULL
-      || (arm_psr_hsh = hash_new ()) == NULL
-      || (arm_v7m_psr_hsh = hash_new ()) == NULL
-      || (arm_reg_hsh = hash_new ()) == NULL
-      || (arm_reloc_hsh = hash_new ()) == NULL
-      || (arm_barrier_opt_hsh = hash_new ()) == NULL)
+  if (	 (arm_ops_hsh = str_htab_create ()) == NULL
+      || (arm_cond_hsh = str_htab_create ()) == NULL
+      || (arm_vcond_hsh = str_htab_create ()) == NULL
+      || (arm_shift_hsh = str_htab_create ()) == NULL
+      || (arm_psr_hsh = str_htab_create ()) == NULL
+      || (arm_v7m_psr_hsh = str_htab_create ()) == NULL
+      || (arm_reg_hsh = str_htab_create ()) == NULL
+      || (arm_reloc_hsh = str_htab_create ()) == NULL
+      || (arm_barrier_opt_hsh = str_htab_create ()) == NULL)
     as_fatal (_("virtual memory exhausted"));
 
   for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
-    hash_insert (arm_ops_hsh, insns[i].template_name, (void *) (insns + i));
+    if (str_hash_find (arm_ops_hsh, insns[i].template_name) == NULL)
+      str_hash_insert (arm_ops_hsh, insns[i].template_name, (void *) (insns + i));
   for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
-    hash_insert (arm_cond_hsh, conds[i].template_name, (void *) (conds + i));
+    str_hash_insert (arm_cond_hsh, conds[i].template_name, (void *) (conds + i));
   for (i = 0; i < sizeof (vconds) / sizeof (struct asm_cond); i++)
-    hash_insert (arm_vcond_hsh, vconds[i].template_name, (void *) (vconds + i));
+    str_hash_insert (arm_vcond_hsh, vconds[i].template_name, (void *) (vconds + i));
   for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
-    hash_insert (arm_shift_hsh, shift_names[i].name, (void *) (shift_names + i));
+    str_hash_insert (arm_shift_hsh, shift_names[i].name, (void *) (shift_names + i));
   for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
-    hash_insert (arm_psr_hsh, psrs[i].template_name, (void *) (psrs + i));
+    str_hash_insert (arm_psr_hsh, psrs[i].template_name, (void *) (psrs + i));
   for (i = 0; i < sizeof (v7m_psrs) / sizeof (struct asm_psr); i++)
-    hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template_name,
+    str_hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template_name,
 		 (void *) (v7m_psrs + i));
   for (i = 0; i < sizeof (reg_names) / sizeof (struct reg_entry); i++)
-    hash_insert (arm_reg_hsh, reg_names[i].name, (void *) (reg_names + i));
+    str_hash_insert (arm_reg_hsh, reg_names[i].name, (void *) (reg_names + i));
   for (i = 0;
        i < sizeof (barrier_opt_names) / sizeof (struct asm_barrier_opt);
        i++)
-    hash_insert (arm_barrier_opt_hsh, barrier_opt_names[i].template_name,
+    str_hash_insert (arm_barrier_opt_hsh, barrier_opt_names[i].template_name,
 		 (void *) (barrier_opt_names + i));
 #ifdef OBJ_ELF
   for (i = 0; i < ARRAY_SIZE (reloc_names); i++)
@@ -30752,7 +30755,7 @@ md_begin (void)
 	/* This makes encode_branch() use the EABI versions of this relocation.  */
 	entry->reloc = BFD_RELOC_UNUSED;
 
-      hash_insert (arm_reloc_hsh, entry->name, (void *) entry);
+      str_hash_insert (arm_reloc_hsh, entry->name, (void *) entry);
     }
 #endif
 
Only in binutils-2.35/gas/config: tc-arm.c.orig
diff -rup binutils.orig/gas/config/tc-avr.c binutils-2.35/gas/config/tc-avr.c
--- binutils.orig/gas/config/tc-avr.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-avr.c	2021-08-11 17:39:31.404057558 +0100
@@ -524,13 +524,13 @@ typedef union
 } mod_index;
 
 /* Opcode hash table.  */
-static struct hash_control *avr_hash;
+static htab_t avr_hash;
 
 /* Reloc modifiers hash control (hh8,hi8,lo8,pm_xx).  */
-static struct hash_control *avr_mod_hash;
+static htab_t avr_mod_hash;
 
 /* Whether some opcode does not change SREG.  */
-static struct hash_control *avr_no_sreg_hash;
+static htab_t avr_no_sreg_hash;
 
 static const char* const avr_no_sreg[] =
   {
@@ -808,33 +808,35 @@ md_begin (void)
   unsigned int i;
   struct avr_opcodes_s *opcode;
 
-  avr_hash = hash_new ();
+  avr_hash = str_htab_create ();
 
   /* Insert unique names into hash table.  This hash table then provides a
      quick index to the first opcode with a particular name in the opcode
      table.  */
   for (opcode = avr_opcodes; opcode->name; opcode++)
-    hash_insert (avr_hash, opcode->name, (char *) opcode);
+    if (str_hash_find (avr_hash, opcode->name) == NULL)
+      str_hash_insert (avr_hash, opcode->name, (char *) opcode);
 
-  avr_mod_hash = hash_new ();
+  avr_mod_hash = str_htab_create ();
 
   for (i = 0; i < ARRAY_SIZE (exp_mod); ++i)
     {
       mod_index m;
 
       m.index = i + 10;
-      hash_insert (avr_mod_hash, EXP_MOD_NAME (i), m.ptr);
+      str_hash_find (avr_mod_hash, EXP_MOD_NAME (i));
+      str_hash_insert (avr_mod_hash, EXP_MOD_NAME (i), m.ptr);
     }
 
-  avr_no_sreg_hash = hash_new ();
+  avr_no_sreg_hash = str_htab_create ();
 
   for (i = 0; i < ARRAY_SIZE (avr_no_sreg); ++i)
     {
-      gas_assert (hash_find (avr_hash, avr_no_sreg[i]));
-      hash_insert (avr_no_sreg_hash, avr_no_sreg[i], (char*) 4 /* dummy */);
+      gas_assert (str_hash_find (avr_hash, avr_no_sreg[i]));
+      str_hash_insert (avr_no_sreg_hash, avr_no_sreg[i], (char*) 4 /* dummy */);
     }
 
-  avr_gccisr_opcode = (struct avr_opcodes_s*) hash_find (avr_hash, "__gcc_isr");
+  avr_gccisr_opcode = (struct avr_opcodes_s*) str_hash_find (avr_hash, "__gcc_isr");
   gas_assert (avr_gccisr_opcode);
 
   bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);
@@ -923,7 +925,7 @@ avr_ldi_expression (expressionS *exp)
     {
       mod_index m;
 
-      m.ptr = hash_find (avr_mod_hash, op);
+      m.ptr = str_hash_find (avr_mod_hash, op);
       mod = m.index;
 
       if (mod)
@@ -1874,7 +1876,7 @@ md_assemble (char *str)
   if (!op[0])
     as_bad (_("can't find opcode "));
 
-  opcode = (struct avr_opcodes_s *) hash_find (avr_hash, op);
+  opcode = (struct avr_opcodes_s *) str_hash_find (avr_hash, op);
 
   if (opcode && !avr_opt.all_opcodes)
     {
@@ -2453,7 +2455,7 @@ avr_update_gccisr (struct avr_opcodes_s
   /* SREG: Look up instructions that don't clobber SREG.  */
 
   if (!avr_isr.need_sreg
-      && !hash_find (avr_no_sreg_hash, opcode->name))
+      && !str_hash_find (avr_no_sreg_hash, opcode->name))
     {
       avr_isr.need_sreg = 1;
     }
@@ -2497,7 +2499,7 @@ avr_emit_insn (const char *insn, int reg
   const int sreg = 0x3f;
   unsigned bin = 0;
   const struct avr_opcodes_s *op
-    = (struct avr_opcodes_s*) hash_find (avr_hash, insn);
+    = (struct avr_opcodes_s*) str_hash_find (avr_hash, insn);
 
   /* We only have to deal with: IN, OUT, PUSH, POP, CLR, LDI 0.  All of
      these deal with at least one Reg and are 1-word instructions.  */
diff -rup binutils.orig/gas/config/tc-cr16.c binutils-2.35/gas/config/tc-cr16.c
--- binutils.orig/gas/config/tc-cr16.c	2021-08-11 17:33:12.211490357 +0100
+++ binutils-2.35/gas/config/tc-cr16.c	2021-08-11 17:39:31.404057558 +0100
@@ -53,15 +53,15 @@ typedef enum
 op_err;
 
 /* Opcode mnemonics hash table.  */
-static struct hash_control *cr16_inst_hash;
+static htab_t cr16_inst_hash;
 /* CR16 registers hash table.  */
-static struct hash_control *reg_hash;
+static htab_t reg_hash;
 /* CR16 register pair hash table.  */
-static struct hash_control *regp_hash;
+static htab_t regp_hash;
 /* CR16 processor registers hash table.  */
-static struct hash_control *preg_hash;
+static htab_t preg_hash;
 /* CR16 processor registers 32 bit hash table.  */
-static struct hash_control *pregp_hash;
+static htab_t pregp_hash;
 /* Current instruction we're assembling.  */
 const inst *instruction;
 
@@ -324,7 +324,7 @@ get_register (char *reg_name)
 {
   const reg_entry *rreg;
 
-  rreg = (const reg_entry *) hash_find (reg_hash, reg_name);
+  rreg = (const reg_entry *) str_hash_find (reg_hash, reg_name);
 
   if (rreg != NULL)
     return rreg->value.reg_val;
@@ -345,10 +345,10 @@ get_register_pair (char *reg_name)
       tmp_rp[0] = '(';
       strcat (tmp_rp, reg_name);
       strcat (tmp_rp,")");
-      rreg = (const reg_entry *) hash_find (regp_hash, tmp_rp);
+      rreg = (const reg_entry *) str_hash_find (regp_hash, tmp_rp);
     }
   else
-    rreg = (const reg_entry *) hash_find (regp_hash, reg_name);
+    rreg = (const reg_entry *) str_hash_find (regp_hash, reg_name);
 
   if (rreg != NULL)
     return rreg->value.reg_val;
@@ -363,7 +363,7 @@ get_index_register (char *reg_name)
 {
   const reg_entry *rreg;
 
-  rreg = (const reg_entry *) hash_find (reg_hash, reg_name);
+  rreg = (const reg_entry *) str_hash_find (reg_hash, reg_name);
 
   if ((rreg != NULL)
       && ((rreg->value.reg_val == 12) || (rreg->value.reg_val == 13)))
@@ -378,7 +378,7 @@ get_index_register_pair (char *reg_name)
 {
   const reg_entry *rreg;
 
-  rreg = (const reg_entry *) hash_find (regp_hash, reg_name);
+  rreg = (const reg_entry *) str_hash_find (regp_hash, reg_name);
 
   if (rreg != NULL)
     {
@@ -399,7 +399,7 @@ get_pregister (char *preg_name)
 {
   const reg_entry *prreg;
 
-  prreg = (const reg_entry *) hash_find (preg_hash, preg_name);
+  prreg = (const reg_entry *) str_hash_find (preg_hash, preg_name);
 
   if (prreg != NULL)
     return prreg->value.preg_val;
@@ -414,7 +414,7 @@ get_pregisterp (char *preg_name)
 {
   const reg_entry *prreg;
 
-  prreg = (const reg_entry *) hash_find (pregp_hash, preg_name);
+  prreg = (const reg_entry *) str_hash_find (pregp_hash, preg_name);
 
   if (prreg != NULL)
     return prreg->value.preg_val;
@@ -794,25 +794,18 @@ md_pcrel_from (fixS *fixp)
 }
 
 static void
-initialise_reg_hash_table (struct hash_control ** hash_table,
+initialise_reg_hash_table (htab_t * hash_table,
                            const reg_entry * register_table,
                            const unsigned int num_entries)
 {
   const reg_entry * rreg;
-  const char *hashret;
-
-  if ((* hash_table = hash_new ()) == NULL)
+  if ((* hash_table = str_htab_create ()) == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
   for (rreg = register_table;
        rreg < (register_table + num_entries);
        rreg++)
-    {
-      hashret = hash_insert (* hash_table, rreg->name, (char *) rreg);
-      if (hashret)
-        as_fatal (_("Internal Error:  Can't hash %s: %s"),
-                  rreg->name, hashret);
-    }
+    str_hash_insert (* hash_table, rreg->name, (char *) rreg);
 }
 
 /* This function is called once, at assembler startup time.  This should
@@ -824,21 +817,15 @@ md_begin (void)
   int i = 0;
 
   /* Set up a hash table for the instructions.  */
-  if ((cr16_inst_hash = hash_new ()) == NULL)
+  if ((cr16_inst_hash = str_htab_create ()) == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
   while (cr16_instruction[i].mnemonic != NULL)
     {
-      const char *hashret;
       const char *mnemonic = cr16_instruction[i].mnemonic;
 
-      hashret = hash_insert (cr16_inst_hash, mnemonic,
-                             (char *)(cr16_instruction + i));
-
-      if (hashret != NULL && *hashret != '\0')
-        as_fatal (_("Can't hash `%s': %s\n"), cr16_instruction[i].mnemonic,
-                  *hashret == 0 ? _("(unknown reason)") : hashret);
-
+      str_hash_insert (cr16_inst_hash, mnemonic,
+		       (char *)(cr16_instruction + i));
       /* Insert unique names into hash table.  The CR16 instruction set
          has many identical opcode names that have different opcodes based
          on the operands.  This hash table then provides a quick index to
@@ -2505,7 +2492,7 @@ cr16_assemble (const char *op, char *par
   ins cr16_ins;
 
   /* Find the instruction.  */
-  instruction = (const inst *) hash_find (cr16_inst_hash, op);
+  instruction = (const inst *) str_hash_find (cr16_inst_hash, op);
   if (instruction == NULL)
     {
       as_bad (_("Unknown opcode: `%s'"), op);
@@ -2575,7 +2562,7 @@ md_assemble (char *op)
     {
       strcpy (param1, param);
       /* Find the instruction.  */
-      instruction = (const inst *) hash_find (cr16_inst_hash, op);
+      instruction = (const inst *) str_hash_find (cr16_inst_hash, op);
        parse_operands (&cr16_ins, param1);
       if (((&cr16_ins)->arg[0].type == arg_ic)
           && ((&cr16_ins)->arg[0].constant >= 0))
diff -rup binutils.orig/gas/config/tc-cris.c binutils-2.35/gas/config/tc-cris.c
--- binutils.orig/gas/config/tc-cris.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-cris.c	2021-08-11 17:39:31.404057558 +0100
@@ -160,7 +160,7 @@ static void cris_sym_no_leading_undersco
 static char *cris_insn_first_word_frag (void);
 
 /* Handle to the opcode hash table.  */
-static struct hash_control *op_hash = NULL;
+static htab_t op_hash = NULL;
 
 /* If we target cris-axis-linux-gnu (as opposed to generic cris-axis-elf),
    we default to no underscore and required register-prefixes.  The
@@ -1186,11 +1186,10 @@ cris_insn_first_word_frag (void)
 void
 md_begin (void)
 {
-  const char *hashret = NULL;
   int i = 0;
 
   /* Set up a hash table for the instructions.  */
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
   if (op_hash == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
@@ -1222,12 +1221,8 @@ md_begin (void)
 	  continue;
 	}
 
-      /* Need to cast to get rid of "const".  FIXME: Fix hash_insert instead.  */
-      hashret = hash_insert (op_hash, name, (void *) &cris_opcodes[i]);
-
-      if (hashret != NULL && *hashret != '\0')
-	as_fatal (_("Can't hash `%s': %s\n"), cris_opcodes[i].name,
-		  *hashret == 0 ? _("(unknown reason)") : hashret);
+      /* Need to cast to get rid of "const".  FIXME: Fix str_hash_insert instead.  */
+      str_hash_insert (op_hash, name, (void *) &cris_opcodes[i]);
       do
 	{
 	  if (cris_opcodes[i].match & cris_opcodes[i].lose)
@@ -1558,7 +1553,7 @@ cris_process_instruction (char *insn_tex
     }
 
   /* Find the instruction.  */
-  instruction = (struct cris_opcode *) hash_find (op_hash, insn_text);
+  instruction = (struct cris_opcode *) str_hash_find (op_hash, insn_text);
   if (instruction == NULL)
     {
       as_bad (_("Unknown opcode: `%s'"), insn_text);
diff -rup binutils.orig/gas/config/tc-crx.c binutils-2.35/gas/config/tc-crx.c
--- binutils.orig/gas/config/tc-crx.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-crx.c	2021-08-11 17:39:31.404057558 +0100
@@ -63,11 +63,11 @@ typedef enum
 op_err;
 
 /* Opcode mnemonics hash table.  */
-static struct hash_control *crx_inst_hash;
+static htab_t crx_inst_hash;
 /* CRX registers hash table.  */
-static struct hash_control *reg_hash;
+static htab_t reg_hash;
 /* CRX coprocessor registers hash table.  */
-static struct hash_control *copreg_hash;
+static htab_t copreg_hash;
 /* Current instruction we're assembling.  */
 static const inst *instruction;
 
@@ -208,7 +208,7 @@ get_register (char *reg_name)
 {
   const reg_entry *rreg;
 
-  rreg = (const reg_entry *) hash_find (reg_hash, reg_name);
+  rreg = (const reg_entry *) str_hash_find (reg_hash, reg_name);
 
   if (rreg != NULL)
     return rreg->value.reg_val;
@@ -223,7 +223,7 @@ get_copregister (char *copreg_name)
 {
   const reg_entry *coreg;
 
-  coreg = (const reg_entry *) hash_find (copreg_hash, copreg_name);
+  coreg = (const reg_entry *) str_hash_find (copreg_hash, copreg_name);
 
   if (coreg != NULL)
     return coreg->value.copreg_val;
@@ -527,24 +527,19 @@ md_pcrel_from (fixS *fixp)
 void
 md_begin (void)
 {
-  const char *hashret = NULL;
   int i = 0;
 
   /* Set up a hash table for the instructions.  */
-  if ((crx_inst_hash = hash_new ()) == NULL)
+  if ((crx_inst_hash = str_htab_create ()) == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
   while (crx_instruction[i].mnemonic != NULL)
     {
       const char *mnemonic = crx_instruction[i].mnemonic;
 
-      hashret = hash_insert (crx_inst_hash, mnemonic,
+      str_hash_insert (crx_inst_hash, mnemonic,
 			     (void *) &crx_instruction[i]);
 
-      if (hashret != NULL && *hashret != '\0')
-	as_fatal (_("Can't hash `%s': %s\n"), crx_instruction[i].mnemonic,
-		  *hashret == 0 ? _("(unknown reason)") : hashret);
-
       /* Insert unique names into hash table.  The CRX instruction set
 	 has many identical opcode names that have different opcodes based
 	 on the operands.  This hash table then provides a quick index to
@@ -558,7 +553,7 @@ md_begin (void)
     }
 
   /* Initialize reg_hash hash table.  */
-  if ((reg_hash = hash_new ()) == NULL)
+  if ((reg_hash = str_htab_create ()) == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
   {
@@ -566,17 +561,11 @@ md_begin (void)
 
     for (regtab = crx_regtab;
 	 regtab < (crx_regtab + NUMREGS); regtab++)
-      {
-	hashret = hash_insert (reg_hash, regtab->name, (void *) regtab);
-	if (hashret)
-	  as_fatal (_("Internal error: Can't hash %s: %s"),
-		    regtab->name,
-		    hashret);
-      }
+      str_hash_insert (reg_hash, regtab->name, (void *) regtab);
   }
 
   /* Initialize copreg_hash hash table.  */
-  if ((copreg_hash = hash_new ()) == NULL)
+  if ((copreg_hash = str_htab_create ()) == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
   {
@@ -584,14 +573,8 @@ md_begin (void)
 
     for (copregtab = crx_copregtab; copregtab < (crx_copregtab + NUMCOPREGS);
 	 copregtab++)
-      {
-	hashret = hash_insert (copreg_hash, copregtab->name,
-			       (void *) copregtab);
-	if (hashret)
-	  as_fatal (_("Internal error: Can't hash %s: %s"),
-		    copregtab->name,
-		    hashret);
-      }
+      str_hash_insert (copreg_hash, copregtab->name,
+		       (void *) copregtab);
   }
   /*  Set linkrelax here to avoid fixups in most sections.  */
   linkrelax = 1;
@@ -1989,7 +1972,7 @@ md_assemble (char *op)
   *param++ = '\0';
 
   /* Find the instruction.  */
-  instruction = (const inst *) hash_find (crx_inst_hash, op);
+  instruction = (const inst *) str_hash_find (crx_inst_hash, op);
   if (instruction == NULL)
     {
       as_bad (_("Unknown opcode: `%s'"), op);
diff -rup binutils.orig/gas/config/tc-csky.c binutils-2.35/gas/config/tc-csky.c
--- binutils.orig/gas/config/tc-csky.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-csky.c	2021-08-11 17:39:31.405057552 +0100
@@ -754,8 +754,8 @@ size_t md_longopts_size = sizeof (md_lon
 
 static struct csky_insn_info csky_insn;
 
-static struct hash_control *csky_opcodes_hash;
-static struct hash_control *csky_macros_hash;
+static htab_t csky_opcodes_hash;
+static htab_t csky_macros_hash;
 
 static struct csky_macro_info v1_macros_table[] =
 {
@@ -1354,16 +1354,16 @@ md_begin (void)
     }
 
   /* Establish hash table for opcodes and macros.  */
-  csky_macros_hash = hash_new ();
-  csky_opcodes_hash = hash_new ();
+  csky_macros_hash = str_htab_create ();
+  csky_opcodes_hash = str_htab_create ();
   for ( ; opcode->mnemonic != NULL; opcode++)
     if ((isa_flag & (opcode->isa_flag16 | opcode->isa_flag32)) != 0)
-      hash_insert (csky_opcodes_hash, opcode->mnemonic, (char *)opcode);
+      str_hash_insert (csky_opcodes_hash, opcode->mnemonic, (char *)opcode);
   for ( ; macro->name != NULL; macro++)
     if ((isa_flag & macro->isa_flag) != 0)
-      hash_insert (csky_macros_hash, macro->name, (char *)macro);
+      str_hash_insert (csky_macros_hash, macro->name, (char *)macro);
   if (do_nolrw && (isa_flag & CSKYV2_ISA_1E2) != 0)
-    hash_insert (csky_macros_hash,
+    str_hash_insert (csky_macros_hash,
 		 v2_lrw_macro_opcode.name,
 		 (char *)&v2_lrw_macro_opcode);
   /* Set e_flag to ELF Head.  */
@@ -2931,9 +2931,9 @@ parse_opcode (char *str)
   csky_insn.number = csky_count_operands (opcode_end);
 
   /* Find hash by name in csky_macros_hash and csky_opcodes_hash.  */
-  csky_insn.macro = (struct csky_macro_info *) hash_find (csky_macros_hash,
+  csky_insn.macro = (struct csky_macro_info *) str_hash_find (csky_macros_hash,
 							  macro_name);
-  csky_insn.opcode = (struct csky_opcode *) hash_find (csky_opcodes_hash,
+  csky_insn.opcode = (struct csky_opcode *) str_hash_find (csky_opcodes_hash,
 							name);
 
   if (csky_insn.macro == NULL && csky_insn.opcode == NULL)
@@ -3155,7 +3155,7 @@ get_operand_value (struct csky_opcode_in
 	    {
 	      const char *name = "movi";
 	      csky_insn.opcode = (struct csky_opcode *)
-		hash_find (csky_opcodes_hash, name);
+		str_hash_find (csky_opcodes_hash, name);
 	      csky_insn.val[csky_insn.idx - 1] = 1 << val;
 	    }
 	  return TRUE;
@@ -3189,7 +3189,7 @@ get_operand_value (struct csky_opcode_in
 	      {
 		const char *name = "movi";
 		csky_insn.opcode = (struct csky_opcode *)
-		  hash_find (csky_opcodes_hash, name);
+		  str_hash_find (csky_opcodes_hash, name);
 		as_warn (_("translating mgeni to movi"));
 	      }
 	    else
@@ -3223,7 +3223,7 @@ get_operand_value (struct csky_opcode_in
 	    {
 	      const char *op_movi = "movi";
 	      csky_insn.opcode = (struct csky_opcode *)
-		hash_find (csky_opcodes_hash, op_movi);
+		str_hash_find (csky_opcodes_hash, op_movi);
 	      if (csky_insn.opcode == NULL)
 		return FALSE;
 	      csky_insn.val[csky_insn.idx - 1] = (1 << mask_val) - 1;
@@ -3273,7 +3273,7 @@ get_operand_value (struct csky_opcode_in
 	    {
 	      const char *op_movi = "movi";
 	      csky_insn.opcode = (struct csky_opcode *)
-		hash_find (csky_opcodes_hash, op_movi);
+		str_hash_find (csky_opcodes_hash, op_movi);
 	      if (csky_insn.opcode == NULL)
 		return FALSE;
 	      csky_insn.val[csky_insn.idx - 1] = (1 << (mask_val + 1)) - 1;
@@ -5953,7 +5953,7 @@ v1_work_jbsr (void)
       /* Using jsri instruction.  */
       const char *name = "jsri";
       csky_insn.opcode = (struct csky_opcode *)
-	hash_find (csky_opcodes_hash, name);
+	str_hash_find (csky_opcodes_hash, name);
       csky_insn.opcode_idx = 0;
       csky_insn.isize = 2;
 
@@ -6291,7 +6291,7 @@ v2_work_rotlc (void)
 {
   const char *name = "addc";
   csky_insn.opcode
-    = (struct csky_opcode *) hash_find (csky_opcodes_hash, name);
+    = (struct csky_opcode *) str_hash_find (csky_opcodes_hash, name);
   csky_insn.opcode_idx = 0;
   if (csky_insn.isize == 2)
     {
@@ -6329,7 +6329,7 @@ v2_work_bgeni (void)
       val >>= 16;
     }
   csky_insn.opcode
-    = (struct csky_opcode *) hash_find (csky_opcodes_hash, name);
+    = (struct csky_opcode *) str_hash_find (csky_opcodes_hash, name);
   csky_insn.opcode_idx = 0;
   csky_insn.val[1] = val;
 
@@ -6347,7 +6347,7 @@ v2_work_not (void)
 {
   const char *name = "nor";
   csky_insn.opcode
-    = (struct csky_opcode *) hash_find (csky_opcodes_hash, name);
+    = (struct csky_opcode *) str_hash_find (csky_opcodes_hash, name);
   csky_insn.opcode_idx = 0;
   if (csky_insn.number == 1)
     {
Only in binutils-2.35/gas/config: tc-csky.c.orig
diff -rup binutils.orig/gas/config/tc-d10v.c binutils-2.35/gas/config/tc-d10v.c
--- binutils.orig/gas/config/tc-d10v.c	2021-08-11 17:33:12.215490331 +0100
+++ binutils-2.35/gas/config/tc-d10v.c	2021-08-11 17:39:31.405057552 +0100
@@ -101,7 +101,7 @@ struct option md_longopts[] =
 size_t md_longopts_size = sizeof (md_longopts);
 
 /* Opcode hash table.  */
-static struct hash_control *d10v_hash;
+static htab_t d10v_hash;
 
 /* Do a binary search of the d10v_predefined_registers array to see if
    NAME is a valid register name.  Return the register number from the
@@ -277,7 +277,7 @@ md_begin (void)
 {
   const char *prev_name = "";
   struct d10v_opcode *opcode;
-  d10v_hash = hash_new ();
+  d10v_hash = str_htab_create ();
 
   /* Insert unique names into hash table.  The D10v instruction set
      has many identical opcode names that have different opcodes based
@@ -289,7 +289,7 @@ md_begin (void)
       if (strcmp (prev_name, opcode->name))
 	{
 	  prev_name = (char *) opcode->name;
-	  hash_insert (d10v_hash, opcode->name, (char *) opcode);
+	  str_hash_insert (d10v_hash, opcode->name, (char *) opcode);
 	}
     }
 
@@ -1430,7 +1430,7 @@ do_assemble (char *str, struct d10v_opco
     return -1;
 
   /* Find the first opcode with the proper name.  */
-  *opcode = (struct d10v_opcode *) hash_find (d10v_hash, name);
+  *opcode = (struct d10v_opcode *) str_hash_find (d10v_hash, name);
   if (*opcode == NULL)
     return -1;
 
@@ -1558,8 +1558,8 @@ md_apply_fix (fixS *fixP, valueT *valP,
 	{
 	  struct d10v_opcode *rep, *repi;
 
-	  rep = (struct d10v_opcode *) hash_find (d10v_hash, "rep");
-	  repi = (struct d10v_opcode *) hash_find (d10v_hash, "repi");
+	  rep = (struct d10v_opcode *) str_hash_find (d10v_hash, "rep");
+	  repi = (struct d10v_opcode *) str_hash_find (d10v_hash, "repi");
 	  if ((insn & FM11) == FM11
 	      && ((repi != NULL
 		   && (insn & repi->mask) == (unsigned) repi->opcode)
diff -rup binutils.orig/gas/config/tc-d30v.c binutils-2.35/gas/config/tc-d30v.c
--- binutils.orig/gas/config/tc-d30v.c	2021-08-11 17:33:12.215490331 +0100
+++ binutils-2.35/gas/config/tc-d30v.c	2021-08-11 17:39:31.405057552 +0100
@@ -118,7 +118,7 @@ struct option md_longopts[] =
 size_t md_longopts_size = sizeof (md_longopts);
 
 /* Opcode hash table.  */
-static struct hash_control *d30v_hash;
+static htab_t d30v_hash;
 
 /* Do a binary search of the pre_defined_registers array to see if
    NAME is a valid register name.  Return the register number from the
@@ -310,11 +310,11 @@ void
 md_begin (void)
 {
   struct d30v_opcode *opcode;
-  d30v_hash = hash_new ();
+  d30v_hash = str_htab_create ();
 
   /* Insert opcode names into a hash table.  */
   for (opcode = (struct d30v_opcode *) d30v_opcode_table; opcode->name; opcode++)
-      hash_insert (d30v_hash, opcode->name, (char *) opcode);
+      str_hash_insert (d30v_hash, opcode->name, (char *) opcode);
 
   fixups = &FixUps[0];
   FixUps[0].next = &FixUps[1];
@@ -1390,7 +1390,7 @@ do_assemble (char *str,
     }
 
   /* Find the first opcode with the proper name.  */
-  opcode->op = (struct d30v_opcode *) hash_find (d30v_hash, name);
+  opcode->op = (struct d30v_opcode *) str_hash_find (d30v_hash, name);
   if (opcode->op == NULL)
     {
       as_bad (_("unknown opcode: %s"), name);
diff -rup binutils.orig/gas/config/tc-dlx.c binutils-2.35/gas/config/tc-dlx.c
--- binutils.orig/gas/config/tc-dlx.c	2021-08-11 17:33:12.212490350 +0100
+++ binutils-2.35/gas/config/tc-dlx.c	2021-08-11 17:39:31.405057552 +0100
@@ -43,7 +43,7 @@
 #define RELOC_DLX_VTENTRY   BFD_RELOC_VTABLE_ENTRY
 
 /* handle of the OPCODE hash table */
-static struct hash_control *op_hash = NULL;
+static htab_t op_hash = NULL;
 
 struct machine_it
 {
@@ -276,31 +276,18 @@ s_proc (int end_p)
 void
 md_begin (void)
 {
-  const char *retval = NULL;
-  int lose = 0;
   unsigned int i;
 
   /* Create a new hash table.  */
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   /* Hash up all the opcodes for fast use later.  */
   for (i = 0; i < num_dlx_opcodes; i++)
     {
       const char *name = machine_opcodes[i].name;
-
-      retval = hash_insert (op_hash, name, (void *) &machine_opcodes[i]);
-
-      if (retval != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   machine_opcodes[i].name, retval);
-	  lose = 1;
-	}
+      str_hash_insert (op_hash, name, (void *) &machine_opcodes[i]);
     }
 
-  if (lose)
-    as_fatal (_("Broken assembler.  No assembly attempted."));
-
   define_some_regs ();
 }
 
@@ -694,7 +681,7 @@ machine_ip (char *str)
     }
 
   /* Hash the opcode, insn will have the string from opcode table.  */
-  if ((insn = (struct machine_opcode *) hash_find (op_hash, str)) == NULL)
+  if ((insn = (struct machine_opcode *) str_hash_find (op_hash, str)) == NULL)
     {
       /* Handle the ret and return macro here.  */
       if ((strcmp (str, "ret") == 0) || (strcmp (str, "return") == 0))
diff -rup binutils.orig/gas/config/tc-ft32.c binutils-2.35/gas/config/tc-ft32.c
--- binutils.orig/gas/config/tc-ft32.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-ft32.c	2021-08-11 17:39:31.405057552 +0100
@@ -34,7 +34,7 @@ const char line_separator_chars[] = ";";
 const char line_comment_chars[]   = "#";
 
 static int pending_reloc;
-static struct hash_control *opcode_hash_control;
+static htab_t opcode_hash_control;
 
 static valueT md_chars_to_number (char * buf, int n);
 
@@ -54,11 +54,11 @@ void
 md_begin (void)
 {
   const ft32_opc_info_t *opcode;
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
 
   /* Insert names into hash table.  */
   for (opcode = ft32_opc_info; opcode->name; opcode++)
-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
 
   bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);
   if (!norelax)
@@ -231,7 +231,7 @@ md_assemble (char *str)
   if (nlen == 0)
     as_bad (_("can't find opcode "));
 
-  opcode = (ft32_opc_info_t *) hash_find (opcode_hash_control, op_start);
+  opcode = (ft32_opc_info_t *) str_hash_find (opcode_hash_control, op_start);
   *op_end = pend;
 
   if (opcode == NULL)
diff -rup binutils.orig/gas/config/tc-h8300.c binutils-2.35/gas/config/tc-h8300.c
--- binutils.orig/gas/config/tc-h8300.c	2021-08-11 17:33:12.212490350 +0100
+++ binutils-2.35/gas/config/tc-h8300.c	2021-08-11 17:39:31.406057545 +0100
@@ -224,7 +224,7 @@ const char EXP_CHARS[] = "eE";
    or    0d1.2345e12.  */
 const char FLT_CHARS[] = "rRsSfFdDxXpP";
 
-static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */
+static htab_t opcode_hash_control;	/* Opcode mnemonics.  */
 
 /* This function is called once, at assembler startup time.  This
    should set up all the tables, etc. that the MD part of the assembler
@@ -242,7 +242,7 @@ md_begin (void)
   if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, default_mach))
     as_warn (_("could not set architecture and machine"));
 
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
   prev_buffer[0] = 0;
 
   nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
@@ -283,7 +283,7 @@ md_begin (void)
       len = dst - buffer;
       if (cmplen == 0)
 	cmplen = len;
-      hash_insert (opcode_hash_control, buffer, (char *) pi);
+      str_hash_insert (opcode_hash_control, buffer, (char *) pi);
       strcpy (prev_buffer, buffer);
       idx++;
 
@@ -1940,7 +1940,7 @@ md_assemble (char *str)
       *slash = TOLOWER (*slash);
 
   instruction = (const struct h8_instruction *)
-    hash_find (opcode_hash_control, op_start);
+    str_hash_find (opcode_hash_control, op_start);
 
   if (instruction == NULL)
     {
diff -rup binutils.orig/gas/config/tc-hppa.c binutils-2.35/gas/config/tc-hppa.c
--- binutils.orig/gas/config/tc-hppa.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-hppa.c	2021-08-11 17:39:31.406057545 +0100
@@ -550,7 +550,7 @@ static struct call_info *last_call_info;
 static struct call_desc last_call_desc;
 
 /* handle of the OPCODE hash table */
-static struct hash_control *op_hash = NULL;
+static htab_t op_hash = NULL;
 
 /* These characters can be suffixes of opcode names and they may be
    followed by meaningful whitespace.  We don't include `,' and `!'
@@ -3214,7 +3214,7 @@ pa_ip (char *str)
     }
 
   /* Look up the opcode in the hash table.  */
-  if ((insn = (struct pa_opcode *) hash_find (op_hash, str)) == NULL)
+  if ((insn = (struct pa_opcode *) str_hash_find (op_hash, str)) == NULL)
     {
       as_bad (_("Unknown opcode: `%s'"), str);
       return;
@@ -8215,7 +8215,6 @@ pa_lsym (int unused ATTRIBUTE_UNUSED)
 void
 md_begin (void)
 {
-  const char *retval = NULL;
   int lose = 0;
   unsigned int i = 0;
 
@@ -8238,18 +8237,13 @@ md_begin (void)
   pa_spaces_begin ();
 #endif
 
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   while (i < NUMOPCODES)
     {
       const char *name = pa_opcodes[i].name;
 
-      retval = hash_insert (op_hash, name, (struct pa_opcode *) &pa_opcodes[i]);
-      if (retval != NULL && *retval != '\0')
-	{
-	  as_fatal (_("Internal error: can't hash `%s': %s\n"), name, retval);
-	  lose = 1;
-	}
+      str_hash_insert (op_hash, name, (void *)&pa_opcodes[i]);
 
       do
 	{
diff -rup binutils.orig/gas/config/tc-i386.c binutils-2.35/gas/config/tc-i386.c
--- binutils.orig/gas/config/tc-i386.c	2021-08-11 17:33:12.208490376 +0100
+++ binutils-2.35/gas/config/tc-i386.c	2021-08-11 17:39:31.407057539 +0100
@@ -1362,10 +1362,10 @@ const pseudo_typeS md_pseudo_table[] =
 extern char *input_line_pointer;
 
 /* Hash table for instruction mnemonic lookup.  */
-static struct hash_control *op_hash;
+static htab_t op_hash;
 
 /* Hash table for register lookup.  */
-static struct hash_control *reg_hash;
+static htab_t reg_hash;
 
   /* Various efficient no-op patterns for aligning code labels.
      Note: Don't try to assemble the instructions in the comments.
@@ -3009,13 +3009,11 @@ i386_mach (void)
 void
 md_begin (void)
 {
-  const char *hash_err;
-
   /* Support pseudo prefixes like {disp32}.  */
   lex_type ['{'] = LEX_BEGIN_NAME;
 
   /* Initialize op_hash hash table.  */
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   {
     const insn_template *optab;
@@ -3035,15 +3033,7 @@ md_begin (void)
 	    /* different name --> ship out current template list;
 	       add to hash table; & begin anew.  */
 	    core_optab->end = optab;
-	    hash_err = hash_insert (op_hash,
-				    (optab - 1)->name,
-				    (void *) core_optab);
-	    if (hash_err)
-	      {
-		as_fatal (_("can't hash %s: %s"),
-			  (optab - 1)->name,
-			  hash_err);
-	      }
+	    str_hash_insert (op_hash, (optab - 1)->name, (void *) core_optab);
 	    if (optab->name == NULL)
 	      break;
 	    core_optab = XNEW (templates);
@@ -3053,19 +3043,13 @@ md_begin (void)
   }
 
   /* Initialize reg_hash hash table.  */
-  reg_hash = hash_new ();
+  reg_hash = str_htab_create ();
   {
     const reg_entry *regtab;
     unsigned int regtab_size = i386_regtab_size;
 
     for (regtab = i386_regtab; regtab_size--; regtab++)
-      {
-	hash_err = hash_insert (reg_hash, regtab->reg_name, (void *) regtab);
-	if (hash_err)
-	  as_fatal (_("can't hash %s: %s"),
-		    regtab->reg_name,
-		    hash_err);
-      }
+      str_hash_insert (reg_hash, regtab->reg_name, (void *) regtab);
   }
 
   /* Fill in lexical tables:  mnemonic_chars, operand_chars.  */
@@ -3152,8 +3136,8 @@ md_begin (void)
 void
 i386_print_statistics (FILE *file)
 {
-  hash_print_statistics (file, "i386 opcode", op_hash);
-  hash_print_statistics (file, "i386 register", reg_hash);
+  htab_print_statistics (file, "i386 opcode", op_hash);
+  htab_print_statistics (file, "i386 register", reg_hash);
 }
 
 #ifdef DEBUG386
@@ -5043,7 +5027,7 @@ parse_insn (char *line, char *mnemonic)
 	}
 
       /* Look up instruction (or prefix) via hash table.  */
-      current_templates = (const templates *) hash_find (op_hash, mnemonic);
+      current_templates = (const templates *) str_hash_find (op_hash, mnemonic);
 
       if (*l != END_OF_INSN
 	  && (!is_space_char (*l) || l[1] != END_OF_INSN)
@@ -5165,7 +5149,7 @@ parse_insn (char *line, char *mnemonic)
 	goto check_suffix;
       mnem_p = dot_p;
       *dot_p = '\0';
-      current_templates = (const templates *) hash_find (op_hash, mnemonic);
+      current_templates = (const templates *) str_hash_find (op_hash, mnemonic);
     }
 
   if (!current_templates)
@@ -5185,7 +5169,7 @@ parse_insn (char *line, char *mnemonic)
 	      case QWORD_MNEM_SUFFIX:
 		i.suffix = mnem_p[-1];
 	      mnem_p[-1] = '\0';
-	      current_templates = (const templates *) hash_find (op_hash,
+	      current_templates = (const templates *) str_hash_find (op_hash,
 								 mnemonic);
 	      break;
 	    case SHORT_MNEM_SUFFIX:
@@ -5194,7 +5178,7 @@ parse_insn (char *line, char *mnemonic)
 		{
 		  i.suffix = mnem_p[-1];
 		  mnem_p[-1] = '\0';
-		  current_templates = (const templates *) hash_find (op_hash,
+		  current_templates = (const templates *) str_hash_find (op_hash,
 								     mnemonic);
 		}
 	      break;
@@ -5208,7 +5192,7 @@ parse_insn (char *line, char *mnemonic)
 		  else
 		    i.suffix = LONG_MNEM_SUFFIX;
 		  mnem_p[-1] = '\0';
-		  current_templates = (const templates *) hash_find (op_hash,
+		  current_templates = (const templates *) str_hash_find (op_hash,
 								     mnemonic);
 		}
 	      break;
@@ -7492,7 +7476,7 @@ process_operands (void)
 	      i.flags[j] = i.flags[j - 1];
 	    }
 	  i.op[0].regs
-	    = (const reg_entry *) hash_find (reg_hash, "xmm0");
+	    = (const reg_entry *) str_hash_find (reg_hash, "xmm0");
 	  i.types[0] = regxmm;
 	  i.tm.operand_types[0] = regxmm;
 
@@ -10861,10 +10845,10 @@ i386_index_check (const char *operand_st
 		  && current_templates->end[-1].operand_types[1]
 		     .bitfield.baseindex))
 	    op = 1;
-	  expected_reg = hash_find (reg_hash, di_si[addr_mode][op == es_op]);
+	  expected_reg = (const reg_entry *)str_hash_find (reg_hash, di_si[addr_mode][op == es_op]);
 	}
       else
-	expected_reg = hash_find (reg_hash, bx[addr_mode]);
+	expected_reg = (const reg_entry *)str_hash_find (reg_hash, bx[addr_mode]);
 
       if (i.base_reg != expected_reg
 	  || i.index_reg
@@ -12498,7 +12482,7 @@ parse_real_register (char *reg_string, c
 
   *end_op = s;
 
-  r = (const reg_entry *) hash_find (reg_hash, reg_name_given);
+  r = (const reg_entry *) str_hash_find (reg_hash, reg_name_given);
 
   /* Handle floating point regs, allowing spaces in the (i) part.  */
   if (r == i386_regtab /* %st is first entry of table  */)
@@ -12525,7 +12509,7 @@ parse_real_register (char *reg_string, c
 	      if (*s == ')')
 		{
 		  *end_op = s + 1;
-		  r = (const reg_entry *) hash_find (reg_hash, "st(0)");
+		  r = (const reg_entry *) str_hash_find (reg_hash, "st(0)");
 		  know (r);
 		  return r + fpr;
 		}
Only in binutils-2.35/gas/config: tc-i386.c.orig
diff -rup binutils.orig/gas/config/tc-ia64.c binutils-2.35/gas/config/tc-ia64.c
--- binutils.orig/gas/config/tc-ia64.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-ia64.c	2021-08-11 17:39:31.408057532 +0100
@@ -185,10 +185,10 @@ static void ia64_float_to_chars_littleen
 
 static void (*ia64_float_to_chars) (char *, LITTLENUM_TYPE *, int);
 
-static struct hash_control *alias_hash;
-static struct hash_control *alias_name_hash;
-static struct hash_control *secalias_hash;
-static struct hash_control *secalias_name_hash;
+static htab_t alias_hash;
+static htab_t alias_name_hash;
+static htab_t secalias_hash;
+static htab_t secalias_name_hash;
 
 /* List of chars besides those in app.c:symbol_chars that can start an
    operand.  Used to prevent the scrubber eating vital white-space.  */
@@ -228,11 +228,11 @@ size_t md_longopts_size = sizeof (md_lon
 
 static struct
   {
-    struct hash_control *pseudo_hash;	/* pseudo opcode hash table */
-    struct hash_control *reg_hash;	/* register name hash table */
-    struct hash_control *dynreg_hash;	/* dynamic register hash table */
-    struct hash_control *const_hash;	/* constant hash table */
-    struct hash_control *entry_hash;    /* code entry hint hash table */
+    htab_t pseudo_hash;	/* pseudo opcode hash table */
+    htab_t reg_hash;	/* register name hash table */
+    htab_t dynreg_hash;	/* dynamic register hash table */
+    htab_t const_hash;	/* constant hash table */
+    htab_t entry_hash;    /* code entry hint hash table */
 
     /* If X_op is != O_absent, the register name for the instruction's
        qualifying predicate.  If NULL, p0 is assumed for instructions
@@ -4602,7 +4602,7 @@ dot_rot (int type)
   /* First, remove existing names from hash table.  */
   for (dr = md.dynreg[type]; dr && dr->num_regs; dr = dr->next)
     {
-      hash_delete (md.dynreg_hash, dr->name, FALSE);
+      str_hash_delete (md.dynreg_hash, dr->name);
       /* FIXME: Free dr->name.  */
       dr->num_regs = 0;
     }
@@ -4683,12 +4683,7 @@ dot_rot (int type)
       drpp = &dr->next;
       base_reg += num_regs;
 
-      if (hash_insert (md.dynreg_hash, name, dr))
-	{
-	  as_bad (_("Attempt to redefine register set `%s'"), name);
-	  obstack_free (&notes, name);
-	  goto err;
-	}
+      str_hash_insert (md.dynreg_hash, name, dr);
 
       if (*input_line_pointer != ',')
 	break;
@@ -5166,7 +5161,6 @@ dot_pred_rel (int type)
 static void
 dot_entry (int dummy ATTRIBUTE_UNUSED)
 {
-  const char *err;
   char *name;
   int c;
   symbolS *symbolP;
@@ -5176,10 +5170,7 @@ dot_entry (int dummy ATTRIBUTE_UNUSED)
       c = get_symbol_name (&name);
       symbolP = symbol_find_or_make (name);
 
-      err = hash_insert (md.entry_hash, S_GET_NAME (symbolP), (void *) symbolP);
-      if (err)
-	as_fatal (_("Inserting \"%s\" into entry hint table failed: %s"),
-		  name, err);
+      str_hash_insert (md.entry_hash, S_GET_NAME (symbolP), (void *) symbolP);
 
       *input_line_pointer = c;
       SKIP_WHITESPACE_AFTER_NAME ();
@@ -5378,15 +5369,11 @@ pseudo_opcode[] =
 static symbolS *
 declare_register (const char *name, unsigned int regnum)
 {
-  const char *err;
   symbolS *sym;
 
   sym = symbol_create (name, reg_section, regnum, &zero_address_frag);
 
-  err = hash_insert (md.reg_hash, S_GET_NAME (sym), (void *) sym);
-  if (err)
-    as_fatal ("Inserting \"%s\" into register table failed: %s",
-	      name, err);
+  str_hash_insert (md.reg_hash, S_GET_NAME (sym), (void *) sym);
 
   return sym;
 }
@@ -7241,8 +7228,6 @@ void
 md_begin (void)
 {
   int i, j, k, t, goodness, best, ok;
-  const char *err;
-  char name[8];
 
   md.auto_align = 1;
   md.explicit_mode = md.default_explicit_mode;
@@ -7253,10 +7238,10 @@ md_begin (void)
   target_big_endian = -1;
   dot_byteorder (default_big_endian);
 
-  alias_hash = hash_new ();
-  alias_name_hash = hash_new ();
-  secalias_hash = hash_new ();
-  secalias_name_hash = hash_new ();
+  alias_hash = str_htab_create ();
+  alias_name_hash = str_htab_create ();
+  secalias_hash = str_htab_create ();
+  secalias_name_hash = str_htab_create ();
 
   pseudo_func[FUNC_DTP_MODULE].u.sym =
     symbol_new (".<dtpmod>", undefined_section, FUNC_DTP_MODULE,
@@ -7405,20 +7390,15 @@ md_begin (void)
   for (i = 0; i < NUM_SLOTS; ++i)
     md.slot[i].user_template = -1;
 
-  md.pseudo_hash = hash_new ();
+  md.pseudo_hash = str_htab_create ();
   for (i = 0; i < NELEMS (pseudo_opcode); ++i)
-    {
-      err = hash_insert (md.pseudo_hash, pseudo_opcode[i].name,
-			 (void *) (pseudo_opcode + i));
-      if (err)
-	as_fatal (_("ia64.md_begin: can't hash `%s': %s"),
-		  pseudo_opcode[i].name, err);
-    }
+    str_hash_insert (md.pseudo_hash, pseudo_opcode[i].name,
+		     (void *) (pseudo_opcode + i));
 
-  md.reg_hash = hash_new ();
-  md.dynreg_hash = hash_new ();
-  md.const_hash = hash_new ();
-  md.entry_hash = hash_new ();
+  md.reg_hash = str_htab_create ();
+  md.dynreg_hash = str_htab_create ();
+  md.const_hash = str_htab_create ();
+  md.entry_hash = str_htab_create ();
 
   /* general registers:  */
   declare_register_set ("r", 128, REG_GR);
@@ -7471,13 +7451,8 @@ md_begin (void)
   declare_register ("psp", REG_PSP);
 
   for (i = 0; i < NELEMS (const_bits); ++i)
-    {
-      err = hash_insert (md.const_hash, const_bits[i].name,
-			 (void *) (const_bits + i));
-      if (err)
-	as_fatal (_("Inserting \"%s\" into constant hash table failed: %s"),
-		  name, err);
-    }
+    str_hash_insert (md.const_hash, const_bits[i].name,
+		     (void *) (const_bits + i));
 
   /* Set the architecture and machine depending on defaults and command line
      options.  */
@@ -7980,7 +7955,7 @@ ia64_parse_name (char *name, expressionS
     }
 
   /* first see if NAME is a known register name:  */
-  sym = hash_find (md.reg_hash, name);
+  sym = str_hash_find (md.reg_hash, name);
   if (sym)
     {
       e->X_op = O_register;
@@ -7988,7 +7963,7 @@ ia64_parse_name (char *name, expressionS
       return 1;
     }
 
-  cdesc = hash_find (md.const_hash, name);
+  cdesc = str_hash_find (md.const_hash, name);
   if (cdesc)
     {
       e->X_op = O_constant;
@@ -8054,7 +8029,7 @@ ia64_parse_name (char *name, expressionS
 
   end = xstrdup (name);
   name = ia64_canonicalize_symbol_name (end);
-  if ((dr = hash_find (md.dynreg_hash, name)))
+  if ((dr = str_hash_find (md.dynreg_hash, name)))
     {
       /* We've got ourselves the name of a rotating register set.
 	 Store the base register number in the low 16 bits of
@@ -10675,7 +10650,7 @@ md_assemble (char *str)
 
   ch = get_symbol_name (&temp);
   mnemonic = temp;
-  pdesc = (struct pseudo_opcode *) hash_find (md.pseudo_hash, mnemonic);
+  pdesc = (struct pseudo_opcode *) str_hash_find (md.pseudo_hash, mnemonic);
   if (pdesc)
     {
       (void) restore_line_pointer (ch);
@@ -11750,10 +11725,9 @@ dot_alias (int section)
   char delim;
   char *end_name;
   int len;
-  const char *error_string;
   struct alias *h;
   const char *a;
-  struct hash_control *ahash, *nhash;
+  htab_t ahash, nhash;
   const char *kind;
 
   delim = get_symbol_name (&name);
@@ -11810,21 +11784,26 @@ dot_alias (int section)
     }
 
   /* Check if alias has been used before.  */
-  h = (struct alias *) hash_find (ahash, alias);
+
+  h = (struct alias *) str_hash_find (ahash, alias);
   if (h)
     {
       if (strcmp (h->name, name))
 	as_bad (_("`%s' is already the alias of %s `%s'"),
 		alias, kind, h->name);
+      obstack_free (&notes, name);
+      obstack_free (&notes, alias);
       goto out;
     }
 
   /* Check if name already has an alias.  */
-  a = (const char *) hash_find (nhash, name);
+  a = (const char *) str_hash_find (nhash, name);
   if (a)
     {
       if (strcmp (a, alias))
 	as_bad (_("%s `%s' already has an alias `%s'"), kind, name, a);
+      obstack_free (&notes, name);
+      obstack_free (&notes, alias);
       goto out;
     }
 
@@ -11832,32 +11811,19 @@ dot_alias (int section)
   h->file = as_where (&h->line);
   h->name = name;
 
-  error_string = hash_jam (ahash, alias, (void *) h);
-  if (error_string)
-    {
-      as_fatal (_("inserting \"%s\" into %s alias hash table failed: %s"),
-		alias, kind, error_string);
-      goto out;
-    }
-
-  error_string = hash_jam (nhash, name, (void *) alias);
-  if (error_string)
-    {
-      as_fatal (_("inserting \"%s\" into %s name hash table failed: %s"),
-		alias, kind, error_string);
-    out:
-      obstack_free (&notes, name);
-      obstack_free (&notes, alias);
-    }
+  str_hash_insert (ahash, alias, (void *) h);
+  str_hash_insert (nhash, name, (void *) alias);
 
+out:
   demand_empty_rest_of_line ();
 }
 
 /* It renames the original symbol name to its alias.  */
-static void
-do_alias (const char *alias, void *value)
+static int
+do_alias (void **slot, void *arg ATTRIBUTE_UNUSED)
 {
-  struct alias *h = (struct alias *) value;
+  string_tuple_t *tuple = *((string_tuple_t **) slot);
+  struct alias *h = (struct alias *) tuple->value;
   symbolS *sym = symbol_find (h->name);
 
   if (sym == NULL)
@@ -11866,43 +11832,48 @@ do_alias (const char *alias, void *value
       /* Uses .alias extensively to alias CRTL functions to same with
 	 decc$ prefix. Sometimes function gets optimized away and a
 	 warning results, which should be suppressed.  */
-      if (strncmp (alias, "decc$", 5) != 0)
+      if (strncmp (tuple->key, "decc$", 5) != 0)
 #endif
 	as_warn_where (h->file, h->line,
 		       _("symbol `%s' aliased to `%s' is not used"),
-		       h->name, alias);
+		       h->name, tuple->key);
     }
     else
-      S_SET_NAME (sym, (char *) alias);
+      S_SET_NAME (sym, (char *) tuple->key);
+
+  return 1;
 }
 
 /* Called from write_object_file.  */
 void
 ia64_adjust_symtab (void)
 {
-  hash_traverse (alias_hash, do_alias);
+  htab_traverse (alias_hash, do_alias, NULL);
 }
 
 /* It renames the original section name to its alias.  */
-static void
-do_secalias (const char *alias, void *value)
+static int
+do_secalias (void **slot, void *arg ATTRIBUTE_UNUSED)
 {
-  struct alias *h = (struct alias *) value;
+  string_tuple_t *tuple = *((string_tuple_t **) slot);
+  struct alias *h = (struct alias *) tuple->value;
   segT sec = bfd_get_section_by_name (stdoutput, h->name);
 
   if (sec == NULL)
     as_warn_where (h->file, h->line,
 		   _("section `%s' aliased to `%s' is not used"),
-		   h->name, alias);
+		   h->name, tuple->key);
   else
-    sec->name = alias;
+    sec->name = tuple->key;
+
+  return 1;
 }
 
 /* Called from write_object_file.  */
 void
 ia64_frob_file (void)
 {
-  hash_traverse (secalias_hash, do_secalias);
+  htab_traverse (secalias_hash, do_secalias, NULL);
 }
 
 #ifdef TE_VMS
diff -rup binutils.orig/gas/config/tc-iq2000.c binutils-2.35/gas/config/tc-iq2000.c
--- binutils.orig/gas/config/tc-iq2000.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-iq2000.c	2021-08-11 17:43:57.988347560 +0100
@@ -106,7 +106,7 @@ struct iq2000_hi_fixup
 static struct iq2000_hi_fixup * iq2000_hi_fixup_list;
 
 /* Macro hash table, which we will add to.  */
-extern struct hash_control *macro_hash;
+extern struct htab *macro_hash;
 
 const char *md_shortopts = "";
 struct option md_longopts[] =
@@ -246,7 +246,10 @@ iq2000_add_macro (const char *  name,
       formal_entry ** p = &macro->formals;
 
       macro->formal_count = 0;
-      macro->formal_hash = hash_new ();
+      macro->formal_hash = htab_create_alloc (7, hash_formal_entry,
+					      eq_formal_entry,
+					      NULL, xcalloc, free);
+
 
       while (*arguments != NULL)
 	{
@@ -272,8 +275,9 @@ iq2000_add_macro (const char *  name,
 	    sb_add_string (& formal->name, *arguments);
 
 	  /* Add to macro's hash table.  */
-	  hash_jam (macro->formal_hash, sb_terminate (& formal->name), formal);
-
+	  htab_insert (macro->formal_hash,
+		       formal_entry_alloc (sb_terminate (& formal->name),
+					   formal));
 	  formal->index = macro->formal_count;
 	  macro->formal_count++;
 	  *p = formal;
@@ -285,7 +289,7 @@ iq2000_add_macro (const char *  name,
 
   sb_add_string (&macro_name, name);
   namestr = sb_terminate (&macro_name);
-  hash_jam (macro_hash, namestr, macro);
+  htab_insert (macro_hash, macro_entry_alloc (namestr, macro));
 
   macro_defined = 1;
 }
diff -rup binutils.orig/gas/config/tc-m68hc11.c binutils-2.35/gas/config/tc-m68hc11.c
--- binutils.orig/gas/config/tc-m68hc11.c	2021-08-11 17:33:12.211490357 +0100
+++ binutils-2.35/gas/config/tc-m68hc11.c	2021-08-11 17:39:31.408057532 +0100
@@ -263,7 +263,7 @@ static short flag_print_insn_syntax = 0;
 static short flag_print_opcodes = 0;
 
 /* Opcode hash table.  */
-static struct hash_control *m68hc11_hash;
+static htab_t m68hc11_hash;
 
 /* Current cpu (either cpu6811 or cpu6812).  This is determined automagically
    by 'get_default_target' by looking at default BFD vector.  This is overridden
@@ -472,7 +472,7 @@ m68hc11_print_statistics (FILE *file)
   int i;
   struct m68hc11_opcode_def *opc;
 
-  hash_print_statistics (file, "opcode table", m68hc11_hash);
+  htab_print_statistics (file, "opcode table", m68hc11_hash);
 
   opc = m68hc11_opcode_defs;
   if (opc == 0 || m68hc11_nb_opcode_defs == 0)
@@ -610,7 +610,7 @@ md_begin (void)
 
   get_default_target ();
 
-  m68hc11_hash = hash_new ();
+  m68hc11_hash = str_htab_create ();
 
   /* Get a writable copy of the opcode table and sort it on the names.  */
   opcodes = XNEWVEC (struct m68hc11_opcode, m68hc11_num_opcodes);
@@ -664,7 +664,7 @@ md_begin (void)
 	  opc->nb_modes = 0;
 	  opc->opcode = opcodes;
 	  opc->used = 0;
-	  hash_insert (m68hc11_hash, opcodes->name, opc);
+	  str_hash_insert (m68hc11_hash, opcodes->name, opc);
 	}
       opc->nb_modes++;
       opc->format |= opcodes->format;
@@ -1010,7 +1010,7 @@ print_insn_format (char *name)
   struct m68hc11_opcode *opcode;
   char buf[128];
 
-  opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);
+  opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, name);
   if (opc == NULL)
     {
       as_bad (_("Instruction `%s' is not recognized."), name);
@@ -2848,7 +2848,7 @@ md_assemble (char *str)
   if (current_architecture == cpuxgate)
     {
       /* Find the opcode definition given its name.  */
-      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);
+      opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, name);
       if (opc == NULL)
         {
           as_bad (_("Opcode `%s' is not recognized."), name);
@@ -3469,7 +3469,7 @@ md_assemble (char *str)
     }
 
   /* Find the opcode definition given its name.  */
-  opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);
+  opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, name);
 
   /* If it's not recognized, look for 'jbsr' and 'jbxx'.  These are
      pseudo insns for relative branch.  For these branches, we always
@@ -3477,7 +3477,7 @@ md_assemble (char *str)
      is given.  */
   if (opc == NULL && name[0] == 'j' && name[1] == 'b')
     {
-      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, &name[1]);
+      opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, &name[1]);
       if (opc
 	  && (!(opc->format & M6811_OP_JUMP_REL)
 	      || (opc->format & M6811_OP_BITMASK)))
@@ -3508,7 +3508,7 @@ md_assemble (char *str)
 	    {
 	      name[nlen++] = TOLOWER (*op_end++);
 	      name[nlen] = 0;
-	      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash,
+	      opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash,
 							     name);
 	    }
 	}
diff -rup binutils.orig/gas/config/tc-m68k.c binutils-2.35/gas/config/tc-m68k.c
--- binutils.orig/gas/config/tc-m68k.c	2021-08-11 17:33:12.212490350 +0100
+++ binutils-2.35/gas/config/tc-m68k.c	2021-08-11 17:44:04.214307612 +0100
@@ -1320,7 +1320,7 @@ tc_gen_reloc (asection *section ATTRIBUT
 
 /* Handle of the OPCODE hash table.  NULL means any use before
    m68k_ip_begin() will crash.  */
-static struct hash_control *op_hash;
+static htab_t op_hash;
 
 /* Assemble an m68k instruction.  */
 
@@ -1375,7 +1375,7 @@ m68k_ip (char *instring)
 
   c = *p;
   *p = '\0';
-  opcode = (const struct m68k_incant *) hash_find (op_hash, instring);
+  opcode = (const struct m68k_incant *) str_hash_find (op_hash, instring);
   *p = c;
 
   if (pdot != NULL)
@@ -4496,7 +4496,6 @@ md_begin (void)
 {
   const struct m68k_opcode *ins;
   struct m68k_incant *hack, *slak;
-  const char *retval = 0;	/* Empty string, or error msg text.  */
   int i;
 
   /* Set up hash tables with 68000 instructions.
@@ -4527,7 +4526,7 @@ md_begin (void)
   qsort (m68k_sorted_opcodes, m68k_numopcodes,
 	 sizeof (m68k_sorted_opcodes[0]), m68k_compare_opcode);
 
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   obstack_begin (&robyn, 4000);
   for (i = 0; i < m68k_numopcodes; i++)
@@ -4571,22 +4570,18 @@ md_begin (void)
 	}
       while (slak);
 
-      retval = hash_insert (op_hash, ins->name, (char *) hack);
-      if (retval)
-	as_fatal (_("Internal Error:  Can't hash %s: %s"), ins->name, retval);
+      str_hash_insert (op_hash, ins->name, (char *) hack);
     }
 
   for (i = 0; i < m68k_numaliases; i++)
     {
       const char *name = m68k_opcode_aliases[i].primary;
       const char *alias = m68k_opcode_aliases[i].alias;
-      void *val = hash_find (op_hash, name);
+      void *val = (void *)str_hash_find (op_hash, name);
 
       if (!val)
 	as_fatal (_("Internal Error: Can't find %s in hash table"), name);
-      retval = hash_insert (op_hash, alias, val);
-      if (retval)
-	as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
+      str_hash_insert (op_hash, alias, val);
     }
 
   /* In MRI mode, all unsized branches are variable sized.  Normally,
@@ -4619,13 +4614,11 @@ md_begin (void)
 	{
 	  const char *name = mri_aliases[i].primary;
 	  const char *alias = mri_aliases[i].alias;
-	  void *val = hash_find (op_hash, name);
+	  void *val = (void *)str_hash_find (op_hash, name);
 
 	  if (!val)
 	    as_fatal (_("Internal Error: Can't find %s in hash table"), name);
-	  retval = hash_jam (op_hash, alias, val);
-	  if (retval)
-	    as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
+	  str_hash_insert (op_hash, alias, val);
 	}
     }
 
@@ -4680,7 +4673,7 @@ md_begin (void)
     while (mote_pseudo_table[n].poc_name)
       {
 	hack = XOBNEW (&robyn, struct m68k_incant);
-	hash_insert (op_hash,
+	str_hash_insert (op_hash,
 		     mote_pseudo_table[n].poc_name, (char *) hack);
 	hack->m_operands = 0;
 	hack->m_opnum = n;
@@ -5560,7 +5553,7 @@ s_proc (int ignore ATTRIBUTE_UNUSED)
    alignment is needed.  */
 
 int
-m68k_conditional_pseudoop (pseudo_typeS *pop)
+m68k_conditional_pseudoop (const pseudo_typeS *pop)
 {
   return (pop->poc_handler == s_mri_if
 	  || pop->poc_handler == s_mri_else);
Only in binutils-2.35/gas/config: tc-m68k.c.orig
diff -rup binutils.orig/gas/config/tc-m68k.h binutils-2.35/gas/config/tc-m68k.h
--- binutils.orig/gas/config/tc-m68k.h	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-m68k.h	2021-08-11 17:44:04.214307612 +0100
@@ -47,7 +47,7 @@ extern const char *m68k_comment_chars;
 extern void m68k_mri_mode_change (int);
 #define MRI_MODE_CHANGE(i) m68k_mri_mode_change (i)
 
-extern int m68k_conditional_pseudoop (pseudo_typeS *);
+extern int m68k_conditional_pseudoop (const pseudo_typeS *);
 #define tc_conditional_pseudoop(pop) m68k_conditional_pseudoop (pop)
 
 extern void m68k_frob_label (symbolS *);
diff -rup binutils.orig/gas/config/tc-mcore.c binutils-2.35/gas/config/tc-mcore.c
--- binutils.orig/gas/config/tc-mcore.c	2021-08-11 17:33:12.214490337 +0100
+++ binutils-2.35/gas/config/tc-mcore.c	2021-08-11 17:39:31.408057532 +0100
@@ -135,7 +135,7 @@ static unsigned long poolspan;
 #define SPANEXIT	(600)
 static symbolS * poolsym;		/* Label for current pool.  */
 static char poolname[8];
-static struct hash_control * opcode_hash_control;	/* Opcode mnemonics.  */
+static htab_t  opcode_hash_control;	/* Opcode mnemonics.  */
 
 #define POOL_END_LABEL   ".LE"
 #define POOL_START_LABEL ".LS"
@@ -457,7 +457,7 @@ md_begin (void)
   const char * prev_name = "";
   unsigned int i;
 
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
 
   /* Insert unique names into hash table.  */
   for (i = 0; i < ARRAY_SIZE (mcore_table); i++)
@@ -465,7 +465,7 @@ md_begin (void)
       if (! streq (prev_name, mcore_table[i].name))
 	{
 	  prev_name = mcore_table[i].name;
-	  hash_insert (opcode_hash_control, mcore_table[i].name, (char *) &mcore_table[i]);
+	  str_hash_insert (opcode_hash_control, mcore_table[i].name, (char *) &mcore_table[i]);
 	}
     }
 }
@@ -881,7 +881,7 @@ md_assemble (char * str)
       return;
     }
 
-  opcode = (mcore_opcode_info *) hash_find (opcode_hash_control, name);
+  opcode = (mcore_opcode_info *) str_hash_find (opcode_hash_control, name);
   if (opcode == NULL)
     {
       as_bad (_("unknown opcode \"%s\""), name);
diff -rup binutils.orig/gas/config/tc-microblaze.c binutils-2.35/gas/config/tc-microblaze.c
--- binutils.orig/gas/config/tc-microblaze.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-microblaze.c	2021-08-11 17:39:31.409057526 +0100
@@ -114,7 +114,7 @@ const relax_typeS md_relax_table[] =
   { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 }   /* 18: TEXT_PC_OFFSET.  */
 };
 
-static struct hash_control * opcode_hash_control;	/* Opcode mnemonics.  */
+static htab_t  opcode_hash_control;	/* Opcode mnemonics.  */
 
 static segT sbss_segment = 0; 	/* Small bss section.  */
 static segT sbss2_segment = 0; 	/* Section not used.  */
@@ -413,11 +413,11 @@ md_begin (void)
 {
   struct op_code_struct * opcode;
 
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
 
   /* Insert unique names into hash table.  */
   for (opcode = opcodes; opcode->name; opcode ++)
-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
 }
 
 /* Try to parse a reg name.  */
@@ -942,7 +942,7 @@ md_assemble (char * str)
       return;
     }
 
-  opcode = (struct op_code_struct *) hash_find (opcode_hash_control, name);
+  opcode = (struct op_code_struct *) str_hash_find (opcode_hash_control, name);
   if (opcode == NULL)
     {
       as_bad (_("unknown opcode \"%s\""), name);
@@ -1072,9 +1072,9 @@ md_assemble (char * str)
 
           count = 32 - reg1;
           if (streq (name, "lmi"))
-            opcode = (struct op_code_struct *) hash_find (opcode_hash_control, "lwi");
+            opcode = (struct op_code_struct *) str_hash_find (opcode_hash_control, "lwi");
           else
-            opcode = (struct op_code_struct *) hash_find (opcode_hash_control, "swi");
+            opcode = (struct op_code_struct *) str_hash_find (opcode_hash_control, "swi");
           if (opcode == NULL)
             {
               as_bad (_("unknown opcode \"%s\""), "lwi");
@@ -1106,7 +1106,7 @@ md_assemble (char * str)
           if ((temp != 0) && (temp != 0xFFFF8000))
 	    {
               /* Needs an immediate inst.  */
-              opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, "imm");
+              opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, "imm");
               if (opcode1 == NULL)
                 {
                   as_bad (_("unknown opcode \"%s\""), "imm");
@@ -1559,7 +1559,7 @@ md_assemble (char * str)
       if ((temp != 0) && (temp != 0xFFFF8000))
 	{
           /* Needs an immediate inst.  */
-          opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, "imm");
+          opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, "imm");
           if (opcode1 == NULL)
             {
               as_bad (_("unknown opcode \"%s\""), "imm");
@@ -1625,7 +1625,7 @@ md_assemble (char * str)
       if ((temp != 0) && (temp != 0xFFFF8000))
 	{
           /* Needs an immediate inst.  */
-          opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, "imm");
+          opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, "imm");
           if (opcode1 == NULL)
             {
               as_bad (_("unknown opcode \"%s\""), "imm");
@@ -1698,7 +1698,7 @@ md_assemble (char * str)
       if ((temp != 0) && (temp != 0xFFFF8000))
 	{
           /* Needs an immediate inst.  */
-          opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, "imm");
+          opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, "imm");
           if (opcode1 == NULL)
             {
               as_bad (_("unknown opcode \"%s\""), "imm");
@@ -2119,7 +2119,7 @@ md_apply_fix (fixS *   fixP,
 	buf[i + INST_WORD_SIZE] = buf[i];
 
       /* Generate the imm instruction.  */
-      opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, "imm");
+      opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, "imm");
       if (opcode1 == NULL)
 	{
 	  as_bad (_("unknown opcode \"%s\""), "imm");
@@ -2167,7 +2167,7 @@ md_apply_fix (fixS *   fixP,
 	buf[i + INST_WORD_SIZE] = buf[i];
 
       /* Generate the imm instruction.  */
-      opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, "imm");
+      opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, "imm");
       if (opcode1 == NULL)
 	{
 	  as_bad (_("unknown opcode \"%s\""), "imm");
diff -rup binutils.orig/gas/config/tc-mips.c binutils-2.35/gas/config/tc-mips.c
--- binutils.orig/gas/config/tc-mips.c	2021-08-11 17:33:12.211490357 +0100
+++ binutils-2.35/gas/config/tc-mips.c	2021-08-11 17:39:31.410057520 +0100
@@ -675,13 +675,13 @@ static int g_switch_seen = 0;
 static int nopic_need_relax (symbolS *, int);
 
 /* Handle of the OPCODE hash table.  */
-static struct hash_control *op_hash = NULL;
+static htab_t op_hash = NULL;
 
 /* The opcode hash table we use for the mips16.  */
-static struct hash_control *mips16_op_hash = NULL;
+static htab_t mips16_op_hash = NULL;
 
 /* The opcode hash table we use for the microMIPS ASE.  */
-static struct hash_control *micromips_op_hash = NULL;
+static htab_t micromips_op_hash = NULL;
 
 /* This array holds the chars that always start a comment.  If the
     pre-processor is disabled, these aren't very useful.  */
@@ -3673,7 +3673,6 @@ validate_micromips_insn (const struct mi
 void
 md_begin (void)
 {
-  const char *retval = NULL;
   int i = 0;
   int broken = 0;
 
@@ -3693,21 +3692,14 @@ md_begin (void)
   if (! bfd_set_arch_mach (stdoutput, bfd_arch_mips, file_mips_opts.arch))
     as_warn (_("could not set architecture and machine"));
 
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   mips_operands = XCNEWVEC (struct mips_operand_array, NUMOPCODES);
   for (i = 0; i < NUMOPCODES;)
     {
       const char *name = mips_opcodes[i].name;
 
-      retval = hash_insert (op_hash, name, (void *) &mips_opcodes[i]);
-      if (retval != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   mips_opcodes[i].name, retval);
-	  /* Probably a memory allocation problem?  Give up now.  */
-	  as_fatal (_("broken assembler, no assembly attempted"));
-	}
+      str_hash_insert (op_hash, name, (void *) &mips_opcodes[i]);
       do
 	{
 	  if (!validate_mips_insn (&mips_opcodes[i], 0xffffffff,
@@ -3730,7 +3722,7 @@ md_begin (void)
       while ((i < NUMOPCODES) && !strcmp (mips_opcodes[i].name, name));
     }
 
-  mips16_op_hash = hash_new ();
+  mips16_op_hash = str_htab_create ();
   mips16_operands = XCNEWVEC (struct mips_operand_array,
 			      bfd_mips16_num_opcodes);
 
@@ -3739,10 +3731,7 @@ md_begin (void)
     {
       const char *name = mips16_opcodes[i].name;
 
-      retval = hash_insert (mips16_op_hash, name, (void *) &mips16_opcodes[i]);
-      if (retval != NULL)
-	as_fatal (_("internal: can't hash `%s': %s"),
-		  mips16_opcodes[i].name, retval);
+      str_hash_insert (mips16_op_hash, name, (void *) &mips16_opcodes[i]);
       do
 	{
 	  if (!validate_mips16_insn (&mips16_opcodes[i], &mips16_operands[i]))
@@ -3758,7 +3747,7 @@ md_begin (void)
 	     && strcmp (mips16_opcodes[i].name, name) == 0);
     }
 
-  micromips_op_hash = hash_new ();
+  micromips_op_hash = str_htab_create ();
   micromips_operands = XCNEWVEC (struct mips_operand_array,
 				 bfd_micromips_num_opcodes);
 
@@ -3767,11 +3756,8 @@ md_begin (void)
     {
       const char *name = micromips_opcodes[i].name;
 
-      retval = hash_insert (micromips_op_hash, name,
+      str_hash_insert (micromips_op_hash, name,
 			    (void *) &micromips_opcodes[i]);
-      if (retval != NULL)
-	as_fatal (_("internal: can't hash `%s': %s"),
-		  micromips_opcodes[i].name, retval);
       do
 	{
 	  struct mips_cl_insn *micromips_nop_insn;
@@ -9027,7 +9013,7 @@ macro_build (expressionS *ep, const char
   bfd_reloc_code_real_type r[3];
   const struct mips_opcode *amo;
   const struct mips_operand *operand;
-  struct hash_control *hash;
+  htab_t hash;
   struct mips_cl_insn insn;
   va_list args;
   unsigned int uval;
@@ -9045,7 +9031,7 @@ macro_build (expressionS *ep, const char
   r[1] = BFD_RELOC_UNUSED;
   r[2] = BFD_RELOC_UNUSED;
   hash = mips_opts.micromips ? micromips_op_hash : op_hash;
-  amo = (struct mips_opcode *) hash_find (hash, name);
+  amo = (struct mips_opcode *) str_hash_find (hash, name);
   gas_assert (amo);
   gas_assert (strcmp (name, amo->name) == 0);
 
@@ -9203,7 +9189,7 @@ mips16_macro_build (expressionS *ep, con
   bfd_reloc_code_real_type r[3]
     = {BFD_RELOC_UNUSED, BFD_RELOC_UNUSED, BFD_RELOC_UNUSED};
 
-  mo = (struct mips_opcode *) hash_find (mips16_op_hash, name);
+  mo = (struct mips_opcode *) str_hash_find (mips16_op_hash, name);
   gas_assert (mo);
   gas_assert (strcmp (name, mo->name) == 0);
 
@@ -14263,7 +14249,7 @@ mips16_macro (struct mips_cl_insn *ip)
    opcode bits in *OPCODE_EXTRA.  */
 
 static struct mips_opcode *
-mips_lookup_insn (struct hash_control *hash, const char *start,
+mips_lookup_insn (htab_t hash, const char *start,
 		  ssize_t length, unsigned int *opcode_extra)
 {
   char *name, *dot, *p;
@@ -14275,7 +14261,7 @@ mips_lookup_insn (struct hash_control *h
   name = xstrndup (start, length);
 
   /* Look up the instruction as-is.  */
-  insn = (struct mips_opcode *) hash_find (hash, name);
+  insn = (struct mips_opcode *) str_hash_find (hash, name);
   if (insn)
     goto end;
 
@@ -14287,7 +14273,7 @@ mips_lookup_insn (struct hash_control *h
       if (*p == 0 && mask != 0)
 	{
 	  *dot = 0;
-	  insn = (struct mips_opcode *) hash_find (hash, name);
+	  insn = (struct mips_opcode *) str_hash_find (hash, name);
 	  *dot = '.';
 	  if (insn && (insn->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX) != 0)
 	    {
@@ -14313,7 +14299,7 @@ mips_lookup_insn (struct hash_control *h
       if (suffix)
 	{
 	  memmove (name + opend - 2, name + opend, length - opend + 1);
-	  insn = (struct mips_opcode *) hash_find (hash, name);
+	  insn = (struct mips_opcode *) str_hash_find (hash, name);
 	  if (insn)
 	    {
 	      forced_insn_length = suffix;
@@ -14338,7 +14324,7 @@ static void
 mips_ip (char *str, struct mips_cl_insn *insn)
 {
   const struct mips_opcode *first, *past;
-  struct hash_control *hash;
+  htab_t hash;
   char format;
   size_t end;
   struct mips_operand_token *tokens;
@@ -14434,7 +14420,7 @@ mips16_ip (char *str, struct mips_cl_ins
   forced_insn_length = l;
 
   *end = 0;
-  first = (struct mips_opcode *) hash_find (mips16_op_hash, str);
+  first = (struct mips_opcode *) str_hash_find (mips16_op_hash, str);
   *end = c;
 
   if (!first)
Only in binutils-2.35/gas/config: tc-mips.c.orig
diff -rup binutils.orig/gas/config/tc-mmix.c binutils-2.35/gas/config/tc-mmix.c
--- binutils.orig/gas/config/tc-mmix.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-mmix.c	2021-08-11 17:39:31.410057520 +0100
@@ -217,7 +217,7 @@ struct option md_longopts[] =
 
 size_t md_longopts_size = sizeof (md_longopts);
 
-static struct hash_control *mmix_opcode_hash;
+static htab_t mmix_opcode_hash;
 
 /* We use these when implementing the PREFIX pseudo.  */
 char *mmix_current_prefix;
@@ -769,13 +769,13 @@ mmix_md_begin (void)
      only way to make ':' part of a name, and a name beginner.  */
   lex_type[':'] = (LEX_NAME | LEX_BEGIN_NAME);
 
-  mmix_opcode_hash = hash_new ();
+  mmix_opcode_hash = str_htab_create ();
 
   real_reg_section
     = bfd_make_section_old_way (stdoutput, MMIX_REG_SECTION_NAME);
 
   for (opcode = mmix_opcodes; opcode->name; opcode++)
-    hash_insert (mmix_opcode_hash, opcode->name, (char *) opcode);
+    str_hash_insert (mmix_opcode_hash, opcode->name, (char *) opcode);
 
   /* We always insert the ordinary registers 0..255 as registers.  */
   for (i = 0; i < 256; i++)
@@ -843,7 +843,7 @@ md_assemble (char *str)
       *operands++ = '\0';
     }
 
-  instruction = (struct mmix_opcode *) hash_find (mmix_opcode_hash, str);
+  instruction = (struct mmix_opcode *) str_hash_find (mmix_opcode_hash, str);
   if (instruction == NULL)
     {
       as_bad (_("unknown opcode: `%s'"), str);
diff -rup binutils.orig/gas/config/tc-mn10200.c binutils-2.35/gas/config/tc-mn10200.c
--- binutils.orig/gas/config/tc-mn10200.c	2021-08-11 17:33:12.214490337 +0100
+++ binutils-2.35/gas/config/tc-mn10200.c	2021-08-11 17:39:31.410057520 +0100
@@ -101,7 +101,7 @@ const pseudo_typeS md_pseudo_table[] =
 };
 
 /* Opcode hash table.  */
-static struct hash_control *mn10200_hash;
+static htab_t mn10200_hash;
 
 /* This table is sorted. Suitable for searching by a binary search.  */
 static const struct reg_name data_registers[] =
@@ -685,7 +685,7 @@ md_begin (void)
   const char *prev_name = "";
   const struct mn10200_opcode *op;
 
-  mn10200_hash = hash_new ();
+  mn10200_hash = str_htab_create ();
 
   /* Insert unique names into hash table.  The MN10200 instruction set
      has many identical opcode names that have different opcodes based
@@ -698,7 +698,7 @@ md_begin (void)
       if (strcmp (prev_name, op->name))
 	{
 	  prev_name = (char *) op->name;
-	  hash_insert (mn10200_hash, op->name, (char *) op);
+	  str_hash_insert (mn10200_hash, op->name, (char *) op);
 	}
       op++;
     }
@@ -890,7 +890,7 @@ md_assemble (char *str)
     *s++ = '\0';
 
   /* Find the first opcode with the proper name.  */
-  opcode = (struct mn10200_opcode *) hash_find (mn10200_hash, str);
+  opcode = (struct mn10200_opcode *) str_hash_find (mn10200_hash, str);
   if (opcode == NULL)
     {
       as_bad (_("Unrecognized opcode: `%s'"), str);
diff -rup binutils.orig/gas/config/tc-mn10300.c binutils-2.35/gas/config/tc-mn10300.c
--- binutils.orig/gas/config/tc-mn10300.c	2021-08-11 17:33:12.208490376 +0100
+++ binutils-2.35/gas/config/tc-mn10300.c	2021-08-11 17:39:31.411057513 +0100
@@ -121,7 +121,7 @@ size_t md_longopts_size = sizeof (md_lon
 #define HAVE_AM30   (current_machine == AM30)
 
 /* Opcode hash table.  */
-static struct hash_control *mn10300_hash;
+static htab_t mn10300_hash;
 
 /* This table is sorted. Suitable for searching by a binary search.  */
 static const struct reg_name data_registers[] =
@@ -911,7 +911,7 @@ md_begin (void)
   const char *prev_name = "";
   const struct mn10300_opcode *op;
 
-  mn10300_hash = hash_new ();
+  mn10300_hash = str_htab_create ();
 
   /* Insert unique names into hash table.  The MN10300 instruction set
      has many identical opcode names that have different opcodes based
@@ -924,7 +924,7 @@ md_begin (void)
       if (strcmp (prev_name, op->name))
 	{
 	  prev_name = (char *) op->name;
-	  hash_insert (mn10300_hash, op->name, (char *) op);
+	  str_hash_insert (mn10300_hash, op->name, (char *) op);
 	}
       op++;
     }
@@ -1247,7 +1247,7 @@ md_assemble (char *str)
     *s++ = '\0';
 
   /* Find the first opcode with the proper name.  */
-  opcode = (struct mn10300_opcode *) hash_find (mn10300_hash, str);
+  opcode = (struct mn10300_opcode *) str_hash_find (mn10300_hash, str);
   if (opcode == NULL)
     {
       as_bad (_("Unrecognized opcode: `%s'"), str);
diff -rup binutils.orig/gas/config/tc-moxie.c binutils-2.35/gas/config/tc-moxie.c
--- binutils.orig/gas/config/tc-moxie.c	2021-08-11 17:33:12.212490350 +0100
+++ binutils-2.35/gas/config/tc-moxie.c	2021-08-11 17:39:31.411057513 +0100
@@ -32,7 +32,7 @@ const char line_separator_chars[] = ";";
 const char line_comment_chars[]   = "#";
 
 static int pending_reloc;
-static struct hash_control *opcode_hash_control;
+static htab_t opcode_hash_control;
 
 const pseudo_typeS md_pseudo_table[] =
 {
@@ -62,17 +62,17 @@ md_begin (void)
 {
   int count;
   const moxie_opc_info_t *opcode;
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
 
   /* Insert names into hash table.  */
   for (count = 0, opcode = moxie_form1_opc_info; count++ < 64; opcode++)
-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
 
   for (count = 0, opcode = moxie_form2_opc_info; count++ < 4; opcode++)
-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
 
   for (count = 0, opcode = moxie_form3_opc_info; count++ < 10; opcode++)
-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
 
   bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);
 }
@@ -178,7 +178,7 @@ md_assemble (char *str)
 
   if (nlen == 0)
     as_bad (_("can't find opcode "));
-  opcode = (moxie_opc_info_t *) hash_find (opcode_hash_control, op_start);
+  opcode = (moxie_opc_info_t *) str_hash_find (opcode_hash_control, op_start);
   *op_end = pend;
 
   if (opcode == NULL)
diff -rup binutils.orig/gas/config/tc-msp430.c binutils-2.35/gas/config/tc-msp430.c
--- binutils.orig/gas/config/tc-msp430.c	2021-08-11 17:33:12.215490331 +0100
+++ binutils-2.35/gas/config/tc-msp430.c	2021-08-11 17:39:31.411057513 +0100
@@ -194,7 +194,7 @@ const char FLT_CHARS[] = "dD";
 /* Handle  long expressions.  */
 extern LITTLENUM_TYPE generic_bignum[];
 
-static struct hash_control *msp430_hash;
+static htab_t msp430_hash;
 
 /* Relaxations.  */
 #define STATE_UNCOND_BRANCH	1	/* jump */
@@ -1834,10 +1834,11 @@ void
 md_begin (void)
 {
   struct msp430_opcode_s * opcode;
-  msp430_hash = hash_new ();
+  msp430_hash = str_htab_create ();
 
   for (opcode = msp430_opcodes; opcode->name; opcode++)
-    hash_insert (msp430_hash, opcode->name, (char *) opcode);
+    if (str_hash_find (msp430_hash, opcode->name) == NULL)
+      str_hash_insert (msp430_hash, opcode->name, (char *) opcode);
 
   bfd_set_arch_mach (stdoutput, TARGET_ARCH,
 		     target_is_430x () ? bfd_mach_msp430x : bfd_mach_msp11);
@@ -2871,7 +2872,7 @@ msp430_operands (struct msp430_opcode_s
       char real_name[32];
 
       sprintf (real_name, "%sa", old_name);
-      opcode = hash_find (msp430_hash, real_name);
+      opcode = str_hash_find (msp430_hash, real_name);
       if (opcode == NULL)
 	{
 	  as_bad (_("instruction %s.a does not exist"), old_name);
@@ -4355,7 +4356,7 @@ md_assemble (char * str)
       return;
     }
 
-  opcode = (struct msp430_opcode_s *) hash_find (msp430_hash, cmd);
+  opcode = (struct msp430_opcode_s *) str_hash_find (msp430_hash, cmd);
 
   if (opcode == NULL)
     {
Only in binutils-2.35/gas/config: tc-msp430.c.orig
diff -rup binutils.orig/gas/config/tc-nds32.c binutils-2.35/gas/config/tc-nds32.c
--- binutils.orig/gas/config/tc-nds32.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-nds32.c	2021-08-11 17:39:31.411057513 +0100
@@ -82,8 +82,8 @@ static int vec_size = 0;
    ".flag verbatim" at beginning of the content.  We have
    'nds32_flag' to parse it and set this field to be non-zero.  */
 static int verbatim = 0;
-static struct hash_control *nds32_gprs_hash;
-static struct hash_control *nds32_hint_hash;
+static htab_t nds32_gprs_hash;
+static htab_t nds32_hint_hash;
 #define TLS_REG "$r27"
 #define GOT_NAME "_GLOBAL_OFFSET_TABLE_"
 
@@ -109,7 +109,7 @@ enum ict_option {
 static enum ict_option ict_flag = ICT_NONE;
 
 
-static struct hash_control *nds32_relax_info_hash;
+static htab_t nds32_relax_info_hash;
 
 /* Branch patterns.  */
 static relax_info_t relax_table[] =
@@ -2569,12 +2569,12 @@ struct nds32_pseudo_opcode
 };
 #define PV_DONT_CARE 0
 
-static struct hash_control *nds32_pseudo_opcode_hash = NULL;
+static htab_t nds32_pseudo_opcode_hash = NULL;
 
 static int
 builtin_isreg (const char *s, const char *x ATTRIBUTE_UNUSED)
 {
-  if (s [0] == '$' && hash_find (nds32_gprs_hash, (s + 1)))
+  if (s [0] == '$' && str_hash_find (nds32_gprs_hash, (s + 1)))
     return 1;
   return 0;
 }
@@ -2586,7 +2586,7 @@ builtin_regnum (const char *s, const cha
   if (*s != '$')
     return -1;
   s++;
-  k = hash_find (nds32_gprs_hash, s);
+  k = str_hash_find (nds32_gprs_hash, s);
 
   if (k == NULL)
     return -1;
@@ -3434,18 +3434,18 @@ nds32_init_nds32_pseudo_opcodes (void)
 {
   struct nds32_pseudo_opcode *opcode = nds32_pseudo_opcode_table;
 
-  nds32_pseudo_opcode_hash = hash_new ();
+  nds32_pseudo_opcode_hash = str_htab_create ();
   for ( ; opcode->opcode; opcode++)
     {
       void *op;
 
-      op = hash_find (nds32_pseudo_opcode_hash, opcode->opcode);
+      op = str_hash_find (nds32_pseudo_opcode_hash, opcode->opcode);
       if (op != NULL)
 	{
 	  as_warn (_("Duplicated pseudo-opcode %s."), opcode->opcode);
 	  continue;
 	}
-      hash_insert (nds32_pseudo_opcode_hash, opcode->opcode, opcode);
+      str_hash_insert (nds32_pseudo_opcode_hash, opcode->opcode, opcode);
     }
 }
 
@@ -3466,7 +3466,7 @@ nds32_lookup_pseudo_opcode (const char *
     }
   op[i] = '\0';
 
-  result = hash_find (nds32_pseudo_opcode_hash, op);
+  result = str_hash_find (nds32_pseudo_opcode_hash, op);
   free (op);
   return result;
 }
@@ -4291,12 +4291,12 @@ nds32_relax_hint (int mode ATTRIBUTE_UNU
 
   /* Find relax hint entry for next instruction, and all member will be
      initialized at that time.  */
-  relocs = hash_find (nds32_hint_hash, name);
+  relocs = str_hash_find (nds32_hint_hash, name);
   if (relocs == NULL)
     {
       relocs = XNEW (struct nds32_relocs_pattern);
       memset (relocs, 0, sizeof (struct nds32_relocs_pattern));
-      hash_insert (nds32_hint_hash, name, relocs);
+      str_hash_insert (nds32_hint_hash, name, relocs);
     }
   else
     {
@@ -4623,17 +4623,17 @@ md_begin (void)
   nds32_asm_init (&asm_desc, flags);
 
   /* Initial general purpose registers hash table.  */
-  nds32_gprs_hash = hash_new ();
+  nds32_gprs_hash = str_htab_create ();
   for (k = keyword_gpr; k->name; k++)
-    hash_insert (nds32_gprs_hash, k->name, k);
+    str_hash_insert (nds32_gprs_hash, k->name, k);
 
   /* Initial branch hash table.  */
-  nds32_relax_info_hash = hash_new ();
+  nds32_relax_info_hash = str_htab_create ();
   for (relax_info = relax_table; relax_info->opcode; relax_info++)
-    hash_insert (nds32_relax_info_hash, relax_info->opcode, relax_info);
+    str_hash_insert (nds32_relax_info_hash, relax_info->opcode, relax_info);
 
   /* Initial relax hint hash table.  */
-  nds32_hint_hash = hash_new ();
+  nds32_hint_hash = str_htab_create ();
   enable_16bit = nds32_16bit_ext;
 }
 
@@ -5813,7 +5813,7 @@ nds32_find_reloc_table (struct nds32_rel
   if (opc)
     {
       /* Branch relax pattern.  */
-      relax_info = hash_find (nds32_relax_info_hash, opc);
+      relax_info = str_hash_find (nds32_relax_info_hash, opc);
       if (!relax_info)
 	return FALSE;
       fixup_info = relax_info->relax_fixup[range];
@@ -6272,6 +6272,15 @@ nds32_elf_append_relax_relocs (const cha
   frchain_now = frchain_bak;
 }
 
+static int
+nds32_elf_append_relax_relocs_traverse (void **slot, void *arg ATTRIBUTE_UNUSED)
+{
+  string_tuple_t *tuple = *((string_tuple_t **) slot);
+  nds32_elf_append_relax_relocs (tuple->key, tuple->value);
+  return 1;
+}
+
+
 static void
 nds32_str_tolower (const char *src, char *dest)
 {
@@ -6757,7 +6766,7 @@ nds32_relax_branch_instructions (segT se
 	return 0;
     }
 
-  relax_info = hash_find (nds32_relax_info_hash, opcode->opcode);
+  relax_info = str_hash_find (nds32_relax_info_hash, opcode->opcode);
 
   if (relax_info == NULL)
     return adjust;
@@ -7046,7 +7055,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNU
 
   if (fragP->tc_frag_data.flag & NDS32_FRAG_RELAXABLE_BRANCH)
     {
-      relax_info = hash_find (nds32_relax_info_hash, opcode->opcode);
+      relax_info = str_hash_find (nds32_relax_info_hash, opcode->opcode);
 
       if (relax_info == NULL)
 	return;
@@ -7106,7 +7115,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNU
   else if (fragP->tc_frag_data.flag & NDS32_FRAG_BRANCH)
     {
       /* Branch instruction adjust and append relocations.  */
-      relax_info = hash_find (nds32_relax_info_hash, opcode->opcode);
+      relax_info = str_hash_find (nds32_relax_info_hash, opcode->opcode);
 
       if (relax_info == NULL)
 	return;
@@ -7481,7 +7490,7 @@ nds32_insert_relax_entry (bfd *abfd ATTR
 static void
 nds32_elf_analysis_relax_hint (void)
 {
-  hash_traverse (nds32_hint_hash, nds32_elf_append_relax_relocs);
+  htab_traverse (nds32_hint_hash, nds32_elf_append_relax_relocs_traverse, NULL);
 }
 
 static void
@@ -7966,7 +7975,7 @@ nds32_parse_name (char const *name, expr
 int
 tc_nds32_regname_to_dw2regnum (char *regname)
 {
-  struct nds32_keyword *sym = hash_find (nds32_gprs_hash, regname);
+  struct nds32_keyword *sym = str_hash_find (nds32_gprs_hash, regname);
 
   if (!sym)
     return -1;
diff -rup binutils.orig/gas/config/tc-nios2.c binutils-2.35/gas/config/tc-nios2.c
--- binutils.orig/gas/config/tc-nios2.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-nios2.c	2021-08-11 17:39:31.412057507 +0100
@@ -184,20 +184,20 @@ typedef struct nios2_ps_insn_info
 } nios2_ps_insn_infoS;
 
 /* Opcode hash table.  */
-static struct hash_control *nios2_opcode_hash = NULL;
+static htab_t nios2_opcode_hash = NULL;
 #define nios2_opcode_lookup(NAME) \
-  ((struct nios2_opcode *) hash_find (nios2_opcode_hash, (NAME)))
+  ((struct nios2_opcode *) str_hash_find (nios2_opcode_hash, (NAME)))
 
 /* Register hash table.  */
-static struct hash_control *nios2_reg_hash = NULL;
+static htab_t nios2_reg_hash = NULL;
 #define nios2_reg_lookup(NAME) \
-  ((struct nios2_reg *) hash_find (nios2_reg_hash, (NAME)))
+  ((struct nios2_reg *) str_hash_find (nios2_reg_hash, (NAME)))
 
 
 /* Pseudo-op hash table.  */
-static struct hash_control *nios2_ps_hash = NULL;
+static htab_t nios2_ps_hash = NULL;
 #define nios2_ps_lookup(NAME) \
-  ((nios2_ps_insn_infoS *) hash_find (nios2_ps_hash, (NAME)))
+  ((nios2_ps_insn_infoS *) str_hash_find (nios2_ps_hash, (NAME)))
 
 /* The known current alignment of the current section.  */
 static int nios2_current_align;
@@ -3603,7 +3603,6 @@ void
 md_begin (void)
 {
   int i;
-  const char *inserted;
 
   switch (nios2_architecture)
     {
@@ -3620,52 +3619,21 @@ md_begin (void)
 
   /* Create and fill a hashtable for the Nios II opcodes, registers and
      arguments.  */
-  nios2_opcode_hash = hash_new ();
-  nios2_reg_hash = hash_new ();
-  nios2_ps_hash = hash_new ();
+  nios2_opcode_hash = str_htab_create ();
+  nios2_reg_hash = str_htab_create ();
+  nios2_ps_hash = str_htab_create ();
 
   for (i = 0; i < nios2_num_opcodes; ++i)
-    {
-      inserted
-	= hash_insert (nios2_opcode_hash, nios2_opcodes[i].name,
-		       (PTR) & nios2_opcodes[i]);
-      if (inserted != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   nios2_opcodes[i].name, inserted);
-	  /* Probably a memory allocation problem?  Give up now.  */
-	  as_fatal (_("Broken assembler.  No assembly attempted."));
-	}
-    }
+    str_hash_insert (nios2_opcode_hash, nios2_opcodes[i].name,
+		     (PTR) & nios2_opcodes[i]);
 
   for (i = 0; i < nios2_num_regs; ++i)
-    {
-      inserted
-	= hash_insert (nios2_reg_hash, nios2_regs[i].name,
-		       (PTR) & nios2_regs[i]);
-      if (inserted != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   nios2_regs[i].name, inserted);
-	  /* Probably a memory allocation problem?  Give up now.  */
-	  as_fatal (_("Broken assembler.  No assembly attempted."));
-	}
-
-    }
+    str_hash_insert (nios2_reg_hash, nios2_regs[i].name,
+		     (PTR) & nios2_regs[i]);
 
   for (i = 0; i < nios2_num_ps_insn_info_structs; ++i)
-    {
-      inserted
-	= hash_insert (nios2_ps_hash, nios2_ps_insn_info_structs[i].pseudo_insn,
-		       (PTR) & nios2_ps_insn_info_structs[i]);
-      if (inserted != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   nios2_ps_insn_info_structs[i].pseudo_insn, inserted);
-	  /* Probably a memory allocation problem?  Give up now.  */
-	  as_fatal (_("Broken assembler.  No assembly attempted."));
-	}
-    }
+    str_hash_insert (nios2_ps_hash, nios2_ps_insn_info_structs[i].pseudo_insn,
+		     (PTR) & nios2_ps_insn_info_structs[i]);
 
   /* Assembler option defaults.  */
   nios2_as_options.noat = FALSE;
diff -rup binutils.orig/gas/config/tc-ns32k.c binutils-2.35/gas/config/tc-ns32k.c
--- binutils.orig/gas/config/tc-ns32k.c	2021-08-11 17:33:12.208490376 +0100
+++ binutils-2.35/gas/config/tc-ns32k.c	2021-08-11 17:39:31.412057507 +0100
@@ -84,7 +84,7 @@ struct addr_mode
 typedef struct addr_mode addr_modeS;
 
 char *freeptr, *freeptr_static;	/* Points at some number of free bytes.  */
-struct hash_control *inst_hash_handle;
+htab_t inst_hash_handle;
 
 struct ns32k_opcode *desc;	/* Pointer at description of instruction.  */
 addr_modeS addr_modeP;
@@ -1103,7 +1103,7 @@ parse (const char *line, int recursive_l
       c = *lineptr;
       *(char *) lineptr = '\0';
 
-      if (!(desc = (struct ns32k_opcode *) hash_find (inst_hash_handle, line)))
+      if (!(desc = (struct ns32k_opcode *) str_hash_find (inst_hash_handle, line)))
 	as_fatal (_("No such opcode"));
 
       *(char *) lineptr = c;
@@ -1895,18 +1895,13 @@ md_begin (void)
 {
   /* Build a hashtable of the instructions.  */
   const struct ns32k_opcode *ptr;
-  const char *status;
   const struct ns32k_opcode *endop;
 
-  inst_hash_handle = hash_new ();
+  inst_hash_handle = str_htab_create ();
 
   endop = ns32k_opcodes + sizeof (ns32k_opcodes) / sizeof (ns32k_opcodes[0]);
   for (ptr = ns32k_opcodes; ptr < endop; ptr++)
-    {
-      if ((status = hash_insert (inst_hash_handle, ptr->name, (char *) ptr)))
-	/* Fatal.  */
-	as_fatal (_("Can't hash %s: %s"), ptr->name, status);
-    }
+    str_hash_insert (inst_hash_handle, ptr->name, (char *) ptr);
 
   /* Some private space please!  */
   freeptr_static = XNEWVEC (char, PRIVATE_SIZE);
diff -rup binutils.orig/gas/config/tc-pdp11.c binutils-2.35/gas/config/tc-pdp11.c
--- binutils.orig/gas/config/tc-pdp11.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-pdp11.c	2021-08-11 17:39:31.412057507 +0100
@@ -82,7 +82,7 @@ const pseudo_typeS md_pseudo_table[] =
   { 0, 0, 0 },
 };
 
-static struct hash_control *insn_hash = NULL;
+static htab_t insn_hash = NULL;
 
 static int
 set_option (const char *arg)
@@ -188,14 +188,14 @@ md_begin (void)
 
   init_defaults ();
 
-  insn_hash = hash_new ();
+  insn_hash = str_htab_create ();
   if (insn_hash == NULL)
     as_fatal (_("Virtual memory exhausted"));
 
   for (i = 0; i < pdp11_num_opcodes; i++)
-    hash_insert (insn_hash, pdp11_opcodes[i].name, (void *) (pdp11_opcodes + i));
+    str_hash_insert (insn_hash, pdp11_opcodes[i].name, (void *) (pdp11_opcodes + i));
   for (i = 0; i < pdp11_num_aliases; i++)
-    hash_insert (insn_hash, pdp11_aliases[i].name, (void *) (pdp11_aliases + i));
+    str_hash_insert (insn_hash, pdp11_aliases[i].name, (void *) (pdp11_aliases + i));
 }
 
 void
@@ -713,7 +713,7 @@ md_assemble (char *instruction_string)
 
   c = *p;
   *p = '\0';
-  op = (struct pdp11_opcode *)hash_find (insn_hash, str);
+  op = (struct pdp11_opcode *)str_hash_find (insn_hash, str);
   *p = c;
   if (op == 0)
     {
diff -rup binutils.orig/gas/config/tc-pj.c binutils-2.35/gas/config/tc-pj.c
--- binutils.orig/gas/config/tc-pj.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-pj.c	2021-08-11 17:39:31.412057507 +0100
@@ -31,7 +31,7 @@ const char line_separator_chars[] = ";";
 const char line_comment_chars[]   = "/!#";
 
 static int pending_reloc;
-static struct hash_control *opcode_hash_control;
+static htab_t opcode_hash_control;
 
 static void
 little (int ignore ATTRIBUTE_UNUSED)
@@ -176,7 +176,7 @@ fake_opcode (const char *name,
   fake->opcode = -1;
   fake->opcode_next = -1;
   fake->u.func = func;
-  hash_insert (opcode_hash_control, name, (char *) fake);
+  str_hash_insert (opcode_hash_control, name, (char *) fake);
 }
 
 /* Enter another entry into the opcode hash table so the same opcode
@@ -185,8 +185,8 @@ fake_opcode (const char *name,
 static void
 alias (const char *new_name, const char *old)
 {
-  hash_insert (opcode_hash_control, new_name,
-	       (char *) hash_find (opcode_hash_control, old));
+  str_hash_insert (opcode_hash_control, new_name,
+	       (char *) str_hash_find (opcode_hash_control, old));
 }
 
 /* This function is called once, at assembler startup time.  It sets
@@ -197,11 +197,11 @@ void
 md_begin (void)
 {
   const pj_opc_info_t *opcode;
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
 
   /* Insert names into hash table.  */
   for (opcode = pj_opc_info; opcode->u.name; opcode++)
-    hash_insert (opcode_hash_control, opcode->u.name, (char *) opcode);
+    str_hash_insert (opcode_hash_control, opcode->u.name, (char *) opcode);
 
   /* Insert the only fake opcode.  */
   fake_opcode ("ipush", ipush_code);
@@ -252,7 +252,7 @@ md_assemble (char *str)
   if (nlen == 0)
     as_bad (_("can't find opcode "));
 
-  opcode = (pj_opc_info_t *) hash_find (opcode_hash_control, op_start);
+  opcode = (pj_opc_info_t *) str_hash_find (opcode_hash_control, op_start);
   *op_end = pend;
 
   if (opcode == NULL)
diff -rup binutils.orig/gas/config/tc-ppc.c binutils-2.35/gas/config/tc-ppc.c
--- binutils.orig/gas/config/tc-ppc.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-ppc.c	2021-08-11 17:39:31.413057500 +0100
@@ -1004,10 +1004,10 @@ ppc_optimize_expr (expressionS *left, op
 static unsigned int ppc_obj64 = BFD_DEFAULT_TARGET_SIZE == 64;
 
 /* Opcode hash table.  */
-static struct hash_control *ppc_hash;
+static htab_t ppc_hash;
 
 /* Macro hash table.  */
-static struct hash_control *ppc_macro_hash;
+static htab_t ppc_macro_hash;
 
 #ifdef OBJ_ELF
 /* What type of shared library support to use.  */
@@ -1656,12 +1656,12 @@ ppc_setup_opcodes (void)
   bfd_boolean bad_insn = FALSE;
 
   if (ppc_hash != NULL)
-    hash_die (ppc_hash);
+    htab_delete (ppc_hash);
   if (ppc_macro_hash != NULL)
-    hash_die (ppc_macro_hash);
+    htab_delete (ppc_macro_hash);
 
   /* Insert the opcodes into a hash table.  */
-  ppc_hash = hash_new ();
+  ppc_hash = str_htab_create ();
 
   if (ENABLE_CHECKING)
     {
@@ -1738,22 +1738,12 @@ ppc_setup_opcodes (void)
 
       if ((ppc_cpu & op->flags) != 0
 	  && !(ppc_cpu & op->deprecated))
-	{
-	  const char *retval;
-
-	  retval = hash_insert (ppc_hash, op->name, (void *) op);
-	  if (retval != NULL)
-	    {
-	      as_bad (_("duplicate instruction %s"),
-		      op->name);
-	      bad_insn = TRUE;
-	    }
-	}
+	str_hash_insert (ppc_hash, op->name, (void *) op);
     }
 
   if ((ppc_cpu & PPC_OPCODE_ANY) != 0)
     for (op = powerpc_opcodes; op < op_end; op++)
-      hash_insert (ppc_hash, op->name, (void *) op);
+      str_hash_insert (ppc_hash, op->name, (void *) op);
 
   op_end = prefix_opcodes + prefix_num_opcodes;
   for (op = prefix_opcodes; op < op_end; op++)
@@ -1782,22 +1772,12 @@ ppc_setup_opcodes (void)
 
       if ((ppc_cpu & op->flags) != 0
 	  && !(ppc_cpu & op->deprecated))
-	{
-	  const char *retval;
-
-	  retval = hash_insert (ppc_hash, op->name, (void *) op);
-	  if (retval != NULL)
-	    {
-	      as_bad (_("duplicate instruction %s"),
-		      op->name);
-	      bad_insn = TRUE;
-	    }
-	}
+	str_hash_insert (ppc_hash, op->name, (void *) op);
     }
 
   if ((ppc_cpu & PPC_OPCODE_ANY) != 0)
     for (op = prefix_opcodes; op < op_end; op++)
-      hash_insert (ppc_hash, op->name, (void *) op);
+      str_hash_insert (ppc_hash, op->name, (void *) op);
 
   op_end = vle_opcodes + vle_num_opcodes;
   for (op = vle_opcodes; op < op_end; op++)
@@ -1827,17 +1807,7 @@ ppc_setup_opcodes (void)
 
       if ((ppc_cpu & op->flags) != 0
 	  && !(ppc_cpu & op->deprecated))
-	{
-	  const char *retval;
-
-	  retval = hash_insert (ppc_hash, op->name, (void *) op);
-	  if (retval != NULL)
-	    {
-	      as_bad (_("duplicate instruction %s"),
-		      op->name);
-	      bad_insn = TRUE;
-	    }
-	}
+	str_hash_insert (ppc_hash, op->name, (void *) op);
     }
 
   /* SPE2 instructions */
@@ -1871,40 +1841,21 @@ ppc_setup_opcodes (void)
 	    }
 
 	  if ((ppc_cpu & op->flags) != 0 && !(ppc_cpu & op->deprecated))
-	    {
-	      const char *retval;
-
-	      retval = hash_insert (ppc_hash, op->name, (void *) op);
-	      if (retval != NULL)
-		{
-		  as_bad (_("duplicate instruction %s"),
-			  op->name);
-		  bad_insn = TRUE;
-		}
-	    }
+	    str_hash_insert (ppc_hash, op->name, (void *) op);
 	}
 
       for (op = spe2_opcodes; op < op_end; op++)
-	hash_insert (ppc_hash, op->name, (void *) op);
+	str_hash_insert (ppc_hash, op->name, (void *) op);
     }
 
   /* Insert the macros into a hash table.  */
-  ppc_macro_hash = hash_new ();
+  ppc_macro_hash = str_htab_create ();
 
   macro_end = powerpc_macros + powerpc_num_macros;
   for (macro = powerpc_macros; macro < macro_end; macro++)
     {
       if ((macro->flags & ppc_cpu) != 0 || (ppc_cpu & PPC_OPCODE_ANY) != 0)
-	{
-	  const char *retval;
-
-	  retval = hash_insert (ppc_macro_hash, macro->name, (void *) macro);
-	  if (retval != (const char *) NULL)
-	    {
-	      as_bad (_("duplicate macro %s"), macro->name);
-	      bad_insn = TRUE;
-	    }
-	}
+	str_hash_insert (ppc_macro_hash, macro->name, (void *) macro);
     }
 
   if (bad_insn)
@@ -3319,12 +3270,12 @@ md_assemble (char *str)
     *s++ = '\0';
 
   /* Look up the opcode in the hash table.  */
-  opcode = (const struct powerpc_opcode *) hash_find (ppc_hash, str);
+  opcode = (const struct powerpc_opcode *) str_hash_find (ppc_hash, str);
   if (opcode == (const struct powerpc_opcode *) NULL)
     {
       const struct powerpc_macro *macro;
 
-      macro = (const struct powerpc_macro *) hash_find (ppc_macro_hash, str);
+      macro = (const struct powerpc_macro *) str_hash_find (ppc_macro_hash, str);
       if (macro == (const struct powerpc_macro *) NULL)
 	as_bad (_("unrecognized opcode: `%s'"), str);
       else
Only in binutils-2.35/gas/config: tc-ppc.c.orig
diff -rup binutils.orig/gas/config/tc-pru.c binutils-2.35/gas/config/tc-pru.c
--- binutils.orig/gas/config/tc-pru.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-pru.c	2021-08-11 17:39:31.413057500 +0100
@@ -132,14 +132,14 @@ typedef struct pru_insn_info
 } pru_insn_infoS;
 
 /* Opcode hash table.  */
-static struct hash_control *pru_opcode_hash = NULL;
+static htab_t pru_opcode_hash = NULL;
 #define pru_opcode_lookup(NAME) \
-  ((struct pru_opcode *) hash_find (pru_opcode_hash, (NAME)))
+  ((struct pru_opcode *) str_hash_find (pru_opcode_hash, (NAME)))
 
 /* Register hash table.  */
-static struct hash_control *pru_reg_hash = NULL;
+static htab_t pru_reg_hash = NULL;
 #define pru_reg_lookup(NAME) \
-  ((struct pru_reg *) hash_find (pru_reg_hash, (NAME)))
+  ((struct pru_reg *) str_hash_find (pru_reg_hash, (NAME)))
 
 /* The known current alignment of the current section.  */
 static int pru_current_align;
@@ -1557,41 +1557,19 @@ void
 md_begin (void)
 {
   int i;
-  const char *inserted;
 
   /* Create and fill a hashtable for the PRU opcodes, registers and
      arguments.  */
-  pru_opcode_hash = hash_new ();
-  pru_reg_hash = hash_new ();
+  pru_opcode_hash = str_htab_create ();
+  pru_reg_hash = str_htab_create ();
 
   for (i = 0; i < NUMOPCODES; ++i)
-    {
-      inserted
-	= hash_insert (pru_opcode_hash, pru_opcodes[i].name,
-		       (PTR) & pru_opcodes[i]);
-      if (inserted != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   pru_opcodes[i].name, inserted);
-	  /* Probably a memory allocation problem?  Give up now.  */
-	  as_fatal (_("Broken assembler.  No assembly attempted."));
-	}
-    }
+    str_hash_insert (pru_opcode_hash, pru_opcodes[i].name,
+		     (PTR) & pru_opcodes[i]);
 
   for (i = 0; i < pru_num_regs; ++i)
-    {
-      inserted
-	= hash_insert (pru_reg_hash, pru_regs[i].name,
-		       (PTR) & pru_regs[i]);
-      if (inserted != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   pru_regs[i].name, inserted);
-	  /* Probably a memory allocation problem?  Give up now.  */
-	  as_fatal (_("Broken assembler.  No assembly attempted."));
-	}
-
-    }
+    str_hash_insert (pru_reg_hash, pru_regs[i].name,
+		     (PTR) & pru_regs[i]);
 
   linkrelax = pru_opt.link_relax;
   /* Initialize the alignment data.  */
@@ -1811,8 +1789,8 @@ md_pcrel_from (fixS *fixP ATTRIBUTE_UNUS
 void
 md_end (void)
 {
-  hash_die (pru_opcode_hash);
-  hash_die (pru_reg_hash);
+  htab_delete (pru_opcode_hash);
+  htab_delete (pru_reg_hash);
 }
 
 symbolS *
diff -rup binutils.orig/gas/config/tc-riscv.c binutils-2.35/gas/config/tc-riscv.c
--- binutils.orig/gas/config/tc-riscv.c	2021-08-11 17:33:12.214490337 +0100
+++ binutils-2.35/gas/config/tc-riscv.c	2021-08-11 17:39:31.413057500 +0100
@@ -242,28 +242,18 @@ riscv_multi_subset_supports (enum riscv_
 }
 
 /* Handle of the extension with version hash table.  */
-static struct hash_control *ext_version_hash = NULL;
+static htab_t ext_version_hash = NULL;
 
-static struct hash_control *
+static htab_t
 init_ext_version_hash (const struct riscv_ext_version *table)
 {
   int i = 0;
-  struct hash_control *hash = hash_new ();
+  htab_t hash = str_htab_create ();
 
   while (table[i].name)
     {
       const char *name = table[i].name;
-      const char *hash_error =
-       hash_insert (hash, name, (void *) &table[i]);
-
-      if (hash_error != NULL)
-       {
-         fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-                  table[i].name, hash_error);
-         /* Probably a memory allocation problem?  Give up now.  */
-         as_fatal (_("Broken assembler.  No assembly attempted."));
-         return NULL;
-       }
+      str_hash_insert (hash, name, (void *) &table[i]);
 
       i++;
       while (table[i].name
@@ -287,7 +277,7 @@ riscv_get_default_ext_version (const cha
   if (name == NULL || default_isa_spec == ISA_SPEC_CLASS_NONE)
     return;
 
-  ext = (struct riscv_ext_version *) hash_find (ext_version_hash, name);
+  ext = (struct riscv_ext_version *) str_hash_find (ext_version_hash, name);
   while (ext
         && ext->name
         && strcmp (ext->name, name) == 0)
@@ -321,10 +311,10 @@ riscv_set_arch (const char *s)
 }
 
 /* Handle of the OPCODE hash table.  */
-static struct hash_control *op_hash = NULL;
+static htab_t op_hash = NULL;
 
 /* Handle of the type of .insn hash table.  */
-static struct hash_control *insn_type_hash = NULL;
+static htab_t insn_type_hash = NULL;
 
 /* This array holds the chars that always start a comment.  If the
     pre-processor is disabled, these aren't very useful */
@@ -559,23 +549,16 @@ static const struct opcode_name_t opcode
 };
 
 /* Hash table for lookup opcode name.  */
-static struct hash_control *opcode_names_hash = NULL;
+static htab_t opcode_names_hash = NULL;
 
 /* Initialization for hash table of opcode name.  */
 static void
 init_opcode_names_hash (void)
 {
-  const char *retval;
   const struct opcode_name_t *opcode;
 
   for (opcode = &opcode_name_list[0]; opcode->name != NULL; ++opcode)
-    {
-      retval = hash_insert (opcode_names_hash, opcode->name, (void *)opcode);
-
-      if (retval != NULL)
-	as_fatal (_("internal error: can't hash `%s': %s"),
-		  opcode->name, retval);
-    }
+    str_hash_insert (opcode_names_hash, opcode->name, (void *)opcode);
 }
 
 /* Find `s` is a valid opcode name or not,
@@ -598,7 +581,7 @@ opcode_name_lookup (char **s)
   save_c = *e;
   *e = '\0';
 
-  o = (struct opcode_name_t *) hash_find (opcode_names_hash, *s);
+  o = (struct opcode_name_t *) str_hash_find (opcode_names_hash, *s);
 
   /* Advance to next token if one was recognized.  */
   if (o)
@@ -619,8 +602,8 @@ enum reg_class
   RCLASS_CSR
 };
 
-static struct hash_control *reg_names_hash = NULL;
-static struct hash_control *csr_extra_hash = NULL;
+static htab_t reg_names_hash = NULL;
+static htab_t csr_extra_hash = NULL;
 
 #define ENCODE_REG_HASH(cls, n) \
   ((void *)(uintptr_t)((n) * RCLASS_MAX + (cls) + 1))
@@ -631,10 +614,7 @@ static void
 hash_reg_name (enum reg_class class, const char *name, unsigned n)
 {
   void *hash = ENCODE_REG_HASH (class, n);
-  const char *retval = hash_insert (reg_names_hash, name, hash);
-
-  if (retval != NULL)
-    as_fatal (_("internal error: can't hash `%s': %s"), name, retval);
+  str_hash_insert (reg_names_hash, name, hash);
 }
 
 static void
@@ -655,11 +635,10 @@ riscv_init_csr_hash (const char *name,
                     enum riscv_priv_spec_class abort_version)
 {
   struct riscv_csr_extra *entry, *pre_entry;
-  const char *hash_error = NULL;
   bfd_boolean need_enrty = TRUE;
 
   pre_entry = NULL;
-  entry = (struct riscv_csr_extra *) hash_find (csr_extra_hash, name);
+  entry = (struct riscv_csr_extra *) str_hash_find (csr_extra_hash, name);
   while (need_enrty && entry != NULL)
     {
       if (entry->csr_class == class
@@ -686,16 +665,7 @@ riscv_init_csr_hash (const char *name,
      Otherwise, attach the extra information to the entry which is already
      in the hash table.  */
   if (pre_entry == NULL)
-    {
-      hash_error = hash_insert (csr_extra_hash, name, (void *) entry);
-      if (hash_error != NULL)
-       {
-         fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-                  name, hash_error);
-         /* Probably a memory allocation problem?  Give up now.  */
-         as_fatal (_("Broken assembler.  No assembly attempted."));
-       }
-    }
+    str_hash_insert (csr_extra_hash, name, (void *) entry);
   else
     pre_entry->next = entry;
 }
@@ -772,7 +742,7 @@ static unsigned int
 reg_csr_lookup_internal (const char *s)
 {
   struct riscv_csr_extra *r =
-    (struct riscv_csr_extra *) hash_find (csr_extra_hash, s);
+    (struct riscv_csr_extra *) str_hash_find (csr_extra_hash, s);
 
   if (r == NULL)
     return -1U;
@@ -794,7 +764,7 @@ reg_lookup_internal (const char *s, enum
   if (class == RCLASS_CSR)
     return reg_csr_lookup_internal (s);
 
-  r = hash_find (reg_names_hash, s);
+  r = str_hash_find (reg_names_hash, s);
   if (r == NULL || DECODE_REG_CLASS (r) != class)
     return -1;
 
@@ -1018,26 +988,17 @@ struct percent_op_match
 
 /* Common hash table initialization function for
    instruction and .insn directive.  */
-static struct hash_control *
+static htab_t
 init_opcode_hash (const struct riscv_opcode *opcodes,
 		  bfd_boolean insn_directive_p)
 {
   int i = 0;
   int length;
-  struct hash_control *hash = hash_new ();
+  htab_t hash = str_htab_create ();
   while (opcodes[i].name)
     {
       const char *name = opcodes[i].name;
-      const char *hash_error =
-	hash_insert (hash, name, (void *) &opcodes[i]);
-
-      if (hash_error != NULL)
-	{
-	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
-		   opcodes[i].name, hash_error);
-	  /* Probably a memory allocation problem?  Give up now.  */
-	  as_fatal (_("Broken assembler.  No assembly attempted."));
-	}
+      str_hash_insert (hash, name, (void *) &opcodes[i]);
 
       do
 	{
@@ -1074,7 +1035,7 @@ md_begin (void)
   op_hash = init_opcode_hash (riscv_opcodes, FALSE);
   insn_type_hash = init_opcode_hash (riscv_insn_types, TRUE);
 
-  reg_names_hash = hash_new ();
+  reg_names_hash = str_htab_create ();
   hash_reg_names (RCLASS_GPR, riscv_gpr_names_numeric, NGPR);
   hash_reg_names (RCLASS_GPR, riscv_gpr_names_abi, NGPR);
   hash_reg_names (RCLASS_FPR, riscv_fpr_names_numeric, NFPR);
@@ -1083,7 +1044,7 @@ md_begin (void)
   hash_reg_name (RCLASS_GPR, "fp", 8);
 
   /* Create and insert CSR hash tables.  */
-  csr_extra_hash = hash_new ();
+  csr_extra_hash = str_htab_create ();
 #define DECLARE_CSR(name, num, class, define_version, abort_version) \
   riscv_init_csr_hash (#name, num, class, define_version, abort_version);
 #define DECLARE_CSR_ALIAS(name, num, class, define_version, abort_version) \
@@ -1091,7 +1052,7 @@ md_begin (void)
 #include "opcode/riscv-opc.h"
 #undef DECLARE_CSR
 
-  opcode_names_hash = hash_new ();
+  opcode_names_hash = str_htab_create ();
   init_opcode_names_hash ();
 
   /* Set the default alignment for the text section.  */
@@ -1196,7 +1157,7 @@ macro_build (expressionS *ep, const char
   va_start (args, fmt);
 
   r = BFD_RELOC_UNUSED;
-  mo = (struct riscv_opcode *) hash_find (op_hash, name);
+  mo = (struct riscv_opcode *) str_hash_find (op_hash, name);
   gas_assert (mo);
 
   /* Find a non-RVC variant of the instruction.  append_insn will compress
@@ -1796,7 +1757,7 @@ riscv_is_priv_insn (insn_t insn)
 
 static const char *
 riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,
-	  bfd_reloc_code_real_type *imm_reloc, struct hash_control *hash)
+	  bfd_reloc_code_real_type *imm_reloc, htab_t hash)
 {
   char *s;
   const char *args;
@@ -1812,7 +1773,7 @@ riscv_ip (char *str, struct riscv_cl_ins
   bfd_boolean insn_with_csr = FALSE;
 
   /* Parse the name of the instruction.  Terminate the string if whitespace
-     is found so that hash_find only sees the name part of the string.  */
+     is found so that str_hash_find only sees the name part of the string.  */
   for (s = str; *s != '\0'; ++s)
     if (ISSPACE (*s))
       {
@@ -1821,7 +1782,7 @@ riscv_ip (char *str, struct riscv_cl_ins
 	break;
       }
 
-  insn = (struct riscv_opcode *) hash_find (hash, str);
+  insn = (struct riscv_opcode *) str_hash_find (hash, str);
 
   argsStart = s;
   for ( ; insn && insn->name && strcmp (insn->name, str) == 0; insn++)
diff -rup binutils.orig/gas/config/tc-s390.c binutils-2.35/gas/config/tc-s390.c
--- binutils.orig/gas/config/tc-s390.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-s390.c	2021-08-11 17:39:31.413057500 +0100
@@ -197,10 +197,10 @@ register_name (expressionS *expressionP)
 /* Local variables.  */
 
 /* Opformat hash table.  */
-static struct hash_control *s390_opformat_hash;
+static htab_t s390_opformat_hash;
 
 /* Opcode hash table.  */
-static struct hash_control *s390_opcode_hash = NULL;
+static htab_t s390_opcode_hash = NULL;
 
 /* Flags to set in the elf header */
 static flagword s390_flags = 0;
@@ -494,13 +494,12 @@ s390_setup_opcodes (void)
   const struct s390_opcode *op;
   const struct s390_opcode *op_end;
   bfd_boolean dup_insn = FALSE;
-  const char *retval;
 
   if (s390_opcode_hash != NULL)
-    hash_die (s390_opcode_hash);
+    htab_delete (s390_opcode_hash);
 
   /* Insert the opcodes into a hash table.  */
-  s390_opcode_hash = hash_new ();
+  s390_opcode_hash = str_htab_create ();
 
   op_end = s390_opcodes + s390_num_opcodes;
   for (op = s390_opcodes; op < op_end; op++)
@@ -532,15 +531,7 @@ s390_setup_opcodes (void)
 	  use_opcode = ((f & current_flags) == f);
 	}
       if (use_opcode)
-	{
-	  retval = hash_insert (s390_opcode_hash, op->name, (void *) op);
-	  if (retval != (const char *) NULL)
-	    {
-	      as_bad (_("Internal assembler error for instruction %s"),
-		      op->name);
-	      dup_insn = TRUE;
-	    }
-	}
+	str_hash_insert (s390_opcode_hash, op->name, (void *) op);
 
       while (op < op_end - 1 && strcmp (op->name, op[1].name) == 0)
 	op++;
@@ -559,7 +550,6 @@ md_begin (void)
 {
   const struct s390_opcode *op;
   const struct s390_opcode *op_end;
-  const char *retval;
 
   /* Give a warning if the combination -m64-bit and -Aesa is used.  */
   if (s390_arch_size == 64 && current_cpu < S390_OPCODE_Z900)
@@ -572,16 +562,11 @@ md_begin (void)
     bfd_set_private_flags (stdoutput, s390_flags);
 
   /* Insert the opcode formats into a hash table.  */
-  s390_opformat_hash = hash_new ();
+  s390_opformat_hash = str_htab_create ();
 
   op_end = s390_opformats + s390_num_opformats;
   for (op = s390_opformats; op < op_end; op++)
-    {
-      retval = hash_insert (s390_opformat_hash, op->name, (void *) op);
-      if (retval != (const char *) NULL)
-	as_bad (_("Internal assembler error for instruction format %s"),
-		op->name);
-    }
+    str_hash_insert (s390_opformat_hash, op->name, (void *) op);
 
   s390_setup_opcodes ();
 
@@ -1693,7 +1678,7 @@ md_assemble (char *str)
     *s++ = '\0';
 
   /* Look up the opcode in the hash table.  */
-  opcode = (struct s390_opcode *) hash_find (s390_opcode_hash, str);
+  opcode = (struct s390_opcode *) str_hash_find (s390_opcode_hash, str);
   if (opcode == (const struct s390_opcode *) NULL)
     {
       as_bad (_("Unrecognized opcode: `%s'"), str);
@@ -1761,7 +1746,7 @@ s390_insn (int ignore ATTRIBUTE_UNUSED)
 
   /* Look up the opcode in the hash table.  */
   opformat = (struct s390_opcode *)
-    hash_find (s390_opformat_hash, input_line_pointer);
+    str_hash_find (s390_opformat_hash, input_line_pointer);
   if (opformat == (const struct s390_opcode *) NULL)
     {
       as_bad (_("Unrecognized opcode format: `%s'"), input_line_pointer);
diff -rup binutils.orig/gas/config/tc-score.c binutils-2.35/gas/config/tc-score.c
--- binutils.orig/gas/config/tc-score.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-score.c	2021-08-11 17:39:31.414057494 +0100
@@ -459,7 +459,7 @@ struct s3_reg_map
 {
   const struct s3_reg_entry *names;
   int max_regno;
-  struct hash_control *htab;
+  htab_t htab;
   const char *expected;
 };
 
@@ -470,8 +470,8 @@ static struct s3_reg_map s3_all_reg_maps
   {s3_score_crn_table, 31, NULL, N_("S+core co-processor register expected")},
 };
 
-static struct hash_control *s3_score_ops_hsh = NULL;
-static struct hash_control *s3_dependency_insn_hsh = NULL;
+static htab_t s3_score_ops_hsh = NULL;
+static htab_t s3_dependency_insn_hsh = NULL;
 
 
 struct s3_datafield_range
@@ -1027,7 +1027,7 @@ s3_end_of_line (char *str)
 }
 
 static int
-s3_score_reg_parse (char **ccp, struct hash_control *htab)
+s3_score_reg_parse (char **ccp, htab_t htab)
 {
   char *start = *ccp;
   char c;
@@ -1044,7 +1044,7 @@ s3_score_reg_parse (char **ccp, struct h
     c = *p++;
 
   *--p = 0;
-  reg = (struct s3_reg_entry *) hash_find (htab, start);
+  reg = (struct s3_reg_entry *) str_hash_find (htab, start);
   *p = c;
 
   if (reg)
@@ -2203,7 +2203,7 @@ s3_dependency_type_from_insn (char *insn
   const struct s3_insn_to_dependency *tmp;
 
   strcpy (name, insn_name);
-  tmp = (const struct s3_insn_to_dependency *) hash_find (s3_dependency_insn_hsh, name);
+  tmp = (const struct s3_insn_to_dependency *) str_hash_find (s3_dependency_insn_hsh, name);
 
   if (tmp)
     return tmp->type;
@@ -2662,7 +2662,7 @@ s3_parse_16_32_inst (char *insnstr, bfd_
   c = *p;
   *p = '\0';
 
-  opcode = (const struct s3_asm_opcode *) hash_find (s3_score_ops_hsh, operator);
+  opcode = (const struct s3_asm_opcode *) str_hash_find (s3_score_ops_hsh, operator);
   *p = c;
 
   memset (&s3_inst, '\0', sizeof (s3_inst));
@@ -2708,7 +2708,7 @@ s3_parse_48_inst (char *insnstr, bfd_boo
   c = *p;
   *p = '\0';
 
-  opcode = (const struct s3_asm_opcode *) hash_find (s3_score_ops_hsh, operator);
+  opcode = (const struct s3_asm_opcode *) str_hash_find (s3_score_ops_hsh, operator);
   *p = c;
 
   memset (&s3_inst, '\0', sizeof (s3_inst));
@@ -6251,7 +6251,7 @@ s3_s_score_lcomm (int bytes_p)
 }
 
 static void
-s3_insert_reg (const struct s3_reg_entry *r, struct hash_control *htab)
+s3_insert_reg (const struct s3_reg_entry *r, htab_t htab)
 {
   int i = 0;
   int len = strlen (r->name) + 2;
@@ -6265,8 +6265,8 @@ s3_insert_reg (const struct s3_reg_entry
     }
   buf2[i] = '\0';
 
-  hash_insert (htab, buf, (void *) r);
-  hash_insert (htab, buf2, (void *) r);
+  str_hash_insert (htab, buf, (void *) r);
+  str_hash_insert (htab, buf2, (void *) r);
 }
 
 static void
@@ -6274,7 +6274,7 @@ s3_build_reg_hsh (struct s3_reg_map *map
 {
   const struct s3_reg_entry *r;
 
-  if ((map->htab = hash_new ()) == NULL)
+  if ((map->htab = str_htab_create ()) == NULL)
     {
       as_fatal (_("virtual memory exhausted"));
     }
@@ -6309,7 +6309,7 @@ s3_build_score_ops_hsh (void)
       new_opcode->relax_value = insn->relax_value;
       new_opcode->type = insn->type;
       new_opcode->bitmask = insn->bitmask;
-      hash_insert (s3_score_ops_hsh, new_opcode->template_name,
+      str_hash_insert (s3_score_ops_hsh, new_opcode->template_name,
                    (void *) new_opcode);
     }
 }
@@ -6336,7 +6336,7 @@ s3_build_dependency_insn_hsh (void)
       strcpy (buf, tmp->insn_name);
       new_i2n->insn_name = buf;
       new_i2n->type = tmp->type;
-      hash_insert (s3_dependency_insn_hsh, new_i2n->insn_name,
+      str_hash_insert (s3_dependency_insn_hsh, new_i2n->insn_name,
                    (void *) new_i2n);
     }
 }
@@ -6505,12 +6505,12 @@ s3_begin (void)
   segT seg;
   subsegT subseg;
 
-  if ((s3_score_ops_hsh = hash_new ()) == NULL)
+  if ((s3_score_ops_hsh = str_htab_create ()) == NULL)
     as_fatal (_("virtual memory exhausted"));
 
   s3_build_score_ops_hsh ();
 
-  if ((s3_dependency_insn_hsh = hash_new ()) == NULL)
+  if ((s3_dependency_insn_hsh = str_htab_create ()) == NULL)
     as_fatal (_("virtual memory exhausted"));
 
   s3_build_dependency_insn_hsh ();
diff -rup binutils.orig/gas/config/tc-score7.c binutils-2.35/gas/config/tc-score7.c
--- binutils.orig/gas/config/tc-score7.c	2021-08-11 17:33:12.208490376 +0100
+++ binutils-2.35/gas/config/tc-score7.c	2021-08-11 17:39:31.414057494 +0100
@@ -520,7 +520,7 @@ struct s7_reg_map
 {
   const struct s7_reg_entry *names;
   int max_regno;
-  struct hash_control *htab;
+  htab_t htab;
   const char *expected;
 };
 
@@ -531,8 +531,8 @@ static struct s7_reg_map s7_all_reg_maps
   {s7_score_crn_table, 31, NULL, N_("S+core co-processor register expected")},
 };
 
-static struct hash_control *s7_score_ops_hsh = NULL;
-static struct hash_control *s7_dependency_insn_hsh = NULL;
+static htab_t s7_score_ops_hsh = NULL;
+static htab_t s7_dependency_insn_hsh = NULL;
 
 
 struct s7_datafield_range
@@ -1112,7 +1112,7 @@ s7_end_of_line (char *str)
 }
 
 static int
-s7_score_reg_parse (char **ccp, struct hash_control *htab)
+s7_score_reg_parse (char **ccp, htab_t htab)
 {
   char *start = *ccp;
   char c;
@@ -1129,7 +1129,7 @@ s7_score_reg_parse (char **ccp, struct h
     c = *p++;
 
   *--p = 0;
-  reg = (struct s7_reg_entry *) hash_find (htab, start);
+  reg = (struct s7_reg_entry *) str_hash_find (htab, start);
   *p = c;
 
   if (reg)
@@ -2321,7 +2321,7 @@ s7_dependency_type_from_insn (char *insn
   const struct s7_insn_to_dependency *tmp;
 
   strcpy (name, insn_name);
-  tmp = (const struct s7_insn_to_dependency *) hash_find (s7_dependency_insn_hsh, name);
+  tmp = (const struct s7_insn_to_dependency *) str_hash_find (s7_dependency_insn_hsh, name);
 
   if (tmp)
     return tmp->type;
@@ -2789,7 +2789,7 @@ s7_parse_16_32_inst (char *insnstr, bfd_
   c = *p;
   *p = '\0';
 
-  opcode = (const struct s7_asm_opcode *) hash_find (s7_score_ops_hsh, operator);
+  opcode = (const struct s7_asm_opcode *) str_hash_find (s7_score_ops_hsh, operator);
   *p = c;
 
   memset (&s7_inst, '\0', sizeof (s7_inst));
@@ -5103,7 +5103,7 @@ s7_build_score_ops_hsh (void)
       new_opcode->relax_value = insn->relax_value;
       new_opcode->type = insn->type;
       new_opcode->bitmask = insn->bitmask;
-      hash_insert (s7_score_ops_hsh, new_opcode->template_name,
+      str_hash_insert (s7_score_ops_hsh, new_opcode->template_name,
                    (void *) new_opcode);
     }
 }
@@ -5130,7 +5130,7 @@ s7_build_dependency_insn_hsh (void)
       strcpy (insn_name, tmp->insn_name);
       new_i2d->insn_name = insn_name;
       new_i2d->type = tmp->type;
-      hash_insert (s7_dependency_insn_hsh, new_i2d->insn_name,
+      str_hash_insert (s7_dependency_insn_hsh, new_i2d->insn_name,
                    (void *) new_i2d);
     }
 }
@@ -5345,7 +5345,7 @@ s7_parse_pce_inst (char *insnstr)
 
 
 static void
-s7_insert_reg (const struct s7_reg_entry *r, struct hash_control *htab)
+s7_insert_reg (const struct s7_reg_entry *r, htab_t htab)
 {
   int i = 0;
   int len = strlen (r->name) + 2;
@@ -5359,8 +5359,8 @@ s7_insert_reg (const struct s7_reg_entry
     }
   buf2[i] = '\0';
 
-  hash_insert (htab, buf, (void *) r);
-  hash_insert (htab, buf2, (void *) r);
+  str_hash_insert (htab, buf, (void *) r);
+  str_hash_insert (htab, buf2, (void *) r);
 }
 
 static void
@@ -5368,7 +5368,7 @@ s7_build_reg_hsh (struct s7_reg_map *map
 {
   const struct s7_reg_entry *r;
 
-  if ((map->htab = hash_new ()) == NULL)
+  if ((map->htab = str_htab_create ()) == NULL)
     {
       as_fatal (_("virtual memory exhausted"));
     }
@@ -6115,12 +6115,12 @@ s7_begin (void)
   segT seg;
   subsegT subseg;
 
-  if ((s7_score_ops_hsh = hash_new ()) == NULL)
+  if ((s7_score_ops_hsh = str_htab_create ()) == NULL)
     as_fatal (_("virtual memory exhausted"));
 
   s7_build_score_ops_hsh ();
 
-  if ((s7_dependency_insn_hsh = hash_new ()) == NULL)
+  if ((s7_dependency_insn_hsh = str_htab_create ()) == NULL)
     as_fatal (_("virtual memory exhausted"));
 
   s7_build_dependency_insn_hsh ();
diff -rup binutils.orig/gas/config/tc-sh.c binutils-2.35/gas/config/tc-sh.c
--- binutils.orig/gas/config/tc-sh.c	2021-08-11 17:33:12.212490350 +0100
+++ binutils-2.35/gas/config/tc-sh.c	2021-08-11 17:39:31.414057494 +0100
@@ -240,7 +240,7 @@ const relax_typeS md_relax_table[C (END,
 
 #undef EMPTY
 
-static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
+static htab_t opcode_hash_control;	/* Opcode mnemonics */
 
 
 #ifdef OBJ_ELF
@@ -564,7 +564,7 @@ md_begin (void)
     = preset_target_arch ? preset_target_arch : arch_sh_up & ~arch_sh_has_dsp;
   valid_arch = target_arch;
 
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
 
   /* Insert unique names into hash table.  */
   for (opcode = sh_table; opcode->name; opcode++)
@@ -574,7 +574,7 @@ md_begin (void)
 	  if (!SH_MERGE_ARCH_SET_VALID (opcode->arch, target_arch))
 	    continue;
 	  prev_name = opcode->name;
-	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
+	  str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
 	}
     }
 }
@@ -2196,7 +2196,7 @@ find_cooked_opcode (char **str_p)
   if (nlen == 0)
     as_bad (_("can't find opcode "));
 
-  return (sh_opcode_info *) hash_find (opcode_hash_control, name);
+  return (sh_opcode_info *) str_hash_find (opcode_hash_control, name);
 }
 
 /* Assemble a parallel processing insn.  */
diff -rup binutils.orig/gas/config/tc-sparc.c binutils-2.35/gas/config/tc-sparc.c
--- binutils.orig/gas/config/tc-sparc.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-sparc.c	2021-08-11 17:39:31.415057487 +0100
@@ -126,7 +126,7 @@ int sparc_cie_data_alignment;
 #endif
 
 /* Handle of the OPCODE hash table.  */
-static struct hash_control *op_hash;
+static htab_t op_hash;
 
 static void s_data1 (void);
 static void s_seg (int);
@@ -941,7 +941,6 @@ cmp_perc_entry (const void *parg, const
 void
 md_begin (void)
 {
-  const char *retval = NULL;
   int lose = 0;
   unsigned int i = 0;
 
@@ -952,18 +951,12 @@ md_begin (void)
     init_default_arch ();
 
   sparc_cie_data_alignment = sparc_arch_size == 64 ? -8 : -4;
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   while (i < (unsigned int) sparc_num_opcodes)
     {
       const char *name = sparc_opcodes[i].name;
-      retval = hash_insert (op_hash, name, (void *) &sparc_opcodes[i]);
-      if (retval != NULL)
-	{
-	  as_bad (_("Internal error: can't hash `%s': %s\n"),
-		  sparc_opcodes[i].name, retval);
-	  lose = 1;
-	}
+      str_hash_insert (op_hash, name, (void *) &sparc_opcodes[i]);
       do
 	{
 	  if (sparc_opcodes[i].match & sparc_opcodes[i].lose)
@@ -984,7 +977,7 @@ md_begin (void)
       const char *name = ((sparc_arch_size == 32)
 		    ? native_op_table[i].name32
 		    : native_op_table[i].name64);
-      insn = (struct sparc_opcode *) hash_find (op_hash, name);
+      insn = (struct sparc_opcode *) str_hash_find (op_hash, name);
       if (insn == NULL)
 	{
 	  as_bad (_("Internal error: can't find opcode `%s' for `%s'\n"),
@@ -992,16 +985,8 @@ md_begin (void)
 	  lose = 1;
 	}
       else
-	{
-	  retval = hash_insert (op_hash, native_op_table[i].name,
-				(void *) insn);
-	  if (retval != NULL)
-	    {
-	      as_bad (_("Internal error: can't hash `%s': %s\n"),
-		      sparc_opcodes[i].name, retval);
-	      lose = 1;
-	    }
-	}
+	str_hash_insert (op_hash, native_op_table[i].name,
+			 (void *) insn);
     }
 
   if (lose)
@@ -1759,7 +1744,7 @@ sparc_ip (char *str, const struct sparc_
       *pinsn = NULL;
       return special_case;
     }
-  insn = (struct sparc_opcode *) hash_find (op_hash, str);
+  insn = (struct sparc_opcode *) str_hash_find (op_hash, str);
   *pinsn = insn;
   if (insn == NULL)
     {
diff -rup binutils.orig/gas/config/tc-spu.c binutils-2.35/gas/config/tc-spu.c
--- binutils.orig/gas/config/tc-spu.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-spu.c	2021-08-11 17:39:31.415057487 +0100
@@ -57,7 +57,7 @@ static void spu_brinfo (int);
 static void spu_cons (int);
 
 extern char *myname;
-static struct hash_control *op_hash = NULL;
+static htab_t op_hash = NULL;
 
 /* These bits should be turned off in the first address of every segment */
 int md_seg_align = 7;
@@ -110,26 +110,19 @@ unsigned int brinfo;
 void
 md_begin (void)
 {
-  const char *retval = NULL;
   int i;
 
   /* initialize hash table */
 
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   /* loop until you see the end of the list */
 
   for (i = 0; i < spu_num_opcodes; i++)
-    {
-      /* hash each mnemonic and record its position */
-
-      retval = hash_insert (op_hash, spu_opcodes[i].mnemonic,
-			    (void *) &spu_opcodes[i]);
-
-      if (retval != NULL && strcmp (retval, "exists") != 0)
-	as_fatal (_("Can't hash instruction '%s':%s"),
-		  spu_opcodes[i].mnemonic, retval);
-    }
+    /* hash each mnemonic and record its position */
+    if (str_hash_find (op_hash, spu_opcodes[i].mnemonic) == NULL)
+      str_hash_insert (op_hash, spu_opcodes[i].mnemonic,
+		       (void *) &spu_opcodes[i]);
 }
 
 const char *md_shortopts = "";
@@ -285,7 +278,7 @@ md_assemble (char *op)
 
   /* try to find the instruction in the hash table */
 
-  if ((format = (struct spu_opcode *) hash_find (op_hash, op)) == NULL)
+  if ((format = (struct spu_opcode *) str_hash_find (op_hash, op)) == NULL)
     {
       as_bad (_("Invalid mnemonic '%s'"), op);
       return;
diff -rup binutils.orig/gas/config/tc-tic30.c binutils-2.35/gas/config/tc-tic30.c
--- binutils.orig/gas/config/tc-tic30.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-tic30.c	2021-08-11 17:39:31.415057487 +0100
@@ -99,78 +99,56 @@ debug (const char *string, ...)
 }
 
 /* Hash table for opcode lookup.  */
-static struct hash_control *op_hash;
+static htab_t op_hash;
 /* Hash table for parallel opcode lookup.  */
-static struct hash_control *parop_hash;
+static htab_t parop_hash;
 /* Hash table for register lookup.  */
-static struct hash_control *reg_hash;
+static htab_t reg_hash;
 /* Hash table for indirect addressing lookup.  */
-static struct hash_control *ind_hash;
+static htab_t ind_hash;
 
 void
 md_begin (void)
 {
-  const char *hash_err;
-
   debug ("In md_begin()\n");
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
   {
     const insn_template *current_optab = tic30_optab;
 
     for (; current_optab < tic30_optab_end; current_optab++)
-      {
-	hash_err = hash_insert (op_hash, current_optab->name,
-				(char *) current_optab);
-	if (hash_err)
-	  as_fatal ("Internal Error: Can't Hash %s: %s",
-		    current_optab->name, hash_err);
-      }
+      str_hash_insert (op_hash, current_optab->name,
+		       (char *) current_optab);
   }
 
-  parop_hash = hash_new ();
+  parop_hash = str_htab_create ();
 
   {
     const partemplate *current_parop = tic30_paroptab;
 
     for (; current_parop < tic30_paroptab_end; current_parop++)
-      {
-	hash_err = hash_insert (parop_hash, current_parop->name,
-				(char *) current_parop);
-	if (hash_err)
-	  as_fatal ("Internal Error: Can't Hash %s: %s",
-		    current_parop->name, hash_err);
-      }
+      str_hash_insert (parop_hash, current_parop->name,
+		       (char *) current_parop);
   }
 
-  reg_hash = hash_new ();
+  reg_hash = str_htab_create ();
 
   {
     const reg *current_reg = tic30_regtab;
 
     for (; current_reg < tic30_regtab_end; current_reg++)
-      {
-	hash_err = hash_insert (reg_hash, current_reg->name,
-				(char *) current_reg);
-	if (hash_err)
-	  as_fatal ("Internal Error: Can't Hash %s: %s",
-		    current_reg->name, hash_err);
-      }
+      str_hash_insert (reg_hash, current_reg->name,
+		       (char *) current_reg);
   }
 
-  ind_hash = hash_new ();
+  ind_hash = str_htab_create ();
 
   {
     const ind_addr_type *current_ind = tic30_indaddr_tab;
 
     for (; current_ind < tic30_indaddrtab_end; current_ind++)
-      {
-	hash_err = hash_insert (ind_hash, current_ind->syntax,
-				(char *) current_ind);
-	if (hash_err)
-	  as_fatal ("Internal Error: Can't Hash %s: %s",
-		    current_ind->syntax, hash_err);
-      }
+      str_hash_insert (ind_hash, current_ind->syntax,
+		       (char *) current_ind);
   }
 
   /* Fill in lexical tables:  opcode_chars, operand_chars, space_chars.  */
@@ -476,7 +454,7 @@ tic30_operand (char *token)
 	      && (*(token + count) == 'r' || *(token + count) == 'R'))
 	    {
 	      /* AR reference is found, so get its number and remove
-		 it from the buffer so it can pass through hash_find().  */
+		 it from the buffer so it can pass through str_hash_find().  */
 	      if (found_ar)
 		{
 		  as_bad (_("More than one AR register found in indirect reference"));
@@ -538,7 +516,7 @@ tic30_operand (char *token)
 	  return NULL;
 	}
 
-      ind_addr_op = (ind_addr_type *) hash_find (ind_hash, ind_buffer);
+      ind_addr_op = (ind_addr_type *) str_hash_find (ind_hash, ind_buffer);
       if (ind_addr_op)
 	{
 	  debug ("Found indirect reference: %s\n", ind_addr_op->syntax);
@@ -577,7 +555,7 @@ tic30_operand (char *token)
     }
   else
     {
-      reg *regop = (reg *) hash_find (reg_hash, token);
+      reg *regop = (reg *) str_hash_find (reg_hash, token);
 
       if (regop)
 	{
@@ -674,7 +652,7 @@ tic30_parallel_insn (char *token)
     /* Find instruction.  */
     save_char = *current_posn;
     *current_posn = '\0';
-    p_opcode = (partemplate *) hash_find (parop_hash, token);
+    p_opcode = (partemplate *) str_hash_find (parop_hash, token);
     if (p_opcode)
       {
 	debug ("Found instruction %s\n", p_opcode->name);
@@ -719,7 +697,7 @@ tic30_parallel_insn (char *token)
 	debug ("first_opcode = %s\n", first_opcode);
 	debug ("second_opcode = %s\n", second_opcode);
 	sprintf (token, "q_%s_%s", second_opcode, first_opcode);
-	p_opcode = (partemplate *) hash_find (parop_hash, token);
+	p_opcode = (partemplate *) str_hash_find (parop_hash, token);
 
 	if (p_opcode)
 	  {
@@ -1466,7 +1444,7 @@ md_assemble (char *line)
     /* Find instruction.  */
     save_char = *current_posn;
     *current_posn = '\0';
-    op = (insn_template *) hash_find (op_hash, token_start);
+    op = (insn_template *) str_hash_find (op_hash, token_start);
     if (op)
       {
 	debug ("Found instruction %s\n", op->name);
diff -rup binutils.orig/gas/config/tc-tic4x.c binutils-2.35/gas/config/tc-tic4x.c
--- binutils.orig/gas/config/tc-tic4x.c	2021-08-11 17:33:12.210490363 +0100
+++ binutils-2.35/gas/config/tc-tic4x.c	2021-08-11 17:39:31.415057487 +0100
@@ -53,10 +53,10 @@
 #define TIC4X_ALT_SYNTAX
 
 /* Handle of the inst mnemonic hash table.  */
-static struct hash_control *tic4x_op_hash = NULL;
+static htab_t tic4x_op_hash = NULL;
 
 /* Handle asg pseudo.  */
-static struct hash_control *tic4x_asg_hash = NULL;
+static htab_t tic4x_asg_hash = NULL;
 
 static unsigned int tic4x_cpu = 0;        /* Default to TMS320C40.  */
 static unsigned int tic4x_revision = 0;   /* CPU revision */
@@ -727,10 +727,7 @@ tic4x_asg (int x ATTRIBUTE_UNUSED)
   c = get_symbol_name (&name);	/* Get terminator.  */
   str = xstrdup (str);
   name = xstrdup (name);
-  if (hash_find (tic4x_asg_hash, name))
-    hash_replace (tic4x_asg_hash, name, (void *) str);
-  else
-    hash_insert (tic4x_asg_hash, name, (void *) str);
+  str_hash_insert (tic4x_asg_hash, name, str);
   (void) restore_line_pointer (c);
   demand_empty_rest_of_line ();
 }
@@ -1209,23 +1206,17 @@ tic4x_init_symbols (void)
 }
 
 /* Insert a new instruction template into hash table.  */
-static int
+static void
 tic4x_inst_insert (const tic4x_inst_t *inst)
 {
   static char prev_name[16];
-  const char *retval = NULL;
 
   /* Only insert the first name if have several similar entries.  */
   if (!strcmp (inst->name, prev_name) || inst->name[0] == '\0')
-    return 1;
+    return;
 
-  retval = hash_insert (tic4x_op_hash, inst->name, (void *) inst);
-  if (retval != NULL)
-    fprintf (stderr, "internal error: can't hash `%s': %s\n",
-	     inst->name, retval);
-  else
-    strcpy (prev_name, inst->name);
-  return retval == NULL;
+  str_hash_insert (tic4x_op_hash, inst->name, (void *) inst);
+  strcpy (prev_name, inst->name);
 }
 
 /* Make a new instruction template.  */
@@ -1258,13 +1249,12 @@ tic4x_inst_make (const char *name, unsig
 }
 
 /* Add instruction template, creating dynamic templates as required.  */
-static int
+static void
 tic4x_inst_add (const tic4x_inst_t *insts)
 {
   const char *s = insts->name;
   char *d;
   unsigned int i;
-  int ok = 1;
   char name[16];
 
   d = name;
@@ -1272,7 +1262,7 @@ tic4x_inst_add (const tic4x_inst_t *inst
   /* We do not care about INSNs that is not a part of our
      oplevel setting.  */
   if ((insts->oplevel & tic4x_oplevel) == 0)
-    return ok;
+    return;
 
   while (1)
     {
@@ -1296,8 +1286,8 @@ tic4x_inst_add (const tic4x_inst_t *inst
 	      *e = '\0';
 
 	      /* If instruction found then have already processed it.  */
-	      if (hash_find (tic4x_op_hash, name))
-		return 1;
+	      if (str_hash_find (tic4x_op_hash, name))
+		return;
 
 	      do
 		{
@@ -1306,18 +1296,17 @@ tic4x_inst_add (const tic4x_inst_t *inst
 					 (*s == 'B' ? 16 : 23)),
 					insts[k].args);
 		  if (k == 0)	/* Save strcmp() with following func.  */
-		    ok &= tic4x_inst_insert (inst);
+		    tic4x_inst_insert (inst);
 		  k++;
 		}
 	      while (!strcmp (insts->name,
 			      insts[k].name));
 	    }
-	  return ok;
-	  break;
+	  return;
 
 	case '\0':
-	  return tic4x_inst_insert (insts);
-	  break;
+	  tic4x_inst_insert (insts);
+	  return;
 
 	default:
 	  *d++ = *s++;
@@ -1332,7 +1321,6 @@ tic4x_inst_add (const tic4x_inst_t *inst
 void
 md_begin (void)
 {
-  int ok = 1;
   unsigned int i;
 
   /* Setup the proper opcode level according to the
@@ -1364,21 +1352,18 @@ md_begin (void)
     tic4x_oplevel |= OP_IDLE2;
 
   /* Create hash table for mnemonics.  */
-  tic4x_op_hash = hash_new ();
+  tic4x_op_hash = str_htab_create ();
 
   /* Create hash table for asg pseudo.  */
-  tic4x_asg_hash = hash_new ();
+  tic4x_asg_hash = str_htab_create ();
 
   /* Add mnemonics to hash table, expanding conditional mnemonics on fly.  */
   for (i = 0; i < tic4x_num_insts; i++)
-    ok &= tic4x_inst_add (tic4x_insts + i);
+    tic4x_inst_add (tic4x_insts + i);
 
   /* Create dummy inst to avoid errors accessing end of table.  */
   tic4x_inst_make ("", 0, "");
 
-  if (!ok)
-    as_fatal ("Broken assembler.  No assembly attempted.");
-
   /* Add registers to symbol table.  */
   tic4x_init_regtable ();
 
@@ -1509,7 +1494,7 @@ tic4x_operand_parse (char *s, tic4x_oper
 
   c = get_symbol_name (&str);	/* Get terminator.  */
   new_pointer = input_line_pointer;
-  if (strlen (str) && (entry = hash_find (tic4x_asg_hash, str)) != NULL)
+  if (strlen (str) && (entry = str_hash_find (tic4x_asg_hash, str)) != NULL)
     {
       (void) restore_line_pointer (c);
       input_line_pointer = (char *) entry;
@@ -2444,7 +2429,7 @@ md_assemble (char *str)
       /* Skip past instruction mnemonic.  */
       while (*s && *s != ' ')
 	s++;
-      if (*s)			/* Null terminate for hash_find.  */
+      if (*s)			/* Null terminate for str_hash_find.  */
 	*s++ = '\0';		/* and skip past null.  */
       len = strlen (insn->name);
       snprintf (insn->name + len, TIC4X_NAME_MAX - len, "_%s", str);
@@ -2465,7 +2450,7 @@ md_assemble (char *str)
   if (insn->in_use)
     {
       if ((insn->inst = (struct tic4x_inst *)
-	   hash_find (tic4x_op_hash, insn->name)) == NULL)
+	   str_hash_find (tic4x_op_hash, insn->name)) == NULL)
 	{
 	  as_bad (_("Unknown opcode `%s'."), insn->name);
 	  insn->parallel = 0;
@@ -2508,7 +2493,7 @@ md_assemble (char *str)
       s = str;
       while (*s && *s != ' ')	/* Skip past instruction mnemonic.  */
 	s++;
-      if (*s)			/* Null terminate for hash_find.  */
+      if (*s)			/* Null terminate for str_hash_find.  */
 	*s++ = '\0';		/* and skip past null.  */
       strncpy (insn->name, str, TIC4X_NAME_MAX - 1);
       insn->name[TIC4X_NAME_MAX - 1] = '\0';
diff -rup binutils.orig/gas/config/tc-tic54x.c binutils-2.35/gas/config/tc-tic54x.c
--- binutils.orig/gas/config/tc-tic54x.c	2021-08-11 17:33:12.211490357 +0100
+++ binutils-2.35/gas/config/tc-tic54x.c	2021-08-11 17:39:31.416057481 +0100
@@ -181,12 +181,12 @@ static symbolS *last_label_seen = NULL;
 /* This ensures that all new labels are unique.  */
 static int local_label_id;
 
-static struct hash_control *subsym_recurse_hash; /* Prevent infinite recurse.  */
-static struct hash_control *math_hash; /* Built-in math functions.  */
+static htab_t subsym_recurse_hash; /* Prevent infinite recurse.  */
+static htab_t math_hash; /* Built-in math functions.  */
 /* Allow maximum levels of macro nesting; level 0 is the main substitution
    symbol table.  The other assembler only does 32 levels, so there!  */
 #define MAX_SUBSYM_HASH 100
-static struct hash_control *subsym_hash[MAX_SUBSYM_HASH];
+static htab_t subsym_hash[MAX_SUBSYM_HASH];
 
 /* Keep track of local labels so we can substitute them before GAS sees them
    since macros use their own 'namespace' for local labels, use a separate hash
@@ -197,18 +197,18 @@ static struct hash_control *subsym_hash[
    We use our own macro nesting counter, since GAS overloads it when expanding
    other things (like conditionals and repeat loops).  */
 static int macro_level = 0;
-static struct hash_control *local_label_hash[100];
+static htab_t local_label_hash[100];
 /* Keep track of struct/union tags.  */
-static struct hash_control *stag_hash;
-static struct hash_control *op_hash;
-static struct hash_control *parop_hash;
-static struct hash_control *reg_hash;
-static struct hash_control *mmreg_hash;
-static struct hash_control *cc_hash;
-static struct hash_control *cc2_hash;
-static struct hash_control *cc3_hash;
-static struct hash_control *sbit_hash;
-static struct hash_control *misc_symbol_hash;
+static htab_t stag_hash;
+static htab_t op_hash;
+static htab_t parop_hash;
+static htab_t reg_hash;
+static htab_t mmreg_hash;
+static htab_t cc_hash;
+static htab_t cc2_hash;
+static htab_t cc3_hash;
+static htab_t sbit_hash;
+static htab_t misc_symbol_hash;
 
 /* Only word (et al.), align, or conditionals are allowed within
    .struct/.union.  */
@@ -569,7 +569,7 @@ stag_add_field_symbols (struct stag *sta
 
 	  replacement = concat (S_GET_NAME (rootsym), "+", root_stag_name,
 				name + strlen (S_GET_NAME (rootsym)), NULL);
-	  hash_insert (subsym_hash[0], name, replacement);
+	  str_hash_insert (subsym_hash[0], name, replacement);
 	}
 
       /* Recurse if the field is a structure.
@@ -740,7 +740,7 @@ tic54x_endstruct (int is_union)
   /* Nested .structs don't get put in the stag table.  */
   if (current_stag->outer == NULL)
     {
-      hash_insert (stag_hash, current_stag->name, current_stag);
+      str_hash_insert (stag_hash, current_stag->name, current_stag);
       stag_add_field_symbols (current_stag, path,
 			      S_GET_VALUE (current_stag->sym),
 			      NULL, NULL);
@@ -770,7 +770,7 @@ tic54x_tag (int ignore ATTRIBUTE_UNUSED)
 {
   char *name;
   int c = get_symbol_name (&name);
-  struct stag *stag = (struct stag *) hash_find (stag_hash, name);
+  struct stag *stag = (struct stag *) str_hash_find (stag_hash, name);
 
   if (!stag)
     {
@@ -1117,11 +1117,14 @@ tic54x_global (int type)
 
 /* Remove the symbol from the local label hash lookup.  */
 
-static void
-tic54x_remove_local_label (const char *key, void *value ATTRIBUTE_UNUSED)
+static int
+tic54x_remove_local_label (void **slot, void *arg ATTRIBUTE_UNUSED)
 {
-  void *elem = hash_delete (local_label_hash[macro_level], key, FALSE);
+  string_tuple_t *tuple = *((string_tuple_t **) slot);
+  void *elem = str_hash_find (local_label_hash[macro_level], tuple->key);
+  str_hash_delete (local_label_hash[macro_level], tuple->key);
   free (elem);
+  return 0;
 }
 
 /* Reset all local labels.  */
@@ -1129,7 +1132,7 @@ tic54x_remove_local_label (const char *k
 static void
 tic54x_clear_local_labels (int ignored ATTRIBUTE_UNUSED)
 {
-  hash_traverse (local_label_hash[macro_level], tic54x_remove_local_label);
+  htab_traverse (local_label_hash[macro_level], tic54x_remove_local_label, NULL);
 }
 
 /* .text
@@ -2235,7 +2238,7 @@ tic54x_var (int ignore ATTRIBUTE_UNUSED)
       c = get_symbol_name (&name);
       /* .var symbols start out with a null string.  */
       name = xstrdup (name);
-      hash_insert (subsym_hash[macro_level], name, empty);
+      str_hash_insert (subsym_hash[macro_level], name, empty);
       c = restore_line_pointer (c);
       if (c == ',')
 	{
@@ -2503,8 +2506,8 @@ tic54x_macro_start (void)
       as_fatal (_("Macro nesting is too deep"));
       return;
     }
-  subsym_hash[macro_level] = hash_new ();
-  local_label_hash[macro_level] = hash_new ();
+  subsym_hash[macro_level] = str_htab_create ();
+  local_label_hash[macro_level] = str_htab_create ();
 }
 
 void
@@ -2520,7 +2523,7 @@ tic54x_macro_info (const macro_entry *ma
 
       name[entry->name.len] = '\0';
       value[entry->actual.len] = '\0';
-      hash_insert (subsym_hash[macro_level], name, value);
+      str_hash_insert (subsym_hash[macro_level], name, value);
     }
 }
 
@@ -2529,9 +2532,9 @@ tic54x_macro_info (const macro_entry *ma
 void
 tic54x_macro_end (void)
 {
-  hash_die (subsym_hash[macro_level]);
+  htab_delete (subsym_hash[macro_level]);
   subsym_hash[macro_level] = NULL;
-  hash_die (local_label_hash[macro_level]);
+  htab_delete (local_label_hash[macro_level]);
   local_label_hash[macro_level] = NULL;
   --macro_level;
 }
@@ -2685,9 +2688,9 @@ subsym_isname (char *a, char *ignore ATT
 static int
 subsym_isreg (char *a, char *ignore ATTRIBUTE_UNUSED)
 {
-  if (hash_find (reg_hash, a))
+  if (str_hash_find (reg_hash, a))
     return 1;
-  if (hash_find (mmreg_hash, a))
+  if (str_hash_find (mmreg_hash, a))
     return 1;
   return 0;
 }
@@ -2697,7 +2700,7 @@ subsym_isreg (char *a, char *ignore ATTR
 static int
 subsym_structsz (char *name, char *ignore ATTRIBUTE_UNUSED)
 {
-  struct stag *stag = (struct stag *) hash_find (stag_hash, name);
+  struct stag *stag = (struct stag *) str_hash_find (stag_hash, name);
 
   if (stag)
     return stag->size;
@@ -2965,7 +2968,6 @@ md_begin (void)
   tic54x_symbol *sym;
   const subsym_proc_entry *subsym_proc;
   const math_proc_entry *math_proc;
-  const char *hash_err;
   char **symname;
   char *TIC54X_DIR = getenv ("TIC54X_DIR");
   char *A_DIR = TIC54X_DIR ? TIC54X_DIR : getenv ("A_DIR");
@@ -2989,27 +2991,21 @@ md_begin (void)
       while (tmp != NULL);
     }
 
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
   for (tm = (insn_template *) tic54x_optab; tm->name; tm++)
     {
-      if (hash_find (op_hash, tm->name))
+      if (str_hash_find (op_hash, tm->name))
 	continue;
-      hash_err = hash_insert (op_hash, tm->name, (char *) tm);
-      if (hash_err)
-	as_fatal ("Internal Error: Can't hash %s: %s",
-		  tm->name, hash_err);
+      str_hash_insert (op_hash, tm->name, (char *) tm);
     }
-  parop_hash = hash_new ();
+  parop_hash = str_htab_create ();
   for (tm = (insn_template *) tic54x_paroptab; tm->name; tm++)
     {
-      if (hash_find (parop_hash, tm->name))
+      if (str_hash_find (parop_hash, tm->name))
 	continue;
-      hash_err = hash_insert (parop_hash, tm->name, (char *) tm);
-      if (hash_err)
-	as_fatal ("Internal Error: Can't hash %s: %s",
-		  tm->name, hash_err);
+      str_hash_insert (parop_hash, tm->name, (char *) tm);
     }
-  reg_hash = hash_new ();
+  reg_hash = str_htab_create ();
   for (sym = (tic54x_symbol *) regs; sym->name; sym++)
     {
       /* Add basic registers to the symbol table.  */
@@ -3017,54 +3013,54 @@ md_begin (void)
 				     (valueT) sym->value, &zero_address_frag);
       SF_SET_LOCAL (symbolP);
       symbol_table_insert (symbolP);
-      hash_err = hash_insert (reg_hash, sym->name, (char *) sym);
+      str_hash_insert (reg_hash, sym->name, (char *) sym);
     }
   for (sym = (tic54x_symbol *) mmregs; sym->name; sym++)
-    hash_err = hash_insert (reg_hash, sym->name, (char *) sym);
-  mmreg_hash = hash_new ();
+    str_hash_insert (reg_hash, sym->name, (char *) sym);
+  mmreg_hash = str_htab_create ();
   for (sym = (tic54x_symbol *) mmregs; sym->name; sym++)
-    hash_err = hash_insert (mmreg_hash, sym->name, (char *) sym);
+    str_hash_insert (mmreg_hash, sym->name, (char *) sym);
 
-  cc_hash = hash_new ();
+  cc_hash = str_htab_create ();
   for (sym = (tic54x_symbol *) condition_codes; sym->name; sym++)
-    hash_err = hash_insert (cc_hash, sym->name, (char *) sym);
+    str_hash_insert (cc_hash, sym->name, (char *) sym);
 
-  cc2_hash = hash_new ();
+  cc2_hash = str_htab_create ();
   for (sym = (tic54x_symbol *) cc2_codes; sym->name; sym++)
-    hash_err = hash_insert (cc2_hash, sym->name, (char *) sym);
+    str_hash_insert (cc2_hash, sym->name, (char *) sym);
 
-  cc3_hash = hash_new ();
+  cc3_hash = str_htab_create ();
   for (sym = (tic54x_symbol *) cc3_codes; sym->name; sym++)
-    hash_err = hash_insert (cc3_hash, sym->name, (char *) sym);
+    str_hash_insert (cc3_hash, sym->name, (char *) sym);
 
-  sbit_hash = hash_new ();
+  sbit_hash = str_htab_create ();
   for (sym = (tic54x_symbol *) status_bits; sym->name; sym++)
-    hash_err = hash_insert (sbit_hash, sym->name, (char *) sym);
+    str_hash_insert (sbit_hash, sym->name, (char *) sym);
 
-  misc_symbol_hash = hash_new ();
+  misc_symbol_hash = str_htab_create ();
   for (symname = (char **) misc_symbols; *symname; symname++)
-    hash_err = hash_insert (misc_symbol_hash, *symname, *symname);
+    str_hash_insert (misc_symbol_hash, *symname, *symname);
 
   /* Only the base substitution table and local label table are initialized;
      the others (for local macro substitution) get instantiated as needed.  */
-  local_label_hash[0] = hash_new ();
-  subsym_hash[0] = hash_new ();
+  local_label_hash[0] = str_htab_create ();
+  subsym_hash[0] = str_htab_create ();
   for (subsym_proc = subsym_procs; subsym_proc->name; subsym_proc++)
-    hash_err = hash_insert (subsym_hash[0], subsym_proc->name,
-			    (char *) subsym_proc);
+    str_hash_insert (subsym_hash[0], subsym_proc->name,
+		     (char *) subsym_proc);
 
-  math_hash = hash_new ();
+  math_hash = str_htab_create ();
   for (math_proc = math_procs; math_proc->name; math_proc++)
     {
       /* Insert into the main subsym hash for recognition; insert into
 	 the math hash to actually store information.  */
-      hash_err = hash_insert (subsym_hash[0], math_proc->name,
-			      (char *) math_proc);
-      hash_err = hash_insert (math_hash, math_proc->name,
-			      (char *) math_proc);
+      str_hash_insert (subsym_hash[0], math_proc->name,
+		       (char *) math_proc);
+      str_hash_insert (math_hash, math_proc->name,
+		       (char *) math_proc);
     }
-  subsym_recurse_hash = hash_new ();
-  stag_hash = hash_new ();
+  subsym_recurse_hash = str_htab_create ();
+  stag_hash = str_htab_create ();
 }
 
 static int
@@ -3257,7 +3253,7 @@ is_mmreg (struct opstruct *operand)
 {
   return (is_absolute (operand)
 	  || is_immediate (operand)
-	  || hash_find (mmreg_hash, operand->buf) != 0);
+	  || str_hash_find (mmreg_hash, operand->buf) != 0);
 }
 
 static int
@@ -3301,13 +3297,13 @@ is_type (struct opstruct *operand, enum
       return strncasecmp ("ar", operand->buf, 2) == 0
 	&& ISDIGIT (operand->buf[2]);
     case OP_SBIT:
-      return hash_find (sbit_hash, operand->buf) != 0 || is_absolute (operand);
+      return str_hash_find (sbit_hash, operand->buf) != 0 || is_absolute (operand);
     case OP_CC:
-      return hash_find (cc_hash, operand->buf) != 0;
+      return str_hash_find (cc_hash, operand->buf) != 0;
     case OP_CC2:
-      return hash_find (cc2_hash, operand->buf) != 0;
+      return str_hash_find (cc2_hash, operand->buf) != 0;
     case OP_CC3:
-      return hash_find (cc3_hash, operand->buf) != 0
+      return str_hash_find (cc3_hash, operand->buf) != 0
 	|| is_immediate (operand) || is_absolute (operand);
     case OP_16:
       return (is_immediate (operand) || is_absolute (operand))
@@ -3649,7 +3645,7 @@ encode_integer (tic54x_insn *insn,
 static int
 encode_condition (tic54x_insn *insn, struct opstruct *operand)
 {
-  tic54x_symbol *cc = (tic54x_symbol *) hash_find (cc_hash, operand->buf);
+  tic54x_symbol *cc = (tic54x_symbol *) str_hash_find (cc_hash, operand->buf);
   if (!cc)
     {
       as_bad (_("Unrecognized condition code \"%s\""), operand->buf);
@@ -3709,7 +3705,7 @@ encode_condition (tic54x_insn *insn, str
 static int
 encode_cc3 (tic54x_insn *insn, struct opstruct *operand)
 {
-  tic54x_symbol *cc3 = (tic54x_symbol *) hash_find (cc3_hash, operand->buf);
+  tic54x_symbol *cc3 = (tic54x_symbol *) str_hash_find (cc3_hash, operand->buf);
   int value = cc3 ? cc3->value : operand->exp.X_add_number << 8;
 
   if ((value & 0x0300) != value)
@@ -3738,7 +3734,7 @@ encode_arx (tic54x_insn *insn, struct op
 static int
 encode_cc2 (tic54x_insn *insn, struct opstruct *operand)
 {
-  tic54x_symbol *cc2 = (tic54x_symbol *) hash_find (cc2_hash, operand->buf);
+  tic54x_symbol *cc2 = (tic54x_symbol *) str_hash_find (cc2_hash, operand->buf);
 
   if (!cc2)
     {
@@ -3898,7 +3894,7 @@ encode_operand (tic54x_insn *insn, enum
     case OP_SBIT:
       {
 	tic54x_symbol *sbit = (tic54x_symbol *)
-	  hash_find (sbit_hash, operand->buf);
+	  str_hash_find (sbit_hash, operand->buf);
 	int value = is_absolute (operand) ?
 	  operand->exp.X_add_number : (sbit ? sbit->value : -1);
 	int reg = 0;
@@ -3912,7 +3908,7 @@ encode_operand (tic54x_insn *insn, enum
 	      }
 	    /* Guess the register based on the status bit; "ovb" is the last
 	       status bit defined for st0.  */
-	    if (sbit > (tic54x_symbol *) hash_find (sbit_hash, "ovb"))
+	    if (sbit > (tic54x_symbol *) str_hash_find (sbit_hash, "ovb"))
 	      reg = 1;
 	  }
 	if (value == -1)
@@ -4152,7 +4148,7 @@ optimize_insn (tic54x_insn *insn)
 static int
 tic54x_parse_insn (tic54x_insn *insn, char *line)
 {
-  insn->tm = (insn_template *) hash_find (op_hash, insn->mnemonic);
+  insn->tm = (insn_template *) str_hash_find (op_hash, insn->mnemonic);
   if (!insn->tm)
     {
       as_bad (_("Unrecognized instruction \"%s\""), insn->mnemonic);
@@ -4175,7 +4171,7 @@ tic54x_parse_insn (tic54x_insn *insn, ch
 	  /* SUCCESS! now try some optimizations.  */
 	  if (optimize_insn (insn))
 	    {
-	      insn->tm = (insn_template *) hash_find (op_hash,
+	      insn->tm = (insn_template *) str_hash_find (op_hash,
                                                       insn->mnemonic);
 	      continue;
 	    }
@@ -4210,7 +4206,7 @@ next_line_shows_parallel (char *next_lin
 static int
 tic54x_parse_parallel_insn_firstline (tic54x_insn *insn, char *line)
 {
-  insn->tm = (insn_template *) hash_find (parop_hash, insn->mnemonic);
+  insn->tm = (insn_template *) str_hash_find (parop_hash, insn->mnemonic);
   if (!insn->tm)
     {
       as_bad (_("Unrecognized parallel instruction \"%s\""),
@@ -4341,17 +4337,8 @@ subsym_create_or_replace (char *name, ch
   int i;
 
   for (i = macro_level; i > 0; i--)
-    {
-      if (hash_find (subsym_hash[i], name))
-	{
-	  hash_replace (subsym_hash[i], name, value);
-	  return;
-	}
-    }
-  if (hash_find (subsym_hash[0], name))
-    hash_replace (subsym_hash[0], name, value);
-  else
-    hash_insert (subsym_hash[0], name, value);
+    str_hash_insert (subsym_hash[i], name, value);
+  str_hash_insert (subsym_hash[0], name, value);
 }
 
 /* Look up the substitution string replacement for the given symbol.
@@ -4361,7 +4348,7 @@ subsym_create_or_replace (char *name, ch
 static char *
 subsym_lookup (char *name, int nest_level)
 {
-  char *value = hash_find (subsym_hash[nest_level], name);
+  char *value = str_hash_find (subsym_hash[nest_level], name);
 
   if (value || nest_level == 0)
     return value;
@@ -4482,7 +4469,7 @@ subsym_substitute (char *line, int force
 	    }
 	  /* Avoid infinite recursion; if a symbol shows up a second time for
 	     substitution, leave it as is.  */
-	  if (hash_find (subsym_recurse_hash, name) == NULL)
+	  if (str_hash_find (subsym_recurse_hash, name) == NULL)
 	    value = subsym_lookup (name, macro_level);
 	  else
 	    as_warn (_("%s symbol recursion stopped at "
@@ -4498,7 +4485,7 @@ subsym_substitute (char *line, int force
 	    {
 	      /* Use an existing identifier for that label if, available, or
 		 create a new, unique identifier.  */
-	      value = hash_find (local_label_hash[macro_level], name);
+	      value = str_hash_find (local_label_hash[macro_level], name);
 	      if (value == NULL)
 		{
 		  char digit[11];
@@ -4510,7 +4497,7 @@ subsym_substitute (char *line, int force
 		    value[strlen (value) - 1] = '\0';
 		  sprintf (digit, ".%d", local_label_id++);
 		  strcat (value, digit);
-		  hash_insert (local_label_hash[macro_level], namecopy, value);
+		  str_hash_insert (local_label_hash[macro_level], namecopy, value);
 		}
 	      /* Indicate where to continue looking for substitutions.  */
 	      ptr = tail;
@@ -4519,7 +4506,7 @@ subsym_substitute (char *line, int force
 	  else if (value != NULL && *name == '$')
 	    {
 	      subsym_proc_entry *entry = (subsym_proc_entry *) value;
-	      math_proc_entry *math_entry = hash_find (math_hash, name);
+	      math_proc_entry *math_entry = str_hash_find (math_hash, name);
 	      char *arg1, *arg2 = NULL;
 
 	      *ptr = c;
@@ -4631,9 +4618,9 @@ subsym_substitute (char *line, int force
 		 try to replace a symbol once.  */
 	      if (recurse)
 		{
-		  hash_insert (subsym_recurse_hash, name, name);
+		  str_hash_insert (subsym_recurse_hash, name, name);
 		  value = subsym_substitute (value, macro_level > 0);
-		  hash_delete (subsym_recurse_hash, name, FALSE);
+		  str_hash_delete (subsym_recurse_hash, name);
 		}
 
 	      /* Temporarily zero-terminate where the symbol started.  */
@@ -5022,19 +5009,19 @@ tic54x_undefined_symbol (char *name)
   tic54x_symbol *sym;
 
   /* Not sure how to handle predefined symbols.  */
-  if ((sym = (tic54x_symbol *) hash_find (cc_hash, name)) != NULL ||
-      (sym = (tic54x_symbol *) hash_find (cc2_hash, name)) != NULL ||
-      (sym = (tic54x_symbol *) hash_find (cc3_hash, name)) != NULL ||
-      (sym = (tic54x_symbol *) hash_find (misc_symbol_hash, name)) != NULL ||
-      (sym = (tic54x_symbol *) hash_find (sbit_hash, name)) != NULL)
+  if ((sym = (tic54x_symbol *) str_hash_find (cc_hash, name)) != NULL ||
+      (sym = (tic54x_symbol *) str_hash_find (cc2_hash, name)) != NULL ||
+      (sym = (tic54x_symbol *) str_hash_find (cc3_hash, name)) != NULL ||
+      (sym = (tic54x_symbol *) str_hash_find (misc_symbol_hash, name)) != NULL ||
+      (sym = (tic54x_symbol *) str_hash_find (sbit_hash, name)) != NULL)
     {
       return symbol_new (name, reg_section,
 			 (valueT) sym->value,
 			 &zero_address_frag);
     }
 
-  if ((sym = (tic54x_symbol *) hash_find (reg_hash, name)) != NULL ||
-      (sym = (tic54x_symbol *) hash_find (mmreg_hash, name)) != NULL ||
+  if ((sym = (tic54x_symbol *) str_hash_find (reg_hash, name)) != NULL ||
+      (sym = (tic54x_symbol *) str_hash_find (mmreg_hash, name)) != NULL ||
       !strcasecmp (name, "a") || !strcasecmp (name, "b"))
     {
       return symbol_new (name, reg_section,
diff -rup binutils.orig/gas/config/tc-tic6x.c binutils-2.35/gas/config/tc-tic6x.c
--- binutils.orig/gas/config/tc-tic6x.c	2021-08-11 17:33:12.208490376 +0100
+++ binutils-2.35/gas/config/tc-tic6x.c	2021-08-11 17:39:31.416057481 +0100
@@ -742,7 +742,7 @@ const pseudo_typeS md_pseudo_table[] =
 /* Hash table of opcodes.  For each opcode name, this stores a pointer
    to a tic6x_opcode_list listing (in an arbitrary order) all opcode
    table entries with that name.  */
-static struct hash_control *opcode_hash;
+static htab_t opcode_hash;
 
 /* Initialize the assembler (called once at assembler startup).  */
 
@@ -757,17 +757,14 @@ md_begin (void)
   bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);
 
   /* Insert opcodes into the hash table.  */
-  opcode_hash = hash_new ();
+  opcode_hash = str_htab_create ();
   for (id = 0; id < tic6x_opcode_max; id++)
     {
-      const char *errmsg;
       tic6x_opcode_list *opc = XNEW (tic6x_opcode_list);
 
       opc->id = id;
-      opc->next = hash_find (opcode_hash, tic6x_opcode_table[id].name);
-      if ((errmsg = hash_jam (opcode_hash, tic6x_opcode_table[id].name, opc))
-	  != NULL)
-	as_fatal ("%s", _(errmsg));
+      opc->next = str_hash_find (opcode_hash, tic6x_opcode_table[id].name);
+      str_hash_insert (opcode_hash, tic6x_opcode_table[id].name, opc);
     }
 
   /* Save the current subseg so we can restore it [it's the default one and
@@ -3187,7 +3184,7 @@ md_assemble (char *str)
   this_insn_label_list = seginfo->tc_segment_info_data.label_list;
   seginfo->tc_segment_info_data.label_list = NULL;
 
-  opc_list = hash_find_n (opcode_hash, str, p - str);
+  opc_list = str_hash_find_n (opcode_hash, str, p - str);
   if (opc_list == NULL)
     {
       char c = *p;
diff -rup binutils.orig/gas/config/tc-tilegx.c binutils-2.35/gas/config/tc-tilegx.c
--- binutils.orig/gas/config/tc-tilegx.c	2021-08-11 17:33:12.209490370 +0100
+++ binutils-2.35/gas/config/tc-tilegx.c	2021-08-11 17:39:31.416057481 +0100
@@ -177,13 +177,13 @@ md_show_usage (FILE *stream)
 #define O_hw1_last_plt		O_md27
 #define O_hw2_last_plt		O_md28
 
-static struct hash_control *special_operator_hash;
+static htab_t special_operator_hash;
 
 /* Hash tables for instruction mnemonic lookup.  */
-static struct hash_control *op_hash;
+static htab_t op_hash;
 
 /* Hash table for spr lookup.  */
-static struct hash_control *spr_hash;
+static htab_t spr_hash;
 
 /* True temporarily while parsing an SPR expression. This changes the
  * namespace to include SPR names.  */
@@ -231,7 +231,7 @@ static int allow_suspicious_bundles;
    for that register (e.g. r63 instead of zero), so we should generate
    a warning. The attempted register number can be found by clearing
    NONCANONICAL_REG_NAME_FLAG.  */
-static struct hash_control *main_reg_hash;
+static htab_t main_reg_hash;
 
 
 /* We cannot unambiguously store a 0 in a hash table and look it up,
@@ -273,9 +273,9 @@ md_begin (void)
   tilegx_cie_data_alignment = (tilegx_arch_size == 64 ? -8 : -4);
 
   /* Initialize special operator hash table.  */
-  special_operator_hash = hash_new ();
+  special_operator_hash = str_htab_create ();
 #define INSERT_SPECIAL_OP(name)					\
-  hash_insert (special_operator_hash, #name, (void *)O_##name)
+  str_hash_insert (special_operator_hash, #name, (void *)O_##name)
 
   INSERT_SPECIAL_OP (hw0);
   INSERT_SPECIAL_OP (hw1);
@@ -285,7 +285,7 @@ md_begin (void)
   INSERT_SPECIAL_OP (hw1_last);
   INSERT_SPECIAL_OP (hw2_last);
   /* hw3_last is a convenience alias for the equivalent hw3.  */
-  hash_insert (special_operator_hash, "hw3_last", (void*)O_hw3);
+  str_hash_insert (special_operator_hash, "hw3_last", (void*)O_hw3);
   INSERT_SPECIAL_OP (hw0_got);
   INSERT_SPECIAL_OP (hw0_last_got);
   INSERT_SPECIAL_OP (hw1_last_got);
@@ -310,36 +310,32 @@ md_begin (void)
 #undef INSERT_SPECIAL_OP
 
   /* Initialize op_hash hash table.  */
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
   for (op = &tilegx_opcodes[0]; op->name != NULL; op++)
-    {
-      const char *hash_err = hash_insert (op_hash, op->name, (void *)op);
-      if (hash_err != NULL)
-	as_fatal (_("Internal Error:  Can't hash %s: %s"), op->name, hash_err);
-    }
+    str_hash_insert (op_hash, op->name, (void *)op);
 
   /* Initialize the spr hash table.  */
   parsing_spr = 0;
-  spr_hash = hash_new ();
+  spr_hash = str_htab_create ();
   for (i = 0; i < tilegx_num_sprs; i++)
-    hash_insert (spr_hash, tilegx_sprs[i].name,
+    str_hash_insert (spr_hash, tilegx_sprs[i].name,
                  (void *) &tilegx_sprs[i]);
 
   /* Set up the main_reg_hash table. We use this instead of
      creating a symbol in the register section to avoid ambiguities
      with labels that have the same names as registers.  */
-  main_reg_hash = hash_new ();
+  main_reg_hash = str_htab_create ();
   for (i = 0; i < TILEGX_NUM_REGISTERS; i++)
     {
       char buf[64];
 
-      hash_insert (main_reg_hash, tilegx_register_names[i],
+      str_hash_insert (main_reg_hash, tilegx_register_names[i],
 		   (void *) (long) (i | CANONICAL_REG_NAME_FLAG));
 
       /* See if we should insert a noncanonical alias, like r63.  */
       sprintf (buf, "r%d", i);
       if (strcmp (buf, tilegx_register_names[i]) != 0)
-	hash_insert (main_reg_hash, xstrdup (buf),
+	str_hash_insert (main_reg_hash, xstrdup (buf),
 		     (void *) (long) (i | NONCANONICAL_REG_NAME_FLAG));
     }
 }
@@ -1013,7 +1009,7 @@ tilegx_parse_name (char *name, expressio
 
   if (parsing_spr)
     {
-      void* val = hash_find (spr_hash, name);
+      void* val = str_hash_find (spr_hash, name);
       if (val == NULL)
 	return 0;
 
@@ -1031,7 +1027,7 @@ tilegx_parse_name (char *name, expressio
   else
     {
       /* Look up the operator in our table.  */
-      void* val = hash_find (special_operator_hash, name);
+      void* val = str_hash_find (special_operator_hash, name);
       if (val == 0)
 	return 0;
       op = (operatorT)(long)val;
@@ -1098,7 +1094,7 @@ parse_reg_expression (expressionS* expre
 
   terminating_char = get_symbol_name (&regname);
 
-  pval = hash_find (main_reg_hash, regname);
+  pval = str_hash_find (main_reg_hash, regname);
   if (pval == NULL)
     as_bad (_("Expected register, got '%s'."), regname);
 
@@ -1243,7 +1239,7 @@ md_assemble (char *str)
   old_char = str[opname_len];
   str[opname_len] = '\0';
 
-  op = hash_find(op_hash, str);
+  op = str_hash_find(op_hash, str);
   str[opname_len] = old_char;
   if (op == NULL)
     {
diff -rup binutils.orig/gas/config/tc-tilepro.c binutils-2.35/gas/config/tc-tilepro.c
--- binutils.orig/gas/config/tc-tilepro.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-tilepro.c	2021-08-11 17:39:31.416057481 +0100
@@ -126,13 +126,13 @@ md_show_usage (FILE *stream)
 #define O_tls_gd_add  O_md22
 #define O_tls_ie_load O_md23
 
-static struct hash_control *special_operator_hash;
+static htab_t special_operator_hash;
 
 /* Hash tables for instruction mnemonic lookup.  */
-static struct hash_control *op_hash;
+static htab_t op_hash;
 
 /* Hash table for spr lookup.  */
-static struct hash_control *spr_hash;
+static htab_t spr_hash;
 
 /* True temporarily while parsing an SPR expression. This changes the
  * namespace to include SPR names.  */
@@ -181,7 +181,7 @@ static int allow_suspicious_bundles;
    for that register (e.g. r63 instead of zero), so we should generate
    a warning. The attempted register number can be found by clearing
    NONCANONICAL_REG_NAME_FLAG.  */
-static struct hash_control *main_reg_hash;
+static htab_t main_reg_hash;
 
 
 /* We cannot unambiguously store a 0 in a hash table and look it up,
@@ -216,9 +216,9 @@ md_begin (void)
   inside_bundle = 0;
 
   /* Initialize special operator hash table.  */
-  special_operator_hash = hash_new ();
+  special_operator_hash = str_htab_create ();
 #define INSERT_SPECIAL_OP(name)					\
-  hash_insert (special_operator_hash, #name, (void *)O_##name)
+  str_hash_insert (special_operator_hash, #name, (void *)O_##name)
 
   INSERT_SPECIAL_OP(lo16);
   INSERT_SPECIAL_OP(hi16);
@@ -246,54 +246,47 @@ md_begin (void)
 #undef INSERT_SPECIAL_OP
 
   /* Initialize op_hash hash table.  */
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
   for (op = &tilepro_opcodes[0]; op->name != NULL; op++)
-    {
-      const char *hash_err = hash_insert (op_hash, op->name, (void *)op);
-      if (hash_err != NULL)
-	{
-	  as_fatal (_("Internal Error:  Can't hash %s: %s"),
-		    op->name, hash_err);
-	}
-    }
+    str_hash_insert (op_hash, op->name, (void *)op);
 
   /* Initialize the spr hash table.  */
   parsing_spr = 0;
-  spr_hash = hash_new ();
+  spr_hash = str_htab_create ();
   for (i = 0; i < tilepro_num_sprs; i++)
-    hash_insert (spr_hash, tilepro_sprs[i].name,
+    str_hash_insert (spr_hash, tilepro_sprs[i].name,
                  (void *) &tilepro_sprs[i]);
 
   /* Set up the main_reg_hash table. We use this instead of
    * creating a symbol in the register section to avoid ambiguities
    * with labels that have the same names as registers.  */
-  main_reg_hash = hash_new ();
+  main_reg_hash = str_htab_create ();
   for (i = 0; i < TILEPRO_NUM_REGISTERS; i++)
     {
       char buf[64];
 
-      hash_insert (main_reg_hash, tilepro_register_names[i],
+      str_hash_insert (main_reg_hash, tilepro_register_names[i],
 		   (void *) (long)(i | CANONICAL_REG_NAME_FLAG));
 
       /* See if we should insert a noncanonical alias, like r63.  */
       sprintf (buf, "r%d", i);
       if (strcmp (buf, tilepro_register_names[i]) != 0)
-	hash_insert (main_reg_hash, xstrdup (buf),
+	str_hash_insert (main_reg_hash, xstrdup (buf),
 		     (void *) (long)(i | NONCANONICAL_REG_NAME_FLAG));
     }
 
   /* Insert obsolete backwards-compatibility register names.  */
-  hash_insert (main_reg_hash, "io0",
+  str_hash_insert (main_reg_hash, "io0",
                (void *) (long) (TREG_IDN0 | CANONICAL_REG_NAME_FLAG));
-  hash_insert (main_reg_hash, "io1",
+  str_hash_insert (main_reg_hash, "io1",
                (void *) (long) (TREG_IDN1 | CANONICAL_REG_NAME_FLAG));
-  hash_insert (main_reg_hash, "us0",
+  str_hash_insert (main_reg_hash, "us0",
                (void *) (long) (TREG_UDN0 | CANONICAL_REG_NAME_FLAG));
-  hash_insert (main_reg_hash, "us1",
+  str_hash_insert (main_reg_hash, "us1",
                (void *) (long) (TREG_UDN1 | CANONICAL_REG_NAME_FLAG));
-  hash_insert (main_reg_hash, "us2",
+  str_hash_insert (main_reg_hash, "us2",
                (void *) (long) (TREG_UDN2 | CANONICAL_REG_NAME_FLAG));
-  hash_insert (main_reg_hash, "us3",
+  str_hash_insert (main_reg_hash, "us3",
                (void *) (long) (TREG_UDN3 | CANONICAL_REG_NAME_FLAG));
 
 }
@@ -903,7 +896,7 @@ tilepro_parse_name (char *name, expressi
 
   if (parsing_spr)
     {
-      void *val = hash_find (spr_hash, name);
+      void *val = str_hash_find (spr_hash, name);
       if (val == NULL)
 	return 0;
 
@@ -922,7 +915,7 @@ tilepro_parse_name (char *name, expressi
   else
     {
       /* Look up the operator in our table.  */
-      void *val = hash_find (special_operator_hash, name);
+      void *val = str_hash_find (special_operator_hash, name);
       if (val == 0)
 	return 0;
       op = (operatorT)(long)val;
@@ -984,7 +977,7 @@ parse_reg_expression (expressionS* expre
   char *regname;
   char terminating_char = get_symbol_name (&regname);
 
-  void* pval = hash_find (main_reg_hash, regname);
+  void* pval = str_hash_find (main_reg_hash, regname);
 
   if (pval == NULL)
     as_bad (_("Expected register, got '%s'."), regname);
@@ -1128,7 +1121,7 @@ md_assemble (char *str)
   old_char = str[opname_len];
   str[opname_len] = '\0';
 
-  op = hash_find(op_hash, str);
+  op = str_hash_find(op_hash, str);
   str[opname_len] = old_char;
   if (op == NULL)
     {
diff -rup binutils.orig/gas/config/tc-v850.c binutils-2.35/gas/config/tc-v850.c
--- binutils.orig/gas/config/tc-v850.c	2021-08-11 17:33:12.214490337 +0100
+++ binutils-2.35/gas/config/tc-v850.c	2021-08-11 17:39:31.417057475 +0100
@@ -599,7 +599,7 @@ const pseudo_typeS md_pseudo_table[] =
 };
 
 /* Opcode hash table.  */
-static struct hash_control *v850_hash;
+static htab_t v850_hash;
 
 /* This table is sorted.  Suitable for searching by a binary search.  */
 static const struct reg_name pre_defined_registers[] =
@@ -1952,7 +1952,7 @@ md_begin (void)
   if (soft_float == -1)
     soft_float = machine < bfd_mach_v850e2v3;
 
-  v850_hash = hash_new ();
+  v850_hash = str_htab_create ();
 
   /* Insert unique names into hash table.  The V850 instruction set
      has many identical opcode names that have different opcodes based
@@ -1964,7 +1964,8 @@ md_begin (void)
       if (strcmp (prev_name, op->name))
 	{
 	  prev_name = (char *) op->name;
-	  hash_insert (v850_hash, op->name, (char *) op);
+	  if (str_hash_find (v850_hash, op->name) == NULL)
+	    str_hash_insert (v850_hash, op->name, (char *) op);
 	}
       op++;
     }
@@ -2321,7 +2322,7 @@ md_assemble (char *str)
     *s++ = '\0';
 
   /* Find the first opcode with the proper name.  */
-  opcode = (struct v850_opcode *) hash_find (v850_hash, str);
+  opcode = (struct v850_opcode *) str_hash_find (v850_hash, str);
   if (opcode == NULL)
     {
       /* xgettext:c-format  */
diff -rup binutils.orig/gas/config/tc-vax.c binutils-2.35/gas/config/tc-vax.c
--- binutils.orig/gas/config/tc-vax.c	2021-08-11 17:33:12.212490350 +0100
+++ binutils-2.35/gas/config/tc-vax.c	2021-08-11 17:39:31.417057475 +0100
@@ -736,7 +736,7 @@ md_ri_to_chars (char *the_bytes, struct
   	source file, and changed the makefile.  */
 
 /* Handle of the OPCODE hash table.  */
-static struct hash_control *op_hash;
+static htab_t op_hash;
 
 /* In:	1 character, from "bdfghloqpw" being the data-type of an operand
   	of a vax instruction.
@@ -950,29 +950,26 @@ vip_op_defaults (const char *immediate,
    instruction table.
    You must nominate metacharacters for eg DEC's "#", "@", "^".  */
 
-static const char *
+static void
 vip_begin (int synthetic_too,		/* 1 means include jXXX op-codes.  */
 	   const char *immediate,
 	   const char *indirect,
 	   const char *displen)
 {
   const struct vot *vP;		/* scan votstrs */
-  const char *retval = 0;	/* error text */
 
-  op_hash = hash_new ();
+  op_hash = str_htab_create ();
 
-  for (vP = votstrs; *vP->vot_name && !retval; vP++)
-    retval = hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);
+  for (vP = votstrs; *vP->vot_name; vP++)
+    str_hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);
 
   if (synthetic_too)
-    for (vP = synthetic_votstrs; *vP->vot_name && !retval; vP++)
-      retval = hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);
+    for (vP = synthetic_votstrs; *vP->vot_name; vP++)
+      str_hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);
 
 #ifndef CONST_TABLE
   vip_op_defaults (immediate, indirect, displen);
 #endif
-
-  return retval;
 }
 
 /* Take 3 char.s, the last of which may be `\0` (non-existent)
@@ -1887,7 +1884,7 @@ vip (struct vit *vitP,		/* We build an e
       /* Here with instring pointing to what better be an op-name, and p
          pointing to character just past that.
          We trust instring points to an op-name, with no whitespace.  */
-      vwP = (struct vot_wot *) hash_find (op_hash, instring);
+      vwP = (struct vot_wot *) str_hash_find (op_hash, instring);
       /* Restore char after op-code.  */
       *p = c;
       if (vwP == 0)
@@ -1986,8 +1983,7 @@ main (void)
   printf ("enter displen symbols   eg enter ^   ");
   gets (my_displen);
 
-  if (p = vip_begin (mysynth, my_immediate, my_indirect, my_displen))
-    error ("vip_begin=%s", p);
+  vip_begin (mysynth, my_immediate, my_indirect, my_displen)
 
   printf ("An empty input line will quit you from the vax instruction parser\n");
   for (;;)
@@ -3256,12 +3252,10 @@ md_assemble (char *instruction_string)
 void
 md_begin (void)
 {
-  const char *errtxt;
   FLONUM_TYPE *fP;
   int i;
 
-  if ((errtxt = vip_begin (1, "$", "*", "`")) != 0)
-    as_fatal (_("VIP_BEGIN error:%s"), errtxt);
+  vip_begin (1, "$", "*", "`");
 
   for (i = 0, fP = float_operand;
        fP < float_operand + VIT_MAX_OPERANDS;
diff -rup binutils.orig/gas/config/tc-wasm32.c binutils-2.35/gas/config/tc-wasm32.c
--- binutils.orig/gas/config/tc-wasm32.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-wasm32.c	2021-08-11 17:39:31.417057475 +0100
@@ -92,7 +92,7 @@ const pseudo_typeS md_pseudo_table[] =
 
 /* Opcode hash table.  */
 
-static struct hash_control *wasm32_hash;
+static htab_t wasm32_hash;
 
 struct option md_longopts[] =
 {
@@ -158,13 +158,13 @@ md_begin (void)
 {
   struct wasm32_opcode_s *opcode;
 
-  wasm32_hash = hash_new ();
+  wasm32_hash = str_htab_create ();
 
   /* Insert unique names into hash table.  This hash table then
      provides a quick index to the first opcode with a particular name
      in the opcode table.  */
   for (opcode = wasm32_opcodes; opcode->name; opcode++)
-    hash_insert (wasm32_hash, opcode->name, (char *) opcode);
+    str_hash_insert (wasm32_hash, opcode->name, (char *) opcode);
 
   linkrelax = 0;
   flag_sectname_subst = 1;
@@ -746,7 +746,7 @@ md_assemble (char *str)
   if (!op[0])
     as_bad (_("can't find opcode "));
 
-  opcode = (struct wasm32_opcode_s *) hash_find (wasm32_hash, op);
+  opcode = (struct wasm32_opcode_s *) str_hash_find (wasm32_hash, op);
 
   if (opcode == NULL)
     {
diff -rup binutils.orig/gas/config/tc-xgate.c binutils-2.35/gas/config/tc-xgate.c
--- binutils.orig/gas/config/tc-xgate.c	2021-08-11 17:33:12.213490344 +0100
+++ binutils-2.35/gas/config/tc-xgate.c	2021-08-11 17:39:31.417057475 +0100
@@ -113,7 +113,7 @@ static void xgate_scan_operands (struct
 static unsigned int xgate_parse_operand (struct xgate_opcode *, int *, int,
 					 char **, s_operand);
 
-static struct hash_control *xgate_hash;
+static htab_t xgate_hash;
 
 /* Previous opcode.  */
 static unsigned int prev = 0;
@@ -324,7 +324,7 @@ md_begin (void)
   op_handles = XNEWVEC (struct xgate_opcode_handle, number_of_op_handles);
 
   /* Insert unique opcode names into hash table, aliasing duplicates.  */
-  xgate_hash = hash_new ();
+  xgate_hash = str_htab_create ();
 
   prev_op_name = "";
   for (xgate_opcode_ptr = xgate_op_table, i = 0, j = 0; i < xgate_num_opcodes;
@@ -342,7 +342,7 @@ md_begin (void)
 	    j++;
 	  op_handles[j].name = xgate_opcode_ptr->name;
 	  op_handles[j].opc0[0] = xgate_opcode_ptr;
-	  hash_insert (xgate_hash, (char *) op_handles[j].name,
+	  str_hash_insert (xgate_hash, (char *) op_handles[j].name,
 		       (char *) &(op_handles[j]));
 	}
       op_handles[j].number_of_modes = handle_enum;
@@ -492,7 +492,7 @@ md_assemble (char *input_line)
   if (!op_name[0])
     as_bad (_("opcode missing or not found on input line"));
 
-  if (!(opcode_handle = (struct xgate_opcode_handle *) hash_find (xgate_hash,
+  if (!(opcode_handle = (struct xgate_opcode_handle *) str_hash_find (xgate_hash,
 								  op_name)))
     {
       as_bad (_("opcode %s not found in opcode hash table"), op_name);
@@ -544,7 +544,7 @@ md_assemble (char *input_line)
 	      p = extract_word (p, op_name, 10);
 
 	      if (!(opcode_handle = (struct xgate_opcode_handle *)
-		    hash_find (xgate_hash, op_name)))
+		    str_hash_find (xgate_hash, op_name)))
 		{
 		  as_bad (_(": processing macro, real opcode handle"
 			    " not found in hash"));
diff -rup binutils.orig/gas/config/tc-z8k.c binutils-2.35/gas/config/tc-z8k.c
--- binutils.orig/gas/config/tc-z8k.c	2021-08-11 17:33:12.214490337 +0100
+++ binutils-2.35/gas/config/tc-z8k.c	2021-08-11 17:39:31.417057475 +0100
@@ -137,7 +137,7 @@ const char EXP_CHARS[] = "eE";
 const char FLT_CHARS[] = "rRsSfFdDxXpP";
 
 /* Opcode mnemonics.  */
-static struct hash_control *opcode_hash_control;
+static htab_t opcode_hash_control;
 
 void
 md_begin (void)
@@ -145,13 +145,13 @@ md_begin (void)
   const opcode_entry_type *opcode;
   unsigned int idx = -1u;
 
-  opcode_hash_control = hash_new ();
+  opcode_hash_control = str_htab_create ();
 
   for (opcode = z8k_table; opcode->name; opcode++)
     {
       /* Only enter unique codes into the table.  */
       if (idx != opcode->idx)
-	hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
+	str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
       idx = opcode->idx;
     }
 
@@ -166,7 +166,7 @@ md_begin (void)
       fake_opcode->name = md_pseudo_table[idx].poc_name;
       fake_opcode->func = (void *) (md_pseudo_table + idx);
       fake_opcode->opcode = 250;
-      hash_insert (opcode_hash_control, fake_opcode->name, fake_opcode);
+      str_hash_insert (opcode_hash_control, fake_opcode->name, fake_opcode);
     }
 }
 
@@ -1224,9 +1224,9 @@ md_assemble (char *str)
     }
   c = *op_end;
 
-  *op_end = 0;  /* Zero-terminate op code string for hash_find() call.  */
+  *op_end = 0;  /* Zero-terminate op code string for str_hash_find() call.  */
 
-  opcode = (opcode_entry_type *) hash_find (opcode_hash_control, op_start);
+  opcode = (opcode_entry_type *) str_hash_find (opcode_hash_control, op_start);
 
   if (opcode == NULL)
     {
diff -rup binutils.orig/gas/doc/as.texi binutils-2.35/gas/doc/as.texi
--- binutils.orig/gas/doc/as.texi	2021-08-11 17:33:12.207490382 +0100
+++ binutils-2.35/gas/doc/as.texi	2021-08-11 17:41:32.630279947 +0100
@@ -238,7 +238,6 @@ gcc(1), ld(1), and the Info entries for
  [@b{--listing-cont-lines}=@var{NUM}] [@b{--keep-locals}]
  [@b{--no-pad-sections}]
  [@b{-o} @var{objfile}] [@b{-R}]
- [@b{--hash-size}=@var{NUM}] [@b{--reduce-memory-overheads}]
  [@b{--statistics}]
  [@b{-v}] [@b{-version}] [@b{--version}]
  [@b{-W}] [@b{--warn}] [@b{--fatal-warnings}] [@b{-w}] [@b{-x}]
@@ -875,18 +874,6 @@ Name the object-file output from @comman
 @item -R
 Fold the data section into the text section.
 
-@item --hash-size=@var{number}
-Set the default size of GAS's hash tables to a prime number close to
-@var{number}.  Increasing this value can reduce the length of time it takes the
-assembler to perform its tasks, at the expense of increasing the assembler's
-memory requirements.  Similarly reducing this value can reduce the memory
-requirements at the expense of speed.
-
-@item --reduce-memory-overheads
-This option reduces GAS's memory requirements, at the expense of making the
-assembly processes slower.  Currently this switch is a synonym for
-@samp{--hash-size=4051}, but in the future it may have other effects as well.
-
 @ifset ELF
 @item --sectname-subst
 Honor substitution sequences in section names.
diff -rup binutils.orig/gas/doc/internals.texi binutils-2.35/gas/doc/internals.texi
--- binutils.orig/gas/doc/internals.texi	2021-08-11 17:33:12.206490389 +0100
+++ binutils-2.35/gas/doc/internals.texi	2021-08-11 17:41:32.630279947 +0100
@@ -1915,38 +1915,6 @@ type is narrow enough, a decimal number
 in hexadecimal.  The value itself is not examined to make this determination.
 @end deftypefun
 
-@node Hash tables
-@subsection Hash tables
-@cindex hash tables
-
-@deftypefun @{@} @{struct hash_control *@} hash_new (void)
-Creates the hash table control structure.
-@end deftypefun
-
-@deftypefun @{@} void hash_die (struct hash_control *)
-Destroy a hash table.
-@end deftypefun
-
-@deftypefun @{@} void *hash_delete (struct hash_control *, const char *, int)
-Deletes entry from the hash table, returns the value it had.  If the last
-arg is non-zero, free memory allocated for this entry and all entries
-allocated more recently than this entry.
-@end deftypefun
-
-@deftypefun @{@} void *hash_replace (struct hash_control *, const char *, void *)
-Updates the value for an entry already in the table, returning the old value.
-If no entry was found, just returns NULL.
-@end deftypefun
-
-@deftypefun @{@} @{const char *@} hash_insert (struct hash_control *, const char *, void *)
-Inserting a value already in the table is an error.
-Returns an error message or NULL.
-@end deftypefun
-
-@deftypefun @{@} @{const char *@} hash_jam (struct hash_control *, const char *, void *)
-Inserts if the value isn't already present, updates it if it is.
-@end deftypefun
-
 @node Test suite
 @section Test suite
 @cindex test suite
diff -rup binutils.orig/gas/dw2gencfi.c binutils-2.35/gas/dw2gencfi.c
--- binutils.orig/gas/dw2gencfi.c	2021-08-11 17:33:12.205490395 +0100
+++ binutils-2.35/gas/dw2gencfi.c	2021-08-11 17:39:16.182155202 +0100
@@ -115,7 +115,7 @@ static bfd_boolean compact_eh;
 #define compact_eh 0
 #endif
 
-static struct hash_control *dwcfi_hash;
+static htab_t dwcfi_hash;
 
 /* Emit a single byte into the current segment.  */
 
@@ -325,20 +325,10 @@ make_debug_seg (segT cseg, char *name, i
   return r;
 }
 
-static void
-dwcfi_hash_insert (const char *name, struct dwcfi_seg_list *item)
-{
-  const char *error_string;
-
-  if ((error_string = hash_jam (dwcfi_hash, name, (char *) item)))
-    as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
-	      name, error_string);
-}
-
 static struct dwcfi_seg_list *
 dwcfi_hash_find (char *name)
 {
-  return (struct dwcfi_seg_list *) hash_find (dwcfi_hash, name);
+  return (struct dwcfi_seg_list *) str_hash_find (dwcfi_hash, name);
 }
 
 static struct dwcfi_seg_list *
@@ -349,7 +339,7 @@ dwcfi_hash_find_or_make (segT cseg, cons
 
   /* Initialize dwcfi_hash once.  */
   if (!dwcfi_hash)
-    dwcfi_hash = hash_new ();
+    dwcfi_hash = str_htab_create ();
 
   name = get_debugseg_name (cseg, base_name);
 
@@ -358,7 +348,7 @@ dwcfi_hash_find_or_make (segT cseg, cons
     {
       item = alloc_debugseg_item (make_debug_seg (cseg, name, flags), 0, name);
 
-      dwcfi_hash_insert (item->seg_name, item);
+      str_hash_insert (dwcfi_hash, item->seg_name, (char *) item);
     }
   else
     free (name);
diff -rup binutils.orig/gas/ecoff.c binutils-2.35/gas/ecoff.c
--- binutils.orig/gas/ecoff.c	2021-08-11 17:33:12.203490408 +0100
+++ binutils-2.35/gas/ecoff.c	2021-08-11 17:39:23.430108707 +0100
@@ -946,7 +946,7 @@ typedef struct efdr {
   varray_t	 aux_syms;	/* auxiliary symbols */
   struct efdr	*next_file;	/* next file descriptor */
 				/* string/type hash tables */
-  struct hash_control *str_hash;	/* string hash table */
+  htab_t	str_hash;	/* string hash table */
   thash_t	*thash_head[THASH_SIZE];
 } efdr_t;
 
@@ -994,7 +994,7 @@ static const efdr_t init_file = {
 
   (struct efdr *)0,	/* next_file:	next file structure */
 
-  (struct hash_control *)0,	/* str_hash:	string hash table */
+  (htab_t)0,		/* str_hash:	string hash table */
   { 0 },		/* thash_head:	type hash table */
 };
 
@@ -1111,7 +1111,7 @@ static const type_info_t type_info_init
 
 static varray_t file_desc = INIT_VARRAY (efdr_t);
 
-static struct hash_control *tag_hash;
+static htab_t tag_hash;
 
 /* Static types for int and void.  Also, remember the last function's
    type (which is set up when we encounter the declaration for the
@@ -1408,7 +1408,7 @@ static char stabs_symbol[] = STABS_SYMBO
 
 static void add_varray_page (varray_t *vp);
 static symint_t add_string (varray_t *vp,
-			    struct hash_control *hash_tbl,
+			    htab_t hash_tbl,
 			    const char *str,
 			    shash_t **ret_hash);
 static localsym_t *add_ecoff_symbol (const char *str, st_t type,
@@ -1475,7 +1475,7 @@ static lineno_list_t *allocate_lineno_li
 void
 ecoff_read_begin_hook (void)
 {
-  tag_hash = hash_new ();
+  tag_hash = str_htab_create ();
   top_tag_head = allocate_thead ();
   top_tag_head->first_tag = (tag_t *) NULL;
   top_tag_head->free = (thead_t *) NULL;
@@ -1548,7 +1548,7 @@ add_varray_page (varray_t *vp /* varray
 
 static symint_t
 add_string (varray_t *vp,			/* string obstack */
-	    struct hash_control *hash_tbl,	/* ptr to hash table */
+	    htab_t hash_tbl,			/* ptr to hash table */
 	    const char *str,			/* string */
 	    shash_t **ret_hash			/* return hash pointer */)
 {
@@ -1558,11 +1558,9 @@ add_string (varray_t *vp,			/* string ob
   if (len >= PAGE_USIZE)
     as_fatal (_("string too big (%lu bytes)"), len);
 
-  hash_ptr = (shash_t *) hash_find (hash_tbl, str);
+  hash_ptr = (shash_t *) str_hash_find (hash_tbl, str);
   if (hash_ptr == (shash_t *) NULL)
     {
-      const char *err;
-
       if (vp->objects_last_page + len >= PAGE_USIZE)
 	{
 	  vp->num_allocated =
@@ -1580,10 +1578,7 @@ add_string (varray_t *vp,			/* string ob
 
       strcpy (hash_ptr->string, str);
 
-      err = hash_insert (hash_tbl, str, (char *) hash_ptr);
-      if (err)
-	as_fatal (_("inserting \"%s\" into string hash table: %s"),
-		  str, err);
+      str_hash_insert (hash_tbl, str, (char *) hash_ptr);
     }
 
   if (ret_hash != (shash_t **) NULL)
@@ -2009,13 +2004,12 @@ get_tag (const char *tag,	/* tag name */
 	 bt_t basic_type	/* bt_Struct, bt_Union, or bt_Enum */)
 {
   shash_t *hash_ptr;
-  const char *err;
   tag_t *tag_ptr;
 
   if (cur_file_ptr == (efdr_t *) NULL)
     as_fatal (_("no current file pointer"));
 
-  hash_ptr = (shash_t *) hash_find (tag_hash, tag);
+  hash_ptr = (shash_t *) str_hash_find (tag_hash, tag);
 
   if (hash_ptr != (shash_t *) NULL
       && hash_ptr->tag_ptr != (tag_t *) NULL)
@@ -2036,10 +2030,7 @@ get_tag (const char *tag,	/* tag name */
 
       perm = xstrdup (tag);
       hash_ptr = allocate_shash ();
-      err = hash_insert (tag_hash, perm, (char *) hash_ptr);
-      if (err)
-	as_fatal (_("inserting \"%s\" into tag hash table: %s"),
-		  tag, err);
+      str_hash_insert (tag_hash, perm, (char *) hash_ptr);
       hash_ptr->string = perm;
     }
 
@@ -2281,7 +2272,7 @@ add_file (const char *file_name, int ind
       fil_ptr->fake = fake;
 
       /* Allocate the string hash table.  */
-      fil_ptr->str_hash = hash_new ();
+      fil_ptr->str_hash = str_htab_create ();
 
       /* Make sure 0 byte in string table is null  */
       add_string (&fil_ptr->strings,
diff -rup binutils.orig/gas/hash.c binutils-2.35/gas/hash.c
--- binutils.orig/gas/hash.c	2021-08-11 17:33:12.485488589 +0100
+++ binutils-2.35/gas/hash.c	2021-08-11 17:47:12.479099992 +0100
@@ -18,578 +18,28 @@
    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
    02110-1301, USA.  */
 
-/* This version of the hash table code is a wholescale replacement of
-   the old hash table code, which was fairly bad.  This is based on
-   the hash table code in BFD, but optimized slightly for the
-   assembler.  The assembler does not need to derive structures that
-   are stored in the hash table.  Instead, it always stores a pointer.
-   The assembler uses the hash table mostly to store symbols, and we
-   don't need to confuse the symbol structure with a hash table
-   structure.  */
-
 #include "as.h"
-#include "safe-ctype.h"
-#include "obstack.h"
-
-/* An entry in a hash table.  */
-
-struct hash_entry {
-  /* Next entry for this hash code.  */
-  struct hash_entry *next;
-  /* String being hashed.  */
-  const char *string;
-  /* Hash code.  This is the full hash code, not the index into the
-     table.  */
-  unsigned long hash;
-  /* Pointer being stored in the hash table.  */
-  void *data;
-};
-
-/* A hash table.  */
-
-struct hash_control {
-  /* The hash array.  */
-  struct hash_entry **table;
-  /* The number of slots in the hash table.  */
-  unsigned int size;
-  /* An obstack for this hash table.  */
-  struct obstack memory;
-
-#ifdef HASH_STATISTICS
-  /* Statistics.  */
-  unsigned long lookups;
-  unsigned long hash_compares;
-  unsigned long string_compares;
-  unsigned long insertions;
-  unsigned long replacements;
-  unsigned long deletions;
-#endif /* HASH_STATISTICS */
-};
-
-/* The default number of entries to use when creating a hash table.
-   Note this value can be reduced to 4051 by using the command line
-   switch --reduce-memory-overheads, or set to other values by using
-   the --hash-size=<NUMBER> switch.  */
-
-static unsigned long gas_hash_table_size = 65537;
-
-void
-set_gas_hash_table_size (unsigned long size)
-{
-  gas_hash_table_size = bfd_hash_set_default_size (size);
-}
-
-/* Create a hash table.  This return a control block.  */
-
-struct hash_control *
-hash_new_sized (unsigned long size)
-{
-  unsigned long alloc;
-  struct hash_control *ret;
-
-  ret = XNEW (struct hash_control);
-  obstack_begin (&ret->memory, chunksize);
-  alloc = size * sizeof (struct hash_entry *);
-  ret->table = (struct hash_entry **) obstack_alloc (&ret->memory, alloc);
-  memset (ret->table, 0, alloc);
-  ret->size = size;
-
-#ifdef HASH_STATISTICS
-  ret->lookups = 0;
-  ret->hash_compares = 0;
-  ret->string_compares = 0;
-  ret->insertions = 0;
-  ret->replacements = 0;
-  ret->deletions = 0;
-#endif
-
-  return ret;
-}
-
-struct hash_control *
-hash_new (void)
-{
-  return hash_new_sized (gas_hash_table_size);
-}
-
-/* Delete a hash table, freeing all allocated memory.  */
-
-void
-hash_die (struct hash_control *table)
-{
-  obstack_free (&table->memory, 0);
-  free (table);
-}
-
-/* Look up a string in a hash table.  This returns a pointer to the
-   hash_entry, or NULL if the string is not in the table.  If PLIST is
-   not NULL, this sets *PLIST to point to the start of the list which
-   would hold this hash entry.  If PHASH is not NULL, this sets *PHASH
-   to the hash code for KEY.
-
-   Each time we look up a string, we move it to the start of the list
-   for its hash code, to take advantage of referential locality.  */
-
-static struct hash_entry *
-hash_lookup (struct hash_control *table, const char *key, size_t len,
-	     struct hash_entry ***plist, unsigned long *phash)
-{
-  unsigned long hash;
-  size_t n;
-  unsigned int c;
-  unsigned int hindex;
-  struct hash_entry **list;
-  struct hash_entry *p;
-  struct hash_entry *prev;
-
-#ifdef HASH_STATISTICS
-  ++table->lookups;
-#endif
-
-  hash = 0;
-  for (n = 0; n < len; n++)
-    {
-      c = key[n];
-      hash += c + (c << 17);
-      hash ^= hash >> 2;
-    }
-  hash += len + (len << 17);
-  hash ^= hash >> 2;
-
-  if (phash != NULL)
-    *phash = hash;
-
-  hindex = hash % table->size;
-  list = table->table + hindex;
-
-  if (plist != NULL)
-    *plist = list;
-
-  prev = NULL;
-  for (p = *list; p != NULL; p = p->next)
-    {
-#ifdef HASH_STATISTICS
-      ++table->hash_compares;
-#endif
-
-      if (p->hash == hash)
-	{
-#ifdef HASH_STATISTICS
-	  ++table->string_compares;
-#endif
-
-	  if (strncmp (p->string, key, len) == 0 && p->string[len] == '\0')
-	    {
-	      if (prev != NULL)
-		{
-		  prev->next = p->next;
-		  p->next = *list;
-		  *list = p;
-		}
-
-	      return p;
-	    }
-	}
-
-      prev = p;
-    }
-
-  return NULL;
-}
-
-/* Insert an entry into a hash table.  This returns NULL on success.
-   On error, it returns a printable string indicating the error.  It
-   is considered to be an error if the entry already exists in the
-   hash table.  */
-
-const char *
-hash_insert (struct hash_control *table, const char *key, void *val)
-{
-  struct hash_entry *p;
-  struct hash_entry **list;
-  unsigned long hash;
-
-  p = hash_lookup (table, key, strlen (key), &list, &hash);
-  if (p != NULL)
-    return "exists";
-
-#ifdef HASH_STATISTICS
-  ++table->insertions;
-#endif
-
-  p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
-  p->string = key;
-  p->hash = hash;
-  p->data = val;
-
-  p->next = *list;
-  *list = p;
-
-  return NULL;
-}
-
-/* Insert or replace an entry in a hash table.  This returns NULL on
-   success.  On error, it returns a printable string indicating the
-   error.  If an entry already exists, its value is replaced.  */
-
-const char *
-hash_jam (struct hash_control *table, const char *key, void *val)
-{
-  struct hash_entry *p;
-  struct hash_entry **list;
-  unsigned long hash;
-
-  p = hash_lookup (table, key, strlen (key), &list, &hash);
-  if (p != NULL)
-    {
-#ifdef HASH_STATISTICS
-      ++table->replacements;
-#endif
-
-      p->data = val;
-    }
-  else
-    {
-#ifdef HASH_STATISTICS
-      ++table->insertions;
-#endif
-
-      p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
-      p->string = key;
-      p->hash = hash;
-      p->data = val;
-
-      p->next = *list;
-      *list = p;
-    }
-
-  return NULL;
-}
-
-/* Replace an existing entry in a hash table.  This returns the old
-   value stored for the entry.  If the entry is not found in the hash
-   table, this does nothing and returns NULL.  */
-
-void *
-hash_replace (struct hash_control *table, const char *key, void *value)
-{
-  struct hash_entry *p;
-  void *ret;
-
-  p = hash_lookup (table, key, strlen (key), NULL, NULL);
-  if (p == NULL)
-    return NULL;
-
-#ifdef HASH_STATISTICS
-  ++table->replacements;
-#endif
-
-  ret = p->data;
-
-  p->data = value;
-
-  return ret;
-}
-
-/* Find an entry in a hash table, returning its value.  Returns NULL
-   if the entry is not found.  */
-
-void *
-hash_find (struct hash_control *table, const char *key)
-{
-  struct hash_entry *p;
-
-  p = hash_lookup (table, key, strlen (key), NULL, NULL);
-  if (p == NULL)
-    return NULL;
-
-  return p->data;
-}
-
-/* As hash_find, but KEY is of length LEN and is not guaranteed to be
-   NUL-terminated.  */
-
-void *
-hash_find_n (struct hash_control *table, const char *key, size_t len)
-{
-  struct hash_entry *p;
 
-  p = hash_lookup (table, key, len, NULL, NULL);
-  if (p == NULL)
-    return NULL;
-
-  return p->data;
-}
-
-/* Delete an entry from a hash table.  This returns the value stored
-   for that entry, or NULL if there is no such entry.  */
-
-void *
-hash_delete (struct hash_control *table, const char *key, int freeme)
-{
-  struct hash_entry *p;
-  struct hash_entry **list;
-
-  p = hash_lookup (table, key, strlen (key), &list, NULL);
-  if (p == NULL)
-    return NULL;
-
-  if (p != *list)
-    abort ();
-
-#ifdef HASH_STATISTICS
-  ++table->deletions;
-#endif
-
-  *list = p->next;
-
-  if (freeme)
-    obstack_free (&table->memory, p);
-
-  return p->data;
-}
-
-/* Traverse a hash table.  Call the function on every entry in the
-   hash table.  */
+/* Insert ELEMENT into HTAB.  If the element exists, it is overwritten.  */
 
 void
-hash_traverse (struct hash_control *table,
-	       void (*pfn) (const char *key, void *value))
+htab_insert (htab_t htab, PTR element)
 {
-  unsigned int i;
-
-  for (i = 0; i < table->size; ++i)
-    {
-      struct hash_entry *p;
+  void **slot = htab_find_slot (htab, element, INSERT);
+  if (slot != NULL && htab->del_f)
+    (*htab->del_f) (*slot);
 
-      for (p = table->table[i]; p != NULL; p = p->next)
-	(*pfn) (p->string, p->data);
-    }
+  *slot = element;
 }
 
-/* Print hash table statistics on the specified file.  NAME is the
-   name of the hash table, used for printing a header.  */
+/* Print statistics about a hash table.  */
 
 void
-hash_print_statistics (FILE *f ATTRIBUTE_UNUSED,
-		       const char *name ATTRIBUTE_UNUSED,
-		       struct hash_control *table ATTRIBUTE_UNUSED)
+htab_print_statistics (FILE *f, const char *name, htab_t table)
 {
-#ifdef HASH_STATISTICS
-  unsigned int i;
-  unsigned long total;
-  unsigned long empty;
-
   fprintf (f, "%s hash statistics:\n", name);
-  fprintf (f, "\t%lu lookups\n", table->lookups);
-  fprintf (f, "\t%lu hash comparisons\n", table->hash_compares);
-  fprintf (f, "\t%lu string comparisons\n", table->string_compares);
-  fprintf (f, "\t%lu insertions\n", table->insertions);
-  fprintf (f, "\t%lu replacements\n", table->replacements);
-  fprintf (f, "\t%lu deletions\n", table->deletions);
-
-  total = 0;
-  empty = 0;
-  for (i = 0; i < table->size; ++i)
-    {
-      struct hash_entry *p;
-
-      if (table->table[i] == NULL)
-	++empty;
-      else
-	{
-	  for (p = table->table[i]; p != NULL; p = p->next)
-	    ++total;
-	}
-    }
-
-  fprintf (f, "\t%g average chain length\n", (double) total / table->size);
-  fprintf (f, "\t%lu empty slots\n", empty);
-#endif
-}
-
-#ifdef TEST
-
-/* This test program is left over from the old hash table code.  */
-
-/* Number of hash tables to maintain (at once) in any testing.  */
-#define TABLES (6)
-
-/* We can have 12 statistics.  */
-#define STATBUFSIZE (12)
-
-/* Display statistics here.  */
-int statbuf[STATBUFSIZE];
-
-/* Human farts here.  */
-char answer[100];
-
-/* We test many hash tables at once.  */
-char *hashtable[TABLES];
-
-/* Points to current hash_control.  */
-char *h;
-char **pp;
-char *p;
-char *name;
-char *value;
-int size;
-int used;
-char command;
-
-/* Number 0:TABLES-1 of current hashed symbol table.  */
-int number;
-
-int
-main ()
-{
-  void applicatee ();
-  void destroy ();
-  char *what ();
-  int *ip;
-
-  number = 0;
-  h = 0;
-  printf ("type h <RETURN> for help\n");
-  for (;;)
-    {
-      printf ("hash_test command: ");
-      gets (answer);
-      command = answer[0];
-      command = TOLOWER (command);	/* Ecch!  */
-      switch (command)
-	{
-	case '#':
-	  printf ("old hash table #=%d.\n", number);
-	  whattable ();
-	  break;
-	case '?':
-	  for (pp = hashtable; pp < hashtable + TABLES; pp++)
-	    {
-	      printf ("address of hash table #%d control block is %xx\n",
-		      pp - hashtable, *pp);
-	    }
-	  break;
-	case 'a':
-	  hash_traverse (h, applicatee);
-	  break;
-	case 'd':
-	  hash_traverse (h, destroy);
-	  hash_die (h);
-	  break;
-	case 'f':
-	  p = hash_find (h, name = what ("symbol"));
-	  printf ("value of \"%s\" is \"%s\"\n", name, p ? p : "NOT-PRESENT");
-	  break;
-	case 'h':
-	  printf ("# show old, select new default hash table number\n");
-	  printf ("? display all hashtable control block addresses\n");
-	  printf ("a apply a simple display-er to each symbol in table\n");
-	  printf ("d die: destroy hashtable\n");
-	  printf ("f find value of nominated symbol\n");
-	  printf ("h this help\n");
-	  printf ("i insert value into symbol\n");
-	  printf ("j jam value into symbol\n");
-	  printf ("n new hashtable\n");
-	  printf ("r replace a value with another\n");
-	  printf ("s say what %% of table is used\n");
-	  printf ("q exit this program\n");
-	  printf ("x delete a symbol from table, report its value\n");
-	  break;
-	case 'i':
-	  p = hash_insert (h, name = what ("symbol"), value = what ("value"));
-	  if (p)
-	    {
-	      printf ("symbol=\"%s\"  value=\"%s\"  error=%s\n", name, value,
-		      p);
-	    }
-	  break;
-	case 'j':
-	  p = hash_jam (h, name = what ("symbol"), value = what ("value"));
-	  if (p)
-	    {
-	      printf ("symbol=\"%s\"  value=\"%s\"  error=%s\n", name, value, p);
-	    }
-	  break;
-	case 'n':
-	  h = hashtable[number] = (char *) hash_new ();
-	  break;
-	case 'q':
-	  exit (EXIT_SUCCESS);
-	case 'r':
-	  p = hash_replace (h, name = what ("symbol"), value = what ("value"));
-	  printf ("old value was \"%s\"\n", p ? p : "{}");
-	  break;
-	case 's':
-	  hash_say (h, statbuf, STATBUFSIZE);
-	  for (ip = statbuf; ip < statbuf + STATBUFSIZE; ip++)
-	    {
-	      printf ("%d ", *ip);
-	    }
-	  printf ("\n");
-	  break;
-	case 'x':
-	  p = hash_delete (h, name = what ("symbol"));
-	  printf ("old value was \"%s\"\n", p ? p : "{}");
-	  break;
-	default:
-	  printf ("I can't understand command \"%c\"\n", command);
-	  break;
-	}
-    }
+  fprintf (f, "\t%u searches\n", table->searches);
+  fprintf (f, "\t%u collisions\n", table->collisions);
+  fprintf (f, "\t%lu elements\n", (unsigned long) htab_elements (table));
+  fprintf (f, "\t%lu table size\n", (unsigned long) htab_size (table));
 }
-
-char *
-what (description)
-     char *description;
-{
-  printf ("   %s : ", description);
-  gets (answer);
-  return xstrdup (answer);
-}
-
-void
-destroy (string, value)
-     char *string;
-     char *value;
-{
-  free (string);
-  free (value);
-}
-
-void
-applicatee (string, value)
-     char *string;
-     char *value;
-{
-  printf ("%.20s-%.20s\n", string, value);
-}
-
-/* Determine number: what hash table to use.
-   Also determine h: points to hash_control.  */
-
-void
-whattable ()
-{
-  for (;;)
-    {
-      printf ("   what hash table (%d:%d) ?  ", 0, TABLES - 1);
-      gets (answer);
-      sscanf (answer, "%d", &number);
-      if (number >= 0 && number < TABLES)
-	{
-	  h = hashtable[number];
-	  if (!h)
-	    {
-	      printf ("warning: current hash-table-#%d. has no hash-control\n", number);
-	    }
-	  return;
-	}
-      else
-	{
-	  printf ("invalid hash table number: %d\n", number);
-	}
-    }
-}
-
-#endif /* TEST */
Only in binutils-2.35/gas: hash.c.orig
Only in binutils-2.35/gas: hash.c.rej
diff -rup binutils.orig/gas/hash.h binutils-2.35/gas/hash.h
--- binutils.orig/gas/hash.h	2021-08-11 17:33:12.203490408 +0100
+++ binutils-2.35/gas/hash.h	2021-08-11 17:50:49.581707254 +0100
@@ -21,68 +21,101 @@
 #ifndef HASH_H
 #define HASH_H
 
-struct hash_control;
+/* Insert ELEMENT into HTAB.  If REPLACE is non-zero existing elements
+   are overwritten.  If ELEMENT already exists, a pointer to the slot
+   is returned.  Otherwise NULL is returned.  */
+
+extern void htab_insert (htab_t, void * /* element */);
+
+/* Print statistics about a hash table.  */
+
+extern void htab_print_statistics (FILE *f, const char *name, htab_t table);
+
+/* String hash table functions.  */
+
+struct string_tuple
+{
+  const char *key;
+  char *value;
+};
+
+typedef struct string_tuple string_tuple_t;
+
+/* Hash function for a string_tuple.  */
+
+static hashval_t
+hash_string_tuple (const void *e)
+{
+  string_tuple_t *tuple = (string_tuple_t *) e;
+  return htab_hash_string (tuple->key);
+}
+
+/* Equality function for a string_tuple.  */
+
+static int
+eq_string_tuple (const void *a, const void *b)
+{
+  const string_tuple_t *ea = (const string_tuple_t *) a;
+  const string_tuple_t *eb = (const string_tuple_t *) b;
+
+  return strcmp (ea->key, eb->key) == 0;
+}
+
+static inline string_tuple_t *
+string_tuple_alloc (const char *key, char *value)
+{
+  string_tuple_t *tuple = XNEW (string_tuple_t);
+  tuple->key = key;
+  tuple->value = value;
+  return tuple;
+}
+
+static inline void *
+str_hash_find (htab_t table, const char *key)
+{
+  string_tuple_t needle = { key, NULL };
+  string_tuple_t *tuple = htab_find (table, &needle);
+  return tuple != NULL ? tuple->value : NULL;
+}
+
+static inline void *
+str_hash_find_n (htab_t table, const char *key, size_t n)
+{
+  char *tmp = XNEWVEC (char, n + 1);
+  memcpy (tmp, key, n);
+  tmp[n] = '\0';
+  string_tuple_t needle = { tmp, NULL };
+  string_tuple_t *tuple = htab_find (table, &needle);
+  free (tmp);
+  return tuple != NULL ? tuple->value : NULL;
+}
+
+static inline void
+str_hash_delete (htab_t table, const char *key)
+{
+  string_tuple_t needle = { key, NULL };
+  htab_remove_elt (table, &needle);
+}
+
+static inline void
+str_hash_insert (htab_t table, const char *key, void *value)
+{
+  htab_insert (table, string_tuple_alloc (key, value));
+}
+
+static inline htab_t
+str_htab_create (void)
+{
+  return htab_create_alloc (16, hash_string_tuple, eq_string_tuple,
+			    NULL, xcalloc, free);
+}
 
-/* Set the size of the hash table used.  */
+/* Insert ELEMENT into HTAB.  If the element exists, it is overwritten.  */
 
-void set_gas_hash_table_size (unsigned long);
+extern void htab_insert (htab_t, void *);
 
-/* Create a hash table.  This return a control block.  */
+/* Print statistics about a hash table.  */
 
-extern struct hash_control *hash_new (void);
-extern struct hash_control *hash_new_sized (unsigned long);
-
-/* Delete a hash table, freeing all allocated memory.  */
-
-extern void hash_die (struct hash_control *);
-
-/* Insert an entry into a hash table.  This returns NULL on success.
-   On error, it returns a printable string indicating the error.  It
-   is considered to be an error if the entry already exists in the
-   hash table.  */
-
-extern const char *hash_insert (struct hash_control *,
-				const char *key, void *value);
-
-/* Insert or replace an entry in a hash table.  This returns NULL on
-   success.  On error, it returns a printable string indicating the
-   error.  If an entry already exists, its value is replaced.  */
-
-extern const char *hash_jam (struct hash_control *,
-			     const char *key, void *value);
-
-/* Replace an existing entry in a hash table.  This returns the old
-   value stored for the entry.  If the entry is not found in the hash
-   table, this does nothing and returns NULL.  */
-
-extern void *hash_replace (struct hash_control *, const char *key,
-			 void *value);
-
-/* Find an entry in a hash table, returning its value.  Returns NULL
-   if the entry is not found.  */
-
-extern void *hash_find (struct hash_control *, const char *key);
-
-/* As hash_find, but KEY is of length LEN and is not guaranteed to be
-   NUL-terminated.  */
-
-extern void *hash_find_n (struct hash_control *, const char *key, size_t len);
-
-/* Delete an entry from a hash table.  This returns the value stored
-   for that entry, or NULL if there is no such entry.  */
-
-extern void *hash_delete (struct hash_control *, const char *key, int);
-
-/* Traverse a hash table.  Call the function on every entry in the
-   hash table.  */
-
-extern void hash_traverse (struct hash_control *,
-			   void (*pfn) (const char *key, void *value));
-
-/* Print hash table statistics on the specified file.  NAME is the
-   name of the hash table, used for printing a header.  */
-
-extern void hash_print_statistics (FILE *, const char *name,
-				   struct hash_control *);
+extern void htab_print_statistics (FILE *f, const char *name, htab_t table);
 
 #endif /* HASH_H */
Only in binutils-2.35/gas: hash.h.orig
Only in binutils-2.35/gas: hash.h.rej
diff -rup binutils.orig/gas/macro.c binutils-2.35/gas/macro.c
--- binutils.orig/gas/macro.c	2021-08-11 17:33:12.204490402 +0100
+++ binutils-2.35/gas/macro.c	2021-08-11 17:43:57.989347554 +0100
@@ -44,7 +44,7 @@
 
 /* The macro hash table.  */
 
-struct hash_control *macro_hash;
+struct htab *macro_hash;
 
 /* Whether any macros have been defined.  */
 
@@ -76,7 +76,8 @@ void
 macro_init (int alternate, int mri, int strip_at,
 	    size_t (*exp) (const char *, size_t, sb *, offsetT *))
 {
-  macro_hash = hash_new ();
+  macro_hash = htab_create_alloc (16, hash_macro_entry, eq_macro_entry,
+				  NULL, xcalloc, free);
   macro_defined = 0;
   macro_alternate = alternate;
   macro_mri = mri;
@@ -566,8 +567,8 @@ do_formals (macro_entry *macro, size_t i
 	}
 
       /* Add to macro's hash table.  */
-      if (! hash_find (macro->formal_hash, name))
-	hash_jam (macro->formal_hash, name, formal);
+      if (formal_entry_find (macro->formal_hash, name) == NULL)
+	htab_insert (macro->formal_hash, formal_entry_alloc (name, formal));
       else
 	as_bad_where (macro->file,
 		      macro->line,
@@ -605,13 +606,13 @@ do_formals (macro_entry *macro, size_t i
       sb_add_string (&formal->name, name);
 
       /* Add to macro's hash table.  */
-      if (hash_find (macro->formal_hash, name))
+      if (formal_entry_find (macro->formal_hash, name))
 	as_bad_where (macro->file,
 		      macro->line,
 		      _("Reserved word `%s' used as parameter in macro `%s'"),
 		      name,
 		      macro->name);
-      hash_jam (macro->formal_hash, name, formal);
+      htab_insert (macro->formal_hash, formal_entry_alloc (name, formal));
 
       formal->index = NARG_INDEX;
       *p = formal;
@@ -635,7 +636,7 @@ free_macro (macro_entry *macro)
       formal = formal->next;
       del_formal (f);
     }
-  hash_die (macro->formal_hash);
+  htab_delete (macro->formal_hash);
   sb_kill (&macro->sub);
   free (macro);
 }
@@ -662,7 +663,8 @@ define_macro (size_t idx, sb *in, sb *la
 
   macro->formal_count = 0;
   macro->formals = 0;
-  macro->formal_hash = hash_new_sized (7);
+  macro->formal_hash = htab_create_alloc (7, hash_formal_entry, eq_formal_entry,
+					  NULL, xcalloc, free);
 
   idx = sb_skip_white (idx, in);
   if (! buffer_and_nest ("MACRO", "ENDM", &macro->sub, get_line))
@@ -707,10 +709,10 @@ define_macro (size_t idx, sb *in, sb *la
   /* And stick it in the macro hash table.  */
   for (idx = 0; idx < name.len; idx++)
     name.ptr[idx] = TOLOWER (name.ptr[idx]);
-  if (hash_find (macro_hash, macro->name))
+  if (macro_entry_find (macro_hash, macro->name))
     error = _("Macro `%s' was already defined");
   if (!error)
-    error = hash_jam (macro_hash, macro->name, (void *) macro);
+    htab_insert (macro_hash, macro_entry_alloc (macro->name, macro));
 
   if (namep != NULL)
     *namep = macro->name;
@@ -740,7 +742,7 @@ get_apost_token (size_t idx, sb *in, sb
 /* Substitute the actual value for a formal parameter.  */
 
 static size_t
-sub_actual (size_t start, sb *in, sb *t, struct hash_control *formal_hash,
+sub_actual (size_t start, sb *in, sb *t, struct htab *formal_hash,
 	    int kind, sb *out, int copyifnotthere)
 {
   size_t src;
@@ -754,7 +756,7 @@ sub_actual (size_t start, sb *in, sb *t,
       && (src == start || in->ptr[src - 1] != '@'))
     ptr = NULL;
   else
-    ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (t));
+    ptr = formal_entry_find (formal_hash, sb_terminate (t));
   if (ptr)
     {
       if (ptr->actual.len)
@@ -790,7 +792,7 @@ sub_actual (size_t start, sb *in, sb *t,
 
 static const char *
 macro_expand_body (sb *in, sb *out, formal_entry *formals,
-		   struct hash_control *formal_hash, const macro_entry *macro)
+		   struct htab *formal_hash, const macro_entry *macro)
 {
   sb t;
   size_t src = 0;
@@ -912,7 +914,7 @@ macro_expand_body (sb *in, sb *out, form
 
 		  src = get_token (src, in, &f->name);
 		  name = sb_terminate (&f->name);
-		  if (! hash_find (formal_hash, name))
+		  if (formal_entry_find (formal_hash, name) == NULL)
 		    {
 		      static int loccnt;
 		      char buf[20];
@@ -924,9 +926,7 @@ macro_expand_body (sb *in, sb *out, form
 		      sprintf (buf, IS_ELF ? ".LL%04x" : "LL%04x", ++loccnt);
 		      sb_add_string (&f->actual, buf);
 
-		      err = hash_jam (formal_hash, name, f);
-		      if (err != NULL)
-			break;
+		      htab_insert (formal_hash, formal_entry_alloc (name, f));
 		    }
 		  else
 		    {
@@ -966,7 +966,7 @@ macro_expand_body (sb *in, sb *out, form
 
 	  sb_reset (&t);
 	  src = get_token (src + 2, in, &t);
-	  ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (&t));
+	  ptr = formal_entry_find (formal_hash, sb_terminate (&t));
 	  if (ptr == NULL)
 	    {
 	      /* FIXME: We should really return a warning string here,
@@ -1010,7 +1010,8 @@ macro_expand_body (sb *in, sb *out, form
 
       f = loclist->next;
       name = sb_terminate (&loclist->name);
-      hash_delete (formal_hash, name, f == NULL);
+      formal_hash_entry_t needle = { name, NULL };
+      htab_remove_elt (formal_hash, &needle);
       del_formal (loclist);
       loclist = f;
     }
@@ -1095,7 +1096,7 @@ macro_expand (size_t idx, sb *in, macro_
 	    }
 
 	  /* Lookup the formal in the macro's list.  */
-	  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
+	  ptr = formal_entry_find (m->formal_hash, sb_terminate (&t));
 	  if (!ptr)
 	    {
 	      as_bad (_("Parameter named `%s' does not exist for macro `%s'"),
@@ -1193,7 +1194,7 @@ macro_expand (size_t idx, sb *in, macro_
 
 	  sb_reset (&t);
 	  sb_add_string (&t, macro_strip_at ? "$NARG" : "NARG");
-	  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
+	  ptr = formal_entry_find (m->formal_hash, sb_terminate (&t));
 	  sprintf (buffer, "%d", narg);
 	  sb_add_string (&ptr->actual, buffer);
 	}
@@ -1253,7 +1254,7 @@ check_macro (const char *line, sb *expan
   for (cls = copy; *cls != '\0'; cls ++)
     *cls = TOLOWER (*cls);
 
-  macro = (macro_entry *) hash_find (macro_hash, copy);
+  macro = macro_entry_find (macro_hash, copy);
   free (copy);
 
   if (macro == NULL)
@@ -1294,14 +1295,14 @@ delete_macro (const char *name)
   /* We can only ask hash_delete to free memory if we are deleting
      macros in reverse order to their definition.
      So just clear out the entry.  */
-  if ((macro = (macro_entry *) hash_find (macro_hash, copy)) != NULL)
+  macro = macro_entry_find (macro_hash, copy);
+  if (macro)
     {
-      hash_jam (macro_hash, copy, NULL);
+      htab_insert (macro_hash, macro_entry_alloc (copy, NULL));
       free_macro (macro);
     }
   else
     as_warn (_("Attempt to purge non-existing macro `%s'"), copy);
-  free (copy);
 }
 
 /* Handle the MRI IRP and IRPC pseudo-ops.  These are handled as a
@@ -1313,8 +1314,8 @@ expand_irp (int irpc, size_t idx, sb *in
 {
   sb sub;
   formal_entry f;
-  struct hash_control *h;
-  const char *err;
+  struct htab *h;
+  const char *err = NULL;
 
   idx = sb_skip_white (idx, in);
 
@@ -1330,10 +1331,10 @@ expand_irp (int irpc, size_t idx, sb *in
   if (f.name.len == 0)
     return _("missing model parameter");
 
-  h = hash_new ();
-  err = hash_jam (h, sb_terminate (&f.name), &f);
-  if (err != NULL)
-    return err;
+  h = htab_create_alloc (16, hash_formal_entry, eq_formal_entry,
+			 NULL, xcalloc, free);
+
+  htab_insert (h, formal_entry_alloc (sb_terminate (&f.name), &f));
 
   f.index = 1;
   f.next = NULL;
@@ -1392,7 +1393,7 @@ expand_irp (int irpc, size_t idx, sb *in
 	}
     }
 
-  hash_die (h);
+  htab_delete (h);
   sb_kill (&f.actual);
   sb_kill (&f.def);
   sb_kill (&f.name);
diff -rup binutils.orig/gas/macro.h binutils-2.35/gas/macro.h
--- binutils.orig/gas/macro.h	2021-08-11 17:33:12.484488595 +0100
+++ binutils-2.35/gas/macro.h	2021-08-11 17:43:57.989347554 +0100
@@ -63,7 +63,7 @@ typedef struct macro_struct
   sb sub;				/* Substitution text.  */
   int formal_count;			/* Number of formal args.  */
   formal_entry *formals;		/* Pointer to list of formal_structs.  */
-  struct hash_control *formal_hash;	/* Hash table of formals.  */
+  struct htab *formal_hash;		/* Hash table of formals.  */
   const char *name;			/* Macro name.  */
   const char *file;				/* File the macro was defined in.  */
   unsigned int line;			/* Line number of definition.  */
@@ -79,7 +79,97 @@ extern int macro_nest;
 
 /* The macro hash table.  */
 
-extern struct hash_control *macro_hash;
+extern struct htab *macro_hash;
+
+struct macro_hash_entry
+{
+  const char *name;
+  macro_entry *macro;
+};
+
+typedef struct macro_hash_entry macro_hash_entry_t;
+
+/* Hash function for a macro_hash_entry.  */
+
+static inline hashval_t
+hash_macro_entry (const void *e)
+{
+  const macro_hash_entry_t *entry = (const macro_hash_entry_t *) e;
+  return htab_hash_string (entry->name);
+}
+
+/* Equality function for a macro_hash_entry.  */
+
+static inline int
+eq_macro_entry (const void *a, const void *b)
+{
+  const macro_hash_entry_t *ea = (const macro_hash_entry_t *) a;
+  const macro_hash_entry_t *eb = (const macro_hash_entry_t *) b;
+
+  return strcmp (ea->name, eb->name) == 0;
+}
+
+static inline macro_hash_entry_t *
+macro_entry_alloc (const char *name, macro_entry *macro)
+{
+  macro_hash_entry_t *entry = XNEW (macro_hash_entry_t);
+  entry->name = name;
+  entry->macro = macro;
+  return entry;
+}
+
+static inline macro_entry *
+macro_entry_find (htab_t table, const char *name)
+{
+  macro_hash_entry_t needle = { name, NULL };
+  macro_hash_entry_t *entry = htab_find (table, &needle);
+  return entry != NULL ? entry->macro : NULL;
+}
+
+struct formal_hash_entry
+{
+  const char *name;
+  formal_entry *formal;
+};
+
+typedef struct formal_hash_entry formal_hash_entry_t;
+
+/* Hash function for a macro_hash_entry.  */
+
+static inline hashval_t
+hash_formal_entry (const void *e)
+{
+  const formal_hash_entry_t *entry = (const formal_hash_entry_t *) e;
+  return htab_hash_string (entry->name);
+}
+
+/* Equality function for a formal_hash_entry.  */
+
+static inline int
+eq_formal_entry (const void *a, const void *b)
+{
+  const formal_hash_entry_t *ea = (const formal_hash_entry_t *) a;
+  const formal_hash_entry_t *eb = (const formal_hash_entry_t *) b;
+
+  return strcmp (ea->name, eb->name) == 0;
+}
+
+static inline formal_hash_entry_t *
+formal_entry_alloc (const char *name, formal_entry *formal)
+{
+  formal_hash_entry_t *entry = XNEW (formal_hash_entry_t);
+  entry->name = name;
+  entry->formal = formal;
+  return entry;
+}
+
+static inline formal_entry *
+formal_entry_find (htab_t table, const char *name)
+{
+  formal_hash_entry_t needle = { name, NULL };
+  formal_hash_entry_t *entry = htab_find (table, &needle);
+  return entry != NULL ? entry->formal : NULL;
+}
 
 extern int buffer_and_nest (const char *, const char *, sb *,
 			    size_t (*) (sb *));
diff -rup binutils.orig/gas/read.c binutils-2.35/gas/read.c
--- binutils.orig/gas/read.c	2021-08-11 17:33:12.205490395 +0100
+++ binutils-2.35/gas/read.c	2021-08-11 17:44:41.265069954 +0100
@@ -293,7 +293,53 @@ address_bytes (void)
 
 /* Set up pseudo-op tables.  */
 
-static struct hash_control *po_hash;
+struct po_entry
+{
+  const char *poc_name;
+
+  const pseudo_typeS *pop;
+};
+
+typedef struct po_entry po_entry_t;
+
+/* Hash function for a po_entry.  */
+
+static hashval_t
+hash_po_entry (const void *e)
+{
+  const po_entry_t *entry = (const po_entry_t *) e;
+  return htab_hash_string (entry->poc_name);
+}
+
+/* Equality function for a po_entry.  */
+
+static int
+eq_po_entry (const void *a, const void *b)
+{
+  const po_entry_t *ea = (const po_entry_t *) a;
+  const po_entry_t *eb = (const po_entry_t *) b;
+
+  return strcmp (ea->poc_name, eb->poc_name) == 0;
+}
+
+static po_entry_t *
+po_entry_alloc (const char *poc_name, const pseudo_typeS *pop)
+{
+  po_entry_t *entry = XNEW (po_entry_t);
+  entry->poc_name = poc_name;
+  entry->pop = pop;
+  return entry;
+}
+
+static const pseudo_typeS *
+po_entry_find (htab_t table, const char *poc_name)
+{
+  po_entry_t needle = { poc_name, NULL };
+  po_entry_t *entry = htab_find (table, &needle);
+  return entry != NULL ? entry->pop : NULL;
+}
+
+static struct htab *po_hash;
 
 static const pseudo_typeS potable[] = {
   {"abort", s_abort, 0},
@@ -512,14 +558,14 @@ static const char *pop_table_name;
 void
 pop_insert (const pseudo_typeS *table)
 {
-  const char *errtxt;
   const pseudo_typeS *pop;
   for (pop = table; pop->poc_name; pop++)
     {
-      errtxt = hash_insert (po_hash, pop->poc_name, (char *) pop);
-      if (errtxt && (!pop_override_ok || strcmp (errtxt, "exists")))
-	as_fatal (_("error constructing %s pseudo-op table: %s"), pop_table_name,
-		  errtxt);
+      int exists = po_entry_find (po_hash, pop->poc_name) != NULL;
+      if (!pop_override_ok && exists)
+	as_fatal (_("error constructing %s pseudo-op table"), pop_table_name);
+      else if (!exists)
+	htab_insert (po_hash, po_entry_alloc (pop->poc_name, pop));
     }
 }
 
@@ -538,7 +584,8 @@ pop_insert (const pseudo_typeS *table)
 static void
 pobegin (void)
 {
-  po_hash = hash_new ();
+  po_hash = htab_create_alloc (16, hash_po_entry, eq_po_entry, NULL,
+			       xcalloc, xfree);
 
   /* Do the target-specific pseudo ops.  */
   pop_table_name = "md";
@@ -817,7 +864,7 @@ read_a_source_file (const char *name)
   char next_char;
   char *s;		/* String of symbol, '\0' appended.  */
   int temp;
-  pseudo_typeS *pop;
+  const pseudo_typeS *pop;
 
 #ifdef WARN_COMMENTS
   found_comment = 0;
@@ -1067,7 +1114,7 @@ read_a_source_file (const char *name)
 		    {
 		      /* The MRI assembler uses pseudo-ops without
 			 a period.  */
-		      pop = (pseudo_typeS *) hash_find (po_hash, s);
+		      pop = po_entry_find (po_hash, s);
 		      if (pop != NULL && pop->poc_handler == NULL)
 			pop = NULL;
 		    }
@@ -1082,7 +1129,7 @@ read_a_source_file (const char *name)
 			 already know that the pseudo-op begins with a '.'.  */
 
 		      if (pop == NULL)
-			pop = (pseudo_typeS *) hash_find (po_hash, s + 1);
+			pop = po_entry_find (po_hash, s + 1);
 		      if (pop && !pop->poc_handler)
 			pop = NULL;
 
@@ -2723,10 +2770,10 @@ s_macro (int ignore ATTRIBUTE_UNUSED)
 	}
 
       if (((NO_PSEUDO_DOT || flag_m68k_mri)
-	   && hash_find (po_hash, name) != NULL)
+	   && po_entry_find (po_hash, name) != NULL)
 	  || (!flag_m68k_mri
 	      && *name == '.'
-	      && hash_find (po_hash, name + 1) != NULL))
+	      && po_entry_find (po_hash, name + 1) != NULL))
 	as_warn_where (file,
 		 line,
 		 _("attempt to redefine pseudo-op `%s' ignored"),
@@ -6112,7 +6159,7 @@ s_ignore (int arg ATTRIBUTE_UNUSED)
 void
 read_print_statistics (FILE *file)
 {
-  hash_print_statistics (file, "pseudo-op table", po_hash);
+  htab_print_statistics (file, "pseudo-op table", po_hash);
 }
 
 /* Inserts the given line into the input stream.
Only in binutils-2.35/gas: read.c.orig
Only in binutils-2.35/gas: read.c.rej
diff -rup binutils.orig/gas/symbols.c binutils-2.35/gas/symbols.c
--- binutils.orig/gas/symbols.c	2021-08-11 17:33:12.486488583 +0100
+++ binutils-2.35/gas/symbols.c	2021-08-11 17:44:52.579997372 +0100
@@ -151,6 +151,57 @@ struct local_symbol
 #endif
 };
 
+struct symbol_entry
+{
+  const char *symbol_name;
+  hashval_t hash;
+  void *symbol;
+};
+
+typedef struct symbol_entry symbol_entry_t;
+
+/* Hash function for a symbol_entry.  */
+
+static hashval_t
+hash_symbol_entry (const void *e)
+{
+  symbol_entry_t *entry = (symbol_entry_t *) e;
+  if (entry->hash == 0)
+    entry->hash = htab_hash_string (entry->symbol_name);
+
+  return entry->hash;
+}
+
+/* Equality function for a symbol_entry.  */
+
+static int
+eq_symbol_entry (const void *a, const void *b)
+{
+  const symbol_entry_t *ea = (const symbol_entry_t *) a;
+  const symbol_entry_t *eb = (const symbol_entry_t *) b;
+
+  return strcmp (ea->symbol_name, eb->symbol_name) == 0;
+}
+
+static symbol_entry_t *
+symbol_entry_alloc (const char *symbol_name, void *symbol)
+{
+  symbol_entry_t *entry = XNEW (symbol_entry_t);
+  entry->symbol_name = symbol_name;
+  entry->hash = 0;
+  entry->symbol = symbol;
+  return entry;
+}
+
+static void *
+symbol_entry_find (htab_t table, const char *symbol_name)
+{
+  symbol_entry_t needle = { symbol_name, 0, NULL };
+  symbol_entry_t *entry = htab_find (table, &needle);
+  return entry != NULL ? entry->symbol : NULL;
+}
+
+
 #define local_symbol_converted_p(l) ((l)->lsy_section == reg_section)
 #define local_symbol_mark_converted(l) ((l)->lsy_section = reg_section)
 #define local_symbol_resolved_p(l) ((l)->lsy_flags.sy_resolved)
@@ -169,10 +220,10 @@ extern int new_broken_words;
 #endif
 
 /* symbol-name => struct symbol pointer */
-static struct hash_control *sy_hash;
+static htab_t sy_hash;
 
 /* Table of local symbols.  */
-static struct hash_control *local_hash;
+static htab_t local_hash;
 
 /* Below are commented in "symbols.h".  */
 symbolS *symbol_rootP;
@@ -340,7 +391,7 @@ local_symbol_make (const char *name, seg
   local_symbol_set_frag (ret, frag);
   ret->lsy_value = val;
 
-  hash_jam (local_hash, name_copy, (void *) ret);
+  htab_insert (local_hash, symbol_entry_alloc (name_copy, ret));
 
   return ret;
 }
@@ -377,7 +428,7 @@ local_symbol_convert (struct local_symbo
   local_symbol_mark_converted (locsym);
   local_symbol_set_real_symbol (locsym, ret);
 
-  hash_jam (local_hash, locsym->lsy_name, NULL);
+  htab_insert (local_hash, symbol_entry_alloc (locsym->lsy_name, NULL));
 
   return ret;
 }
@@ -616,26 +667,16 @@ colon (/* Just seen "x:" - rattle symbol
 void
 symbol_table_insert (symbolS *symbolP)
 {
-  const char *error_string;
-
   know (symbolP);
   know (S_GET_NAME (symbolP));
 
   if (LOCAL_SYMBOL_CHECK (symbolP))
-    {
-      error_string = hash_jam (local_hash, S_GET_NAME (symbolP),
-			       (void *) symbolP);
-      if (error_string != NULL)
-	as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
-		  S_GET_NAME (symbolP), error_string);
-      return;
-    }
-
-  if ((error_string = hash_jam (sy_hash, S_GET_NAME (symbolP), (void *) symbolP)))
-    {
-      as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
-		S_GET_NAME (symbolP), error_string);
-    }				/* on error  */
+    htab_insert (local_hash,
+		 symbol_entry_alloc (S_GET_NAME (symbolP),
+				     (struct local_symbol *)symbolP));
+  else
+    htab_insert (sy_hash, symbol_entry_alloc (S_GET_NAME (symbolP),
+					      (struct local_symbol *)symbolP));
 }
 
 /* If a symbol name does not exist, create it as undefined, and insert
@@ -869,14 +910,11 @@ symbol_find_exact (const char *name)
 symbolS *
 symbol_find_exact_noref (const char *name, int noref)
 {
-  struct local_symbol *locsym;
-  symbolS* sym;
+  symbolS *sym = symbol_entry_find (local_hash, name);
+  if (sym)
+    return sym;
 
-  locsym = (struct local_symbol *) hash_find (local_hash, name);
-  if (locsym != NULL)
-    return (symbolS *) locsym;
-
-  sym = ((symbolS *) hash_find (sy_hash, name));
+  sym = symbol_entry_find (sy_hash, name);
 
   /* Any references to the symbol, except for the reference in
      .weakref, must clear this flag, such that the symbol does not
@@ -1670,15 +1708,16 @@ resolve_symbol_value (symbolS *symp)
   return final_val;
 }
 
-static void resolve_local_symbol (const char *, void *);
-
 /* A static function passed to hash_traverse.  */
 
-static void
-resolve_local_symbol (const char *key ATTRIBUTE_UNUSED, void *value)
+static int
+resolve_local_symbol (void **slot, void *arg ATTRIBUTE_UNUSED)
 {
-  if (value != NULL)
-    resolve_symbol_value ((symbolS *) value);
+  symbol_entry_t *entry = *((symbol_entry_t **) slot);
+  if (entry->symbol != NULL)
+    resolve_symbol_value ((symbolS *) entry->symbol);
+
+  return 1;
 }
 
 /* Resolve all local symbols.  */
@@ -1686,7 +1725,7 @@ resolve_local_symbol (const char *key AT
 void
 resolve_local_symbol_values (void)
 {
-  hash_traverse (local_hash, resolve_local_symbol);
+  htab_traverse (local_hash, resolve_local_symbol, NULL);
 }
 
 /* Obtain the current value of a symbol without changing any
@@ -2988,8 +3027,10 @@ symbol_begin (void)
 {
   symbol_lastP = NULL;
   symbol_rootP = NULL;		/* In case we have 0 symbols (!!)  */
-  sy_hash = hash_new ();
-  local_hash = hash_new ();
+  sy_hash = htab_create_alloc (16, hash_symbol_entry, eq_symbol_entry,
+			       NULL, xcalloc, free);
+  local_hash = htab_create_alloc (16, hash_symbol_entry, eq_symbol_entry,
+				  NULL, xcalloc, free);
 
   memset ((char *) (&abs_symbol), '\0', sizeof (abs_symbol));
 #if defined (EMIT_SECTION_SYMBOLS) || !defined (RELOC_REQUIRES_SYMBOL)
@@ -3244,8 +3285,8 @@ print_expr (expressionS *exp)
 void
 symbol_print_statistics (FILE *file)
 {
-  hash_print_statistics (file, "symbol table", sy_hash);
-  hash_print_statistics (file, "mini local symbol table", local_hash);
+  htab_print_statistics (file, "symbol table", sy_hash);
+  htab_print_statistics (file, "mini local symbol table", local_hash);
   fprintf (file, "%lu mini local symbols created, %lu converted\n",
 	   local_symbol_count, local_symbol_conversion_count);
 }
